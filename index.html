<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>íŒŒì´í”„ 3D (KS ê·œê²© íŒŒì´í”„ + STL ë¶€ì†)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }



:root{
  --topBarH: 52px;     /* ìƒë‹¨ë°” ì‹¤ì œ ë†’ì´ì— ë§ì¶° ì¡°ì ˆ */
  --panelGap: 10px;
}

/* ìƒë‹¨ íŒ¨ë„ì´ í•­ìƒ ìœ„ì— */
#topViewBar{
  z-index: 50;
}

/* ìš°ì¸¡ íŒ¨ë„(ìƒˆë¡œ ë§Œë“¤ ê±°) */
#rightUI{
  position: fixed;
  top: calc(var(--topBarH) + var(--panelGap));
  right: 10px;
  z-index: 40; /* ìƒë‹¨ë°”ë³´ë‹¤ ë‚®ê²Œ */
  width: 220px;
  max-height: calc(95vh - var(--topBarH));
  overflow-y: auto;

  background: rgba(30, 30, 30, 0.96);
  color: #f0f0f0;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.35);
  font-size: 13px;
}

/* í˜¹ì‹œ ì¢Œì¸¡ íŒ¨ë„ë„ ìƒë‹¨ë°” ë°‘ìœ¼ë¡œ ë‚´ë¦¬ê³  ì‹¶ìœ¼ë©´(ì„ íƒ) */
#ui{
  top: calc(var(--topBarH) + var(--panelGap));
  z-index: 30;
}




/* ===== ìƒë‹¨ ë²„íŠ¼ ê³µí†µ ìŠ¤íƒ€ì¼ ===== */
.top-btn {
  border: none;
  border-radius: 6px;
  padding: 6px 12px;
  font-size: 12px;
  font-weight: 500;
  background: #3a3a3a;
  color: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
  transition:
    background 0.15s ease,
    box-shadow 0.15s ease,
    transform 0.05s ease;
}
.top-btn.active {
  background: #6a6a6a;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25);
}


/* hover */
.top-btn:hover {
  background: #4a4a4a;
}

/* ëˆŒë¦¼ */
.top-btn:active {
  background: #2f2f2f;
  transform: translateY(1px);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.15);
}

/* ë¹„í™œì„± ëŠë‚Œ (ì„ íƒ) */
.top-btn.disabled {
  opacity: 0.45;
  pointer-events: none;
}






    /* ì¢Œì¸¡ UI íŒ¨ë„ */
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.96);
      color: #f0f0f0;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
      font-size: 13px;
      width:  200px;
      box-sizing: border-box;
    
max-height: 95vh;
  overflow-y: auto;
}


    /* ìƒë‹¨ View ë°” */
#topViewBar {
  position: fixed;
  top: 10px;
  left: 250px;
  right: 10px;
  height: 40px;
  display: flex;
  justify-content: space-between; /* â† ì™¼ìª½/ì˜¤ë¥¸ìª½ ìë™ ë¶„ë¦¬ */
  align-items: center;
  padding: 4px 10px;
  background: rgba(30,30,30,0.95);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.35);
  z-index: 25;
}

/* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
#topViewBar .view-btn, 
#topViewBar .edit-btn {
  border: none;
  border-radius: 4px;
  padding: 4px 10px;
  font-size: 12px;
  background: #3b3b3b;
  color: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
}

#topViewBar .view-btn:hover,
#topViewBar .edit-btn:hover {
  background: #4a4a4a;
}

/* ì™¼ìª½ ë²„íŠ¼ ê·¸ë£¹ */
#topViewBar .leftGroup {
  display: flex;
  gap: 8px;
}

/* ì˜¤ë¥¸ìª½ ë²„íŠ¼ ê·¸ë£¹ */
#topViewBar .rightGroup {
  display: flex;
  gap: 8px;
}




    #ui button,
    #ui input,
    #ui label {
      margin: 3px 0;
      font-size: 12px;
    }

    #ui button {
      width: 100%;
      text-align: left;
      padding: 6px 8px;
      border: none;
      border-radius: 4px;
      background: #3b3b3b;
      color: #f0f0f0;
      cursor: pointer;
    }

    #ui button:hover {
      background: #4a4a4a;
    }

    .file-item {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
    }
    .file-item:hover {
      background: #444;
    }

    .ui-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
    }

    .ui-group {
      margin-bottom: 14px;
      padding-bottom: 10px;
      border-bottom: 1px solid #444;
    }

    .ui-header {
      font-weight: bold;
      font-size: 12px;
      margin: 6px 0;
      opacity: .8;
    }

    /* 3D ìº”ë²„ìŠ¤ ì „ì²´ í™”ë©´ */
    canvas#c {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      display: block;
    }

    /* ë“œë˜ê·¸ ë°•ìŠ¤ ì„ íƒìš© */
    #selectionRect {
      position: fixed;
      border: 1.5px solid #33aaff;
      background: rgba(51,153,255,0.25);
      pointer-events: none;
      z-index: 15;
      display: none;
    }

    /* íšŒì „ ê°ë„ í‘œì‹œ UI */
    #angleLabel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -120%);
      font-size: 22px;
      font-weight: bold;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      display: none;
      pointer-events: none;
      z-index: 9999;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    /* ===== Fitting 15A / 20A í† ê¸€ ë²„íŠ¼ ===== */
.ui-btn {
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 12px;
  background: #3a3a3a;
  color: #f0f0f0;
  cursor: pointer;
}






/* =========================
   âœ… ìš°ì¸¡ UI íŒ¨ë„ (Plate ì „ìš©)
========================= */
#uiRight{
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 20;

  background: rgba(30, 30, 30, 0.96);
  color: #f0f0f0;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.35);

  width: 220px;
  box-sizing: border-box;

  max-height: 95vh;
  overflow-y: auto;
}

#uiRight .ui-title{
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

#uiRight .ui-group{
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid #444;
}

#uiRight .ui-header{
  font-weight: bold;
  font-size: 12px;
  margin: 6px 0;
  opacity: .8;
}

/* âœ… ìŠ¬ë¼ì´ë” ì¤„ */
.plate-row{
  display:flex;
  align-items:center;
  gap:8px;
}
.plate-row input[type="range"]{
  width: 100%;
}

/* âœ… íŒ”ë ˆíŠ¸ ìŠ¤ì™€ì¹˜ */
.color-swatches{
  display:grid;
  grid-template-columns: repeat(5, 1fr);
  gap:6px;
  margin-top:6px;
}

.swatch{
  width:22px;
  height:22px;
  border-radius:4px;
  cursor:pointer;
  border:1px solid rgba(255,255,255,0.35);
}

.swatch:hover{
  outline:2px solid #ffffff;
}

.swatch.active {
      outline: 2px solid #ffffff;
      outline-offset: 1px;
    }
    
/* âœ… í˜„ì¬ ì„ íƒ ìƒ‰ í‘œì‹œ(ì„ íƒ ì‚¬í•­) */
#plateColorPreview{
  width: 22px;
  height: 22px;
  border-radius: 4px;
  border: 1px solid rgba(255,255,255,0.35);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
}


  /* âœ… STL ì¹˜ìˆ˜ ë³´ì • ì…ë ¥ì„ 'ê°€ë¡œ í•œ ì¤„'ë¡œ */
.stl-off-row{
  display:flex;
  gap:6px;
  margin-bottom:6px;
}
.stl-off-item{
  flex:1;
  min-width:0;
  font-size:11px;
  opacity:.85;
}
.stl-off-item input{
  width:100%;
  margin-top:2px;
  box-sizing:border-box;
}

  
.swatch.active{
  outline:2px solid #ffffff;
  outline-offset:1px;
}

.swatch.custom{
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
}

.swatch.empty{
  background: transparent !important;
  border: 1px dashed rgba(255,255,255,0.35) !important;
  opacity: 0.9;
}
.swatch.empty:hover{
  outline:2px solid rgba(255,255,255,0.6);
}

/* --- í¬íŠ¸ í¸ì§‘ UI ìŠ¤íƒ€ì¼ --- */
.port-edit-row { display: flex; gap: 4px; margin-bottom: 5px; align-items: center; }
.port-edit-row input { 
  width: 55px; background: #222; color: #fff; border: 1px solid #555; 
  font-size: 11px; padding: 2px; border-radius: 3px;
}
.port-header { font-weight: bold; margin-bottom: 5px; font-size: 11px; color: #aaa; }




/* â–¼â–¼â–¼ <style> íƒœê·¸ ì•ˆìª½ì— ë„£ìœ¼ì„¸ìš” â–¼â–¼â–¼ */

/* ê·¸ë¦¬ë“œ ë° íƒ­ ìŠ¤íƒ€ì¼ */
.grid-2 { 
  display: grid; 
  grid-template-columns: 1fr 1fr; /* 1:1 ë¹„ìœ¨ 2ì—´ */
  gap: 5px; 
  margin-bottom: 5px; 
}

.tab-btn {
  padding: 8px 0;
  background: #444;
  color: #aaa;
  font-weight: bold;
  border: 1px solid #555;
  cursor: pointer;
  border-radius: 4px;
}
/* ì„ íƒëœ íƒ­ (ê°•ì œ ì ìš©) */
.tab-btn.active {
  background: #33aaff !important;     /* !important ì¶”ê°€ */
  color: white !important;            /* !important ì¶”ê°€ */
  border-color: #33aaff !important;   /* !important ì¶”ê°€ */
  box-shadow: 0 0 5px rgba(51, 170, 255, 0.5);
}
.ui-divider {
  border: 0; 
  border-top: 1px solid rgba(255,255,255,0.15); 
  margin: 10px 0;
}



/* ğŸ“± ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ë°˜ì‘í˜• ìµœì í™” */
@media screen and (max-width: 768px) {
  #ui, #rightUI {
    width: 100% !important;
    position: relative !important;
    max-height: 40vh !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    border-radius: 0;
    margin-bottom: 5px;
  }
  
  #topViewBar {
    position: relative !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: auto !important;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    padding: 10px 5px;
  }

  .top-btn {
    padding: 10px 8px; /* ì†ê°€ë½ í„°ì¹˜ìš© í¬ê¸° í™•ëŒ€ */
    font-size: 11px;
    flex: 1 1 30%; /* ë²„íŠ¼ì´ ì¤„ë°”ê¿ˆë˜ë©° ê½‰ ì°¨ê²Œ */
    text-align: center;
  }

  canvas#c {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1; /* ìº”ë²„ìŠ¤ë¥¼ ë°°ê²½ìœ¼ë¡œ ë°€ì–´ ë ˆì´ì•„ì›ƒ ë°©í•´ ê¸ˆì§€ */
  }
}
</style>
</head>

<body>

<!-- íšŒì „ ê°ë„ í‘œì‹œ -->
<div id="angleLabel">0Â°</div>


<!-- ìƒë‹¨ View ë°” -->
<div id="topViewBar">
  <!-- ì™¼ìª½: ë·° ì „í™˜ -->
  <div class="leftGroup">
  <button class="top-btn" onclick="setView('front')" style="color: #91f17e;">FRONT</button>
  <button class="top-btn" onclick="setView('back')" style="color: #91f17e;">BACK</button>
  <button class="top-btn" onclick="setView('left')" style="color: #91f17e;">LEFT</button>
  <button class="top-btn" onclick="setView('right')" style="color: #91f17e;">RIGHT</button>
  <button class="top-btn" onclick="setView('top')" style="color: #91f17e;">TOP</button>
  <button class="top-btn" onclick="focusOnSelection()" style="color: #91f17e;">(X)Select View</button>
  <button class="top-btn" onclick="resetCamera()" style="color: #91f17e;">(C)V-Reset</button>


  </div>

 <!-- ì¤‘ì•™: ì •ë ¬ -->
<div class="centerGroup">
  <button class="top-btn" onclick="attachSelectedGroup()" style="color: #e3eb7b;">(A)SNAP</button>
  <button class="top-btn" onclick="placeSelectionOnGround()" style="color: #e3eb7b;">(B)FLOOR</button>
  <button class="top-btn" onclick="alignSelectionAxis('z')" style="color: #e3eb7b;">RED</button>
  <button class="top-btn" onclick="alignSelectionAxis('x')" style="color: #e3eb7b;">BLUE</button>
  <button class="top-btn" onclick="alignSelectionAxis('y')" style="color: #e3eb7b;">TOP</button>
  <button class="top-btn" onclick="alignSelectionToAnchorCenter({axes:'xyz'})" style="color: #e3eb7b;">CENTER</button>
  <button class="top-btn" onclick="snapPlateToPillarsTop()" style="color: #e3eb7b;">TOP END</button>
</div>





  <!-- ì˜¤ë¥¸ìª½: í¸ì§‘ + ì •ë ¬ -->
  <div class="rightGroup">
    <button class="top-btn" onclick="undo()" style="color: #ff7070;">â†© Undo</button>
  <button class="top-btn" onclick="redo()" style="color: #ff7070;">â†ª Redo</button>

  <button class="top-btn" onclick="exportSelectedToSTL()" style="color: #75acff;">STL ë‚´ë³´ë‚´ê¸°</button>
  <button class="top-btn" onclick="saveProjectJSON()" style="color: #75acff;">ì €ì¥</button>
  <button class="top-btn" onclick="document.getElementById('projectFileInput').click()" style="color: #75acff;">ë¶ˆëŸ¬ì˜¤ê¸°</button>
  <input id="projectFileInput" type="file" accept=".json" style="display:none" />
</div>
</div>

</div>
</div>





<!-- ì¢Œì¸¡ UI íŒ¨ë„ -->
<div id="ui">
  <div class="ui-title">Pipe 3D Toolkit</div>
<!-- === STL íŒŒì¼ === -->
  <div class="ui-group">
    <div class="ui-header">ğŸ§± STL íŒŒì¼</div>
    <input type="file" id="fileInput" multiple accept=".stl" />
    <button onclick="spawnSelected()">ğŸ“ STL ë°°ì¹˜</button>
    <div id="fileList" class="file-list"></div>
  
    <div class="ui-header">ğŸ“ STL ì¹˜ìˆ˜ ë³´ì • (mm)</div>
    <div class="stl-off-row">
  <label class="stl-off-item">ê°€ë¡œ(X)+
    <input id="stlOffX" type="number" step="0" value="0">
  </label>
  <label class="stl-off-item">ì„¸ë¡œ(Z)+
    <input id="stlOffZ" type="number" step="0" value="0">
  </label>
  <label class="stl-off-item">ë†’ì´(Y)+
    <input id="stlOffY" type="number" step="0" value="0">
  </label>
  
</div>
    <button onclick="applySTLOffsetToSelection()">âœ… ì„ íƒ ë¶€ì†ì— ì ìš©</button>
    <!--  <button onclick="saveSTLOffsetPresetForSelection()">ğŸ’¾ ì´ ë¶€ì† ê¸°ë³¸ê°’ ì €ì¥</button>
    <button onclick="clearSTLOffsetPresetForSelection()">ğŸ§¹ ì´ ë¶€ì† ê¸°ë³¸ê°’ ì‚­ì œ</button>=== -->
    <div id="stlOffHint" style="font-size:11px; opacity:.75; margin-top:6px; line-height:1.35;">
     
    </div>

  </div>

  <!-- === KS ë¶€ì† === -->
  <div class="ui-group">
  <div class="ui-header">Fittings</div>

  <div class="grid-2">
    <button id="btnTab15" class="tab-btn active" onclick="setNominalMode('15A')">15A</button>
    <button id="btnTab20" class="tab-btn" onclick="setNominalMode('20A')">20A</button>
  </div>
  
  <hr class="ui-divider">

  <div class="grid-2">
    <button onclick="spawnSocket()" style="color: #ffffff;">ì†Œì¼“</button>
<button onclick="spawnElbow()" style="color: #ffffff;">90Â°ì—˜ë³´</button>
<button onclick="spawn45Elbow()" style="color: #ffffff;">45Â°ì—˜ë³´</button>
<button onclick="spawnSOElbow()" style="color: #ffffff;">S.O.ì—˜ë³´</button>

<button onclick="spawnTee()" style="color: #ffffff;">í‹°</button>
<button onclick="spawnCrossTee()" style="color: #ffffff;">í¬ë¡œìŠ¤ í‹°</button>
<button onclick="spawnSOTee()" style="color: #ffffff;">S.O.í‹°</button>

<button onclick="spawnCap()" style="color: #ffffff;">ìº¡</button>
<button onclick="spawnPlug()" style="color: #ffffff;">í”ŒëŸ¬ê·¸</button>

<button onclick="spawnUnion()" style="color: #ffffff;">ìœ ë‹ˆì˜¨</button>
<button onclick="spawnFlange()" style="color: #ffffff;">í”Œëœì§€</button>

<button onclick="spawnReducer()" style="color: #ffffff;">ë ˆë“€ì„œ</button> 
<button onclick="spawnBushing()" style="color: #ffffff;">ë¶€ì‹±</button>
    </div>
</div>
<div class="ui-group">
  <div class="ui-header">ì½¤ë¹„ë½</div>

  <div class="grid-2">
<button onclick="addMmCubeFitting(12)" style="color: #9ab2ff;">12mm</button>
<button onclick="addMmCubeFitting(15)" style="color: #9ab2ff;">15mm</button>
    </div>
</div>


  
  <!-- === íŒŒì´í”„ === -->
  <div class="ui-group">
    <div class="ui-header">ğŸ“ Pipe</div>
    <button onclick="spawnPipeWithPrompt('15A')" style="color: #ffb775;">SPP 15A</button>
<button onclick="spawnPipeWithPrompt('20A')" style="color: #ffb775;">SPP 20A</button>
<button onclick="addKSPipePrompt('12mm')" style="color: #ffb775;">STS 12mm</button>
<button onclick="addKSPipePrompt('15mm')" style="color: #ffb775;">STS 15mm</button>
    <button onclick="spawnAutoPipeBetweenSelection()" style="color: #ffb775;">Auto Pipe Connect</button>
  </div>






<!-- ìš°ì¸¡ UI íŒ¨ë„ -->
<div id="rightUI">
  <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
</div>


<!-- STL ë‚´ë³´ë‚´ê¸°  í”„ë¡œì íŠ¸ ì €ì¥ ë¶ˆëŸ¬ì˜¤ê¸° ìƒë‹¨ ìš°ì¸¡ìœ¼ë¡œ ì´ë™  -->
<!-- <div class="ui-group">
  <div class="ui-header">ğŸ“¤ ë‚´ë³´ë‚´ê¸°</div>
  <button onclick="exportSelectedToSTL()">ğŸ’¾ STL ë‚´ë³´ë‚´ê¸°</button>
</div>
<div class="ui-group">
  <div class="ui-header">ğŸ’¾ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°</div>
  <button onclick="saveProjectJSON()">ğŸ“Œ í”„ë¡œì íŠ¸ ì €ì¥</button>
  <button onclick="document.getElementById('projectFileInput').click()">ğŸ“‚ í”„ë¡œì íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°</button>
  <input id="projectFileInput" type="file" accept=".json" style="display:none" />
</div>
</div> -->
 

<!-- ì‚¬ê° ì›í˜• -->
  <div style="margin-top:10px;">
    <div style="opacity:0.85; font-size:12px; margin-bottom:6px;"></div>
    <div style="display:flex; gap:6px;">
       <button onclick="spawnRectPlateWithPrompt()">â¬œ</button>
    <button onclick="spawnCirclePlatePrompt()">â¬¤</button>
    </div>
  </div>
  <hr style="border:none; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

  <div>
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="opacity:0.85; font-size:12px;">íŒ íˆ¬ëª…ë„</div>
      <div id="plateOpacityLabel" style="font-size:12px;">100%</div>
    </div>
    <input id="plateOpacity" type="range" min="5" max="100" value="100" style="width:100%;">
    <div style="opacity:0.7; font-size:11px; margin-top:4px;">
     <!--  ì„ íƒëœ ì‚¬ê°/ì›í˜• íŒì— ì‹¤ì‹œê°„ ì ìš©ë©ë‹ˆë‹¤.-->
    </div>
  </div>

  <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
    <b></b>
    <button onclick="applyPlateStyleFromUI()">ì„ íƒ ì ìš©</button>
  </div>

  <hr style="border:none; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

  <div>
    <div style="opacity:0.85; font-size:12px; margin-bottom:6px;">ì»¬ëŸ¬</div>




  <!-- ì»¬ëŸ¬ í”¼ì»¤ (ì„ì‹œ ë¹„í™œì„±í™”)-->

<div id="plateColorBar" style="position:relative; width:100%; height:36px; border-radius:6px; overflow:hidden; background:#2f2f2f;">
  <input
  id="plateColorPicker"
  type="color"
  value="#ffffff"
  onchange="updatePaletteAndApply(this.value)"
  style="
    width: 100%;
    height: 36px;
    border: none;
    background: transparent;
    cursor: pointer;
  "/>
</div>


     <div class="ui-group">
  <div class="ui-header"></div>

  <div class="color-swatches">

  <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div> 
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div> 
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div> 
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>  
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div>
    <div class="swatch empty" data-color="" title="ë¹ˆ ìŠ¬ë¡¯"></div> 
</div>
</div>

  </div>
</div>


</div>

<div id="selectionRect"></div>
<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>





<script>
"use strict";
console.clear();



let dimensionKeyDown = false;


// ì„ íƒ ìœ¤ê³½ì„ ìš© ì „ì—­ ë³€ìˆ˜
function setSelectedObject(obj) {
  updateRotationGizmo();
  try { refreshSTLOffsetUIFromSelection(); } catch(e){}
  try { syncPlateColorPickerFromSelection(); } catch(e){}
  updatePortVisuals(obj); 

}


/* =========================================================
   í”„ë¡œì íŠ¸ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° (JSON)
   - draggable ì•ˆì˜ ì˜¤ë¸Œì íŠ¸ë“¤ì„ JSONìœ¼ë¡œ ì €ì¥/ë³µì›
   - geometryê¹Œì§€ ì €ì¥í•˜ë¯€ë¡œ STL ì›ë³¸ ì—†ì–´ë„ ë³µì› ê°€ëŠ¥
========================================================= */

// ---- geometry ì§ë ¬í™”/ì—­ì§ë ¬í™” ----
function geometryToData(geo) {
  if (!geo) return null;

  // ì¸ë±ìŠ¤í˜•ì´ë©´ ê·¸ëŒ€ë¡œ ì €ì¥, ì—†ìœ¼ë©´ null
  const pos = geo.getAttribute("position");
  const nor = geo.getAttribute("normal");
  const idx = geo.index;

  return {
    type: "BufferGeometry",
    position: pos ? Array.from(pos.array) : null,
    normal: nor ? Array.from(nor.array) : null,
    index: idx ? Array.from(idx.array) : null,
    // itemSizeëŠ” position=3 normal=3 ì´ë¼ ê³ ì •ì´ë¼ ìƒëµí•´ë„ ë˜ì§€ë§Œ ì•ˆì „í•˜ê²Œ ë‚¨ê¹€
    positionItemSize: pos ? pos.itemSize : 3,
    normalItemSize: nor ? nor.itemSize : 3
  };
}



function syncPlateSwatchesFromColor(hex){
  const swatches = document.querySelectorAll(".color-swatches .swatch");
  if (!swatches.length || !hex) return;
  const norm = hex.toLowerCase();
  swatches.forEach(sw=>{
    const c = (sw.dataset.color||"").toLowerCase();
    if (c === norm) sw.classList.add("active");
    else sw.classList.remove("active");
  });
}


/* =========================================================
   âœ… Plate color picker â†’ Swatchì— ìë™ ì €ì¥/ì¶”ê°€ (+ localStorage)
   - ì»¬ëŸ¬í”¼ì»¤ì—ì„œ ê³ ë¥¸ ìƒ‰ì´ íŒ”ë ˆíŠ¸ì— ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ì¶”ê°€
   - ìƒˆë¡œê³ ì¹¨í•´ë„ ìœ ì§€(localStorage)
========================================================= */
const PLATE_SWATCH_STORE_KEY = "pipe3d_plate_custom_swatches_v1";
const MAX_CUSTOM_SWATCHES = 12;

function normHex(hex){
  if (!hex) return "";
  let h = String(hex).trim().toLowerCase();
  if (!h.startsWith("#")) h = "#" + h;
  // #rgb -> #rrggbb í™•ì¥
  if (h.length === 4) {
    h = "#" + h[1] + h[1] + h[2] + h[2] + h[3] + h[3];
  }
  return h;
}

function getSwatchContainer(){
  return document.querySelector(".color-swatches");
}

function getAllSwatches(){
  return Array.from(document.querySelectorAll(".color-swatches .swatch"));
}

function ensureSwatchDataColor(){
  // í˜¹ì‹œ data-color ëˆ„ë½ëœ ê¸°ì¡´ ìŠ¤ì™€ì¹˜ ë³´ì •
  getAllSwatches().forEach(sw=>{
    if (sw.dataset && !sw.dataset.color) {
      const bg = (sw.style && sw.style.background) ? sw.style.background : "";
      if (bg) sw.dataset.color = normHex(bg);
    }
  });
}

function loadCustomSwatches(){
  const box = getSwatchContainer();
  if (!box) return;
  let arr = [];
  try { arr = JSON.parse(localStorage.getItem(PLATE_SWATCH_STORE_KEY) || "[]"); } catch(e){ arr = []; }
  if (!Array.isArray(arr)) arr = [];

  // ê¸°ì¡´ì— ì´ë¯¸ ë“¤ì–´ìˆëŠ” ìƒ‰ì€ ì¤‘ë³µ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
  const existing = new Set(getAllSwatches().map(sw => normHex(sw.dataset.color)));
  arr.map(normHex).filter(Boolean).forEach(hex=>{
    if (existing.has(hex)) return;
    const sw = document.createElement("div");
    sw.className = "swatch custom";
    sw.dataset.color = hex;
    sw.style.background = hex;
    sw.title = "ì‚¬ìš©ì ìƒ‰ìƒ: " + hex;
    sw.addEventListener("click", ()=>applyPlateColor(hex));
    box.appendChild(sw);
    existing.add(hex);
  });
}

function saveCustomSwatchesToStorage(){
  const customs = getAllSwatches()
    .filter(sw => sw.classList.contains("custom"))
    .map(sw => normHex(sw.dataset.color))
    .filter(Boolean);

  // ìµœê·¼ ì¶”ê°€ ìˆœì„œ ìœ ì§€
  const unique = [];
  const seen = new Set();
  customs.forEach(h=>{
    if (seen.has(h)) return;
    seen.add(h);
    unique.push(h);
  });

  // ìµœëŒ€ ê°œìˆ˜ ì œí•œ(ë’¤ìª½ ê¸°ì¤€: ìµœê·¼ì— ì¶”ê°€ëœ ê²ƒì´ ë’¤ë¡œ ìŒ“ì´ë¯€ë¡œ ë§ˆì§€ë§‰ Nê°œ ìœ ì§€)
  const trimmed = unique.slice(Math.max(0, unique.length - MAX_CUSTOM_SWATCHES));
  localStorage.setItem(PLATE_SWATCH_STORE_KEY, JSON.stringify(trimmed));
}






// âœ… ì»¬ëŸ¬í”¼ì»¤ ë“œë˜ê·¸(input) ì¤‘ì—ëŠ” 'ë¯¸ë¦¬ë³´ê¸°/ë™ê¸°í™”'ë§Œ (íŒ”ë ˆíŠ¸ ì €ì¥ X)
let pendingPlateColorHex = null;
// âœ… ì»¬ëŸ¬í”¼ì»¤ì—ì„œ ìƒ‰ì„ 'ì„ íƒ í™•ì •'í•˜ë©´(ë§ˆìš°ìŠ¤ ë†“ê¸°/ì„ íƒ ì¢…ë£Œ) ìŠ¤ì™€ì¹˜ì— ì¶”ê°€
document.getElementById("plateColorPicker")?.addEventListener("change", e=>{
  const hex = e.target.value;
  if (!hex) return;

  // í˜„ì¬ìƒ‰ ë³€ìˆ˜ ë™ê¸°í™”(ìˆë‹¤ë©´)
  if (typeof currentPlateColor !== "undefined") currentPlateColor = hex;

  // âœ… íŒ”ë ˆíŠ¸(ìŠ¤ì™€ì¹˜)ì— ì €ì¥/ì¶”ê°€ (ë“œë˜ê·¸ ì¤‘ ì§€ë‚˜ê°„ ìƒ‰ì€ ì €ì¥ ì•ˆ ë¨)
  try { addOrActivateSwatch(hex); } catch(err){}

  // í•˜ì´ë¼ì´íŠ¸ ë™ê¸°í™”
  try { syncPlateSwatchesFromColor(hex); } catch(err){}
});

document.getElementById("plateColorPicker")?.addEventListener("input", e=>{
  const hex = e.target.value;
  pendingPlateColorHex = hex;
  pendingPlateColorHex = hex;
  if (typeof currentPlateColor !== "undefined") currentPlateColor = hex;
  // ê¸°ì¡´ íŒ”ë ˆíŠ¸ì— ê°™ì€ ìƒ‰ì´ ìˆìœ¼ë©´ í•˜ì´ë¼ì´íŠ¸ë§Œ
  try { syncPlateSwatchesFromColor(hex); } catch(err){}
});
function syncPlateColorPickerFromSelection() {
  const picker = document.getElementById("plateColorPicker");
  if (!picker) return;

  // ì„ íƒëœ Plate ì°¾ê¸°
  const plates =
    (selectedSet && selectedSet.size > 0)
      ? [...selectedSet].filter(o => o.userData?.isRectPlate || (o.userData?.isPlate && o.userData?.plateShape === "circle"))
      : (selectedMesh && (selectedMesh.userData?.isRectPlate || selectedMesh.userData?.isPlate) ? [selectedMesh] : []);

  if (!plates.length) return;

  const plate = plates[0]; // ì²« ë²ˆì§¸ íŒ ê¸°ì¤€

  // material ìƒ‰ìƒ ì½ê¸°
  let mat = plate.material;
  if (Array.isArray(mat)) mat = mat[0];
  if (!mat || !mat.color) return;

  const hex = `#${mat.color.getHexString()}`;

  // âœ… ì»¬ëŸ¬ í”¼ì»¤ ë™ê¸°í™”
  picker.value = hex;
  try{ syncPlateSwatchesFromColor(hex); }catch(e){}

  // (ìˆë‹¤ë©´) í˜„ì¬ ìƒ‰ ê¸°ì–µìš© ë³€ìˆ˜ë„ ë™ê¸°í™”
  if (typeof currentPlateColor !== "undefined") {
    currentPlateColor = hex;
  }
}




function createPipeBetweenWorldPoints(pA, pB, size /* "15A"|"20A"|"12mm"|"15mm" */) {
  const dir = new THREE.Vector3().subVectors(pB, pA);
  const len = dir.length();
  if (!isFinite(len) || len < 1e-6) return null;
  dir.normalize();

  const lenMm = len * MM_PER_UNIT;

  // âœ… ì™¸ê²½(OD) ê²°ì •: KS(15A/20A) ë˜ëŠ” mm íŒŒì´í”„(12mm/15mm)
  let od;
  if (typeof size === "string" && size.toLowerCase().endsWith("mm")) {
    od = parseFloat(size); // "12mm" -> 12
  } else {
    od = KS_OD[size] ?? KS_OD["15A"];
  }
  if (!isFinite(od) || od <= 0) od = KS_OD["15A"];

  const radiusUnits = (od / 2) / MM_PER_UNIT;

  // (od êµ¬í•œ ë’¤ì—)
let color = 0x3a3a3a;           // ê¸°ë³¸ íŒŒì´í”„ìƒ‰
if (od === 12 || od === 15) {  // ë„¤ ì½”ë“œì— ìˆëŠ” ì€ìƒ‰ ê·œì¹™ë„ ë™ì¼ ì ìš©í•˜ë ¤ë©´
  color = 0xbfc3c7;
}

const geo = new THREE.CylinderGeometry(radiusUnits, radiusUnits, len, 24);
const mat = new THREE.MeshStandardMaterial({
  color,
  roughness: 0.6,   // âœ… addKSPipeë‘ ë™ì¼í•˜ê²Œ
  metalness: 0.2
});

  const pipe = new THREE.Mesh(geo, mat);

  // ê°€ìš´ë°ë¡œ ì´ë™
  const mid = new THREE.Vector3().addVectors(pA, pB).multiplyScalar(0.5);
  pipe.position.copy(mid);

  // Yì¶•(0,1,0)ì„ dir ë°©í–¥ìœ¼ë¡œ íšŒì „
  const q = new THREE.Quaternion().setFromUnitVectors(
    new THREE.Vector3(0, 1, 0),
    dir
  );
  pipe.quaternion.copy(q);

  // ë©”íƒ€
  pipe.userData.isPipe = true;
  pipe.userData.size = size;
  pipe.userData.lengthMm = lenMm;
  pipe.userData.radiusMm = od / 2;

  // (ì„ íƒ) ë‚˜ì¤‘ì— ë””ë²„ê·¸/ì¬ìƒì„±ìš©
  pipe.userData.autoPipe = true;
  pipe.userData.endA = { x: pA.x, y: pA.y, z: pA.z };
  pipe.userData.endB = { x: pB.x, y: pB.y, z: pB.z };

  return pipe;
}

function spawnAutoPipeBetweenSelection() {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (targets.length !== 2) {
    alert("ìë™ íŒŒì´í”„ëŠ” 'ì •í™•íˆ 2ê°œ'ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.\n(CTRL+í´ë¦­ìœ¼ë¡œ 2ê°œ ì„ íƒ)");
    return;
  }

  const a = targets[0];
  const b = targets[1];

  // âœ… í¬íŠ¸(attach point) í›„ë³´ ìˆ˜ì§‘
  function collectAttachPoints(obj) {
    const pts = [];
    if (!obj) return pts;

    // meshë©´ ë°”ë¡œ
    if (obj.geometry) {
      pts.push(...getWorldAttachPointsForMesh(obj));
      return pts;
    }

    // groupì´ë©´ ë‚´ë¶€ meshë“¤ì—ì„œ
    if (obj instanceof THREE.Group) {
      obj.traverse(ch => {
        if (ch && ch.geometry) pts.push(...getWorldAttachPointsForMesh(ch));
      });
    }
    return pts;
  }

  a.updateWorldMatrix(true, false);
  b.updateWorldMatrix(true, false);

  const aPts = collectAttachPoints(a);
  const bPts = collectAttachPoints(b);

  if (!aPts.length || !bPts.length) {
    alert("í¬íŠ¸(attach point)ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\në¶€ì†ì˜ userData.threadCenters ë˜ëŠ” inline í¬ì¸íŠ¸ ê³„ì‚°ì„ í™•ì¸í•˜ì„¸ìš”.");
    return;
  }

  // âœ… ê°€ì¥ ê°€ê¹Œìš´ í¬íŠ¸ 1ìŒ ì°¾ê¸°
  let best = { d: Infinity, pA: null, pB: null };
  for (let i = 0; i < aPts.length; i++) {
    for (let j = 0; j < bPts.length; j++) {
      const d = aPts[i].distanceTo(bPts[j]);
      if (d < best.d) best = { d, pA: aPts[i], pB: bPts[j] };
    }
  }

  // ë„ˆë¬´ ê°€ê¹Œìš°ë©´(ì´ë¯¸ ë¶™ì–´ìˆìŒ) ìƒì„± ì•ˆ í•¨
  const minGap = 0.01; // ì›”ë“œë‹¨ìœ„(= 1mmë©´ 0.01, 10mmë©´ 0.1) / í•„ìš”ì‹œ ì¡°ì ˆ
  if (!isFinite(best.d) || best.d < minGap) {
    alert("ë‘ ë¶€ì†ì´ ì´ë¯¸ ê±°ì˜ ë¶™ì–´ìˆì–´ì„œ íŒŒì´í”„ë¥¼ ë§Œë“¤ ë¹ˆ ê³µê°„ì´ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  saveState();

  // âœ… íŒŒì´í”„ ê·œê²© ìë™ ì„ íƒ
  // 1) ì„ íƒëœ ë‘ ê°œì²´ ì¤‘ "mmCube(sizeMm)" ë˜ëŠ” mm íŒŒì´í”„("12mm"/"15mm")ê°€ ìˆìœ¼ë©´ ìš°ì„  ê·¸ ê·œê²© ì‚¬ìš©
  // 2) ë‘˜ ë‹¤ mm ê·œê²©ì¸ë° ì„œë¡œ ë‹¤ë¥´ë©´ â†’ í˜„ì¬ í† ê¸€(15A/20A)ë¡œ fallback
  function extractMmSize(obj) {
    if (!obj) return null;

    // mesh
    if (obj.geometry && obj.userData) {
      if (obj.userData.type === "mmCube" && isFinite(obj.userData.sizeMm)) return obj.userData.sizeMm;
      if (typeof obj.userData.size === "string" && obj.userData.size.toLowerCase().endsWith("mm")) {
        const mm = parseFloat(obj.userData.size);
        return isFinite(mm) ? mm : null;
      }
    }

    // group
    if (obj instanceof THREE.Group) {
      let found = null;
      obj.traverse(ch => {
        if (found != null) return;
        if (ch && ch.geometry && ch.userData) {
          if (ch.userData.type === "mmCube" && isFinite(ch.userData.sizeMm)) found = ch.userData.sizeMm;
          else if (typeof ch.userData.size === "string" && ch.userData.size.toLowerCase().endsWith("mm")) {
            const mm = parseFloat(ch.userData.size);
            if (isFinite(mm)) found = mm;
          }
        }
      });
      return found;
    }
    return null;
  }

  const mmA = extractMmSize(a);
  const mmB = extractMmSize(b);

  let size;
  if (mmA != null && mmB != null && Math.abs(mmA - mmB) < 1e-6) {
    size = `${mmA}mm`;
  } else if (mmA != null && mmB == null) {
    size = `${mmA}mm`;
  } else if (mmB != null && mmA == null) {
    size = `${mmB}mm`;
  } else {
    // 3) ê¸°ë³¸: í˜„ì¬ í† ê¸€ ê°’ ì‚¬ìš© (15A/20A)
    size = CURRENT_NOMINAL || "15A";
  }

  const pipe = createPipeBetweenWorldPoints(best.pA, best.pB, size);
  if (!pipe) return;

  scene.add(pipe);
  draggable.push(pipe);

  clearAllSelection();
  selectedSet.add(pipe);
  markSelected(pipe);
  selectedMesh = pipe;
  updateRotationGizmo();
}






function geometryFromData(data) {
  if (!data || data.type !== "BufferGeometry") return null;

  const geo = new THREE.BufferGeometry();

  if (data.position && data.position.length) {
    geo.setAttribute("position", new THREE.BufferAttribute(new Float32Array(data.position), data.positionItemSize || 3));
  }
  if (data.normal && data.normal.length) {
    geo.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(data.normal), data.normalItemSize || 3));
  } else {
    // normalì´ ì—†ìœ¼ë©´ ë‚˜ì¤‘ì— compute
  }

  if (data.index && data.index.length) {
    // indexëŠ” ë³´í†µ Uint16/Uint32 ì¸ë° JSONì€ Numberë¼ì„œ ì¼ë‹¨ Uint32ë¡œ
    geo.setIndex(new THREE.BufferAttribute(new Uint32Array(data.index), 1));
  }

  if (!geo.getAttribute("normal")) geo.computeVertexNormals();
  geo.computeBoundingBox();
  geo.computeBoundingSphere();
  return geo;
}

// ---- material ì§ë ¬í™”/ì—­ì§ë ¬í™” ----
function materialToData(mat) {
  if (!mat) return null;
  // MeshStandardMaterial ê¸°ì¤€ìœ¼ë¡œ í•„ìš”í•œ ê²ƒë§Œ
  return {
    type: "MeshStandardMaterial",
    color: (mat.color && mat.color.getHex) ? mat.color.getHex() : 0xffffff,
    roughness: (mat.roughness != null) ? mat.roughness : 0.5,
    metalness: (mat.metalness != null) ? mat.metalness : 0.0,
    transparent: !!mat.transparent,
    opacity: (mat.opacity != null) ? mat.opacity : 1
  };
}

function materialFromData(data) {
  if (!data) return new THREE.MeshStandardMaterial({ color: 0xffffff });
  if (data.type !== "MeshStandardMaterial") {
    return new THREE.MeshStandardMaterial({ color: data.color ?? 0xffffff });
  }
  return new THREE.MeshStandardMaterial({
    color: data.color ?? 0xffffff,
    roughness: data.roughness ?? 0.5,
    metalness: data.metalness ?? 0.0,
    transparent: !!data.transparent,
    opacity: (data.opacity != null) ? data.opacity : 1
  });
}

// ---- Object3D(ë©”ì‹œ/ê·¸ë£¹) ì§ë ¬í™”/ì—­ì§ë ¬í™” ----
function objectToData(obj) {
  // selection outline / ì¹˜ìˆ˜ ê°™ì€ ê±° ì €ì¥ ì œì™¸
  if (obj?.userData?.isSelectionOutline) return null;
  if (obj?.userData?.isDimension) return null;

  const isGroup = (obj instanceof THREE.Group) && !obj.isMesh;

  const base = {
    name: obj.name || "",
    isGroup,
    // transform
    position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
    quaternion: { x: obj.quaternion.x, y: obj.quaternion.y, z: obj.quaternion.z, w: obj.quaternion.w },
    scale: { x: obj.scale.x, y: obj.scale.y, z: obj.scale.z },
    // userDataëŠ” ê·¸ëŒ€ë¡œ ì €ì¥(í•¨ìˆ˜/ìˆœí™˜ì°¸ì¡° ì—†ìœ¼ë‹ˆ OK)
    userData: obj.userData ? JSON.parse(JSON.stringify(obj.userData)) : {}
  };

  if (obj.isMesh) {
    base.isMesh = true;
    base.geometry = geometryToData(obj.geometry);

    // materialì´ ë°°ì—´ì¼ ìˆ˜ë„ ìˆëŠ”ë°, ì§€ê¸ˆì€ ëŒ€ë¶€ë¶„ ë‹¨ì¼ matì´ë¼ ë‹¨ì¼ë§Œ ì²˜ë¦¬
    base.material = materialToData(obj.material);
  }

  // ê·¸ë£¹ì´ë©´ children ì €ì¥
  base.children = [];
  if (obj.children && obj.children.length) {
    obj.children.forEach(ch => {
      const c = objectToData(ch);
      if (c) base.children.push(c);
    });
  }

  return base;
}

function objectFromData(data) {
  if (!data) return null;

  let obj;
  if (data.isMesh) {
    const geo = geometryFromData(data.geometry);
    const mat = materialFromData(data.material);
    obj = new THREE.Mesh(geo, mat);
  } else {
    obj = new THREE.Group();
  }

  obj.name = data.name || "";

  // transform ë³µì›
  if (data.position) obj.position.set(data.position.x, data.position.y, data.position.z);
  if (data.quaternion) obj.quaternion.set(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w);
  if (data.scale) obj.scale.set(data.scale.x, data.scale.y, data.scale.z);

  // userData ë³µì›
  obj.userData = data.userData || {};

  // children ë³µì›
  if (data.children && data.children.length) {
    data.children.forEach(chData => {
      const ch = objectFromData(chData);
      if (ch) obj.add(ch);
    });
  }

  // í˜¹ì‹œ outline í”ì ì´ ì„ì—¬ìˆìœ¼ë©´ ì œê±°
  stripSelectionOutlineDeep(obj);

  return obj;
}

// ---- íŒŒì¼ ë‹¤ìš´ë¡œë“œ ìœ í‹¸ ----
function downloadJSON(filename, jsonObj) {
  const text = JSON.stringify(jsonObj, null, 2);
  const blob = new Blob([text], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ---- ì €ì¥ ----
function saveProjectJSON() {
  // ì €ì¥ ì „ì— í˜„ì¬ ìƒíƒœ ìŠ¤íƒì—ë„ ë‚¨ê¸°ê³  ì‹¶ìœ¼ë©´ saveState() ìœ ì§€
  // (ì›í•˜ë©´ ë¹¼ë„ ë¨)
  saveState();

  const items = draggable.map(obj => objectToData(obj)).filter(Boolean);

  const payload = {
    app: "pipe3d",
    version: 1,
    savedAt: new Date().toISOString(),
    items
  };

  downloadJSON("pipe3d_project.json", payload);
}

// ---- ë¶ˆëŸ¬ì˜¤ê¸° ----
function loadProjectFromJSON(payload) {
  if (!payload || !Array.isArray(payload.items)) {
    alert("í”„ë¡œì íŠ¸ JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return;
  }

  // ë¶ˆëŸ¬ì˜¤ê¸° ìì²´ë„ Undo ê°€ëŠ¥í•˜ê²Œ
  saveState();

  // ì”¬ ì •ë¦¬ (ê·¸ë¦¬ë“œ/ì¡°ëª…/ê¸°ì¦ˆëª¨ ìœ ì§€í•˜ë©´ì„œ draggableë§Œ ì œê±°)
  draggable.forEach(o => scene.remove(o));
  draggable.length = 0;
  clearAllSelection();

  // ë³µì›
  payload.items.forEach(itemData => {
    const obj = objectFromData(itemData);
    if (!obj) return;

    scene.add(obj);
    draggable.push(obj);
  });

  updateRotationGizmo();

  // ë¶ˆëŸ¬ì˜¨ ìƒíƒœë¥¼ Undo ìŠ¤íƒì— "í˜„ì¬ ìƒíƒœ"ë¡œ ë‹¤ì‹œ í•œ ë²ˆ ì €ì¥í•˜ë©´
  // Undoê°€ ìì—°ìŠ¤ëŸ½ê²Œ ì‘ë™í•¨
  saveState();
}

// ---- íŒŒì¼ input ì—°ê²° ----
(function bindProjectLoader(){
  const input = document.getElementById("projectFileInput");
  if (!input) return;

  input.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const payload = JSON.parse(reader.result);
        loadProjectFromJSON(payload);
      } catch (err) {
        console.error(err);
        alert("JSON íŒŒì‹± ì‹¤íŒ¨: íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ í˜•ì‹ì´ ë‹¤ë¦…ë‹ˆë‹¤.");
      }
    };
    reader.readAsText(file);

    // ê°™ì€ íŒŒì¼ì„ ë‹¤ì‹œ ì„ íƒí•´ë„ change ëœ¨ê²Œ ì´ˆê¸°í™”
    input.value = "";
  });
})();


function alignSelectionToAnchorCenter(opts = { axes: "xz" }) {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (targets.length < 2) {
    alert("ê¸°ì¤€ 1ê°œ + ì •ë ¬í•  ê°œì²´ 1ê°œ ì´ìƒ(ì´ 2ê°œ ì´ìƒ) ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  // âœ… ê¸°ì¤€(Anchor) = ë§ˆì§€ë§‰ ì„ íƒëœ ê²ƒ(selectedMesh)
  const anchor = selectedMesh || targets[targets.length - 1];
  if (!anchor) return;

  saveState();

  // ê¸°ì¤€ ì¤‘ì‹¬
  const aBox = new THREE.Box3().setFromObject(anchor);
  const aCenter = new THREE.Vector3();
  aBox.getCenter(aCenter);

  const axes = (opts.axes || "xz").toLowerCase(); // "x", "z", "xz", "xyz"

  targets.forEach(obj => {
    if (obj === anchor) return;

    const b = new THREE.Box3().setFromObject(obj);
    const c = new THREE.Vector3();
    b.getCenter(c);

    if (axes.includes("x")) obj.position.x += (aCenter.x - c.x);
    if (axes.includes("y")) obj.position.y += (aCenter.y - c.y);
    if (axes.includes("z")) obj.position.z += (aCenter.z - c.z);
  });

  updateRotationGizmo();
}





/* --------------------------------------------------
   ë¶€ì†ë³„ í¬ê¸°/ì¶• ì„¤ì •
-------------------------------------------------- */
const FITTING_META = {
  "socket.stl":  { axis:"z", fracIn1:0.2, fracIn2:0.2 },
  "reducer.stl": { axis:"z", fracIn1:0.2, fracIn2:0.2 },
  "nipple.stl":  { axis:"z", fracIn1:0.2, fracIn2:0.2 }
};

/* ========== ê¸°ë³¸ 3D ì„¸íŒ… ========== */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);


// âœ… ì™¼ìª½ íŒ¨ë„ì—ì„œ íœ ì€ íŒ¨ë„ ìŠ¤í¬ë¡¤ë¡œë§Œ ì‚¬ìš©
const uiPanel = document.getElementById("ui");
if (uiPanel) {
  uiPanel.addEventListener("wheel", (e) => {
    e.stopPropagation(); // ì „ì—­ wheel(ì¤Œ)ë¡œ ì•ˆ ì˜¬ë¼ê°€ê²Œ
  }, { passive: true });
}

/* ========== ğŸ“± ìŠ¤ë§ˆíŠ¸í° í„°ì¹˜ ì§€ì› (ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¡œ ê°•ì œ ì—°ê²°) ========== */
canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1) {
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", {
      clientX: touch.clientX,
      clientY: touch.clientY,
      button: 0 // ì™¼ìª½ í´ë¦­ìœ¼ë¡œ ì¸ì‹
    });
    canvas.dispatchEvent(mouseEvent);
  }
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  if (e.touches.length === 1) {
    e.preventDefault(); // í™”ë©´ ìŠ¤í¬ë¡¤ ë°©ì§€
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", {
      clientX: touch.clientX,
      clientY: touch.clientY
    });
    window.dispatchEvent(mouseEvent);
  }
}, { passive: false });

canvas.addEventListener("touchend", () => {
  const mouseEvent = new MouseEvent("mouseup", {});
  window.dispatchEvent(mouseEvent);
}, { passive: false });


const scene = new THREE.Scene();
scene.background = new THREE.Color(0x777777);

const camera = new THREE.PerspectiveCamera(
  50,
  window.innerWidth / window.innerHeight,
  0.1,
  500
);


// ğŸ¯ ì™¼ìª½ ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ë¶€ì† ì„ íƒ




/* â˜… ì²« í™”ë©´ìš© ì¹´ë©”ë¼ ì„¸íŒ… + ë·° ê³µí†µ í•¨ìˆ˜ë“¤ */

// í™”ë©´ ê¸°ì¤€ì  = ê·¸ë¦¬ë“œ ì¤‘ì•™
function initFirstView() {
  camTarget.set(0, 0, 0);

  // ì²˜ìŒ ì¼°ì„ ë•Œ ê¸°ë³¸ ê±°ë¦¬
  radius = 20;              // ìˆ«ì í‚¤ìš°ë©´ ë” ë©€ë¦¬, ì¤„ì´ë©´ ë” ê°€ê¹Œì´

  // ì •ë©´ì—ì„œ ì‚´ì§ ìœ„
  theta = Math.PI * 0.5;    // +Z ë°©í–¥ (ì •ë©´)
  phi   = Math.PI * 0.35;   // ìœ„ì—ì„œ ì•½ê°„ ë‚´ë ¤ë‹¤ë³´ëŠ” ê°ë„

  camera.up.set(0, 1, 0);   // ì¹´ë©”ë¼ ë¹„í‹€ë¦¼ ë°©ì§€
}

/* ë·° ì „í™˜ ê³µí†µ ì²˜ë¦¬ */
function setViewCommon(thetaValue, phiValue) {
  if (!radius || radius < 3) radius = 10; // ì¤Œ ë„ˆë¬´ ì‘ìœ¼ë©´ ê¸°ë³¸ê°’

  theta = thetaValue;
  phi   = phiValue;

  camera.up.set(0, 1, 0);
  updateCamera();
}

// =======================
// ë·° í”„ë¦¬ì…‹ ì •ì˜
// =======================
const VIEW_PRESETS = {
  front: { theta: Math.PI * 0.5, phi: Math.PI * 0.35 }, // +Z
  back:  { theta: Math.PI * 1.5, phi: Math.PI * 0.35 }, // -Z
  left:  { theta: Math.PI,       phi: Math.PI * 0.35 }, // -X
  right: { theta: 0,             phi: Math.PI * 0.35 }, // +X
  top:   { theta: Math.PI * 0.5, phi: 0.0001 }           // +Y
};

// =======================
// ê³µìš© ë·° ì „í™˜ í•¨ìˆ˜
// =======================
function setView(name) {
  const p = VIEW_PRESETS[name];
  if (!p) return;
  setViewCommon(p.theta, p.phi);
}




/* === ì¹´ë©”ë¼ ê¶¤ë„ ìƒíƒœ === */
let camTarget = new THREE.Vector3(0, 0, 0);
let radius = 10;
let theta  = Math.PI / 4;
let phi    = Math.PI / 4;



/* ===== íšŒì „ Gizmo ê´€ë ¨ ìƒíƒœ ===== */
let rotationGizmo = null;
let ringX = null, ringY = null, ringZ = null;
let hitRingX = null, hitRingY = null, hitRingZ = null;

const rotateCenterScreen = new THREE.Vector2();
let rotateStartAngle = 0;
let rotateAxis = "y";
const rotateWorldAxis   = new THREE.Vector3(); // ì›”ë“œ ê¸°ì¤€ íšŒì „ì¶•
const initialRotations  = new Map();           // ê° ì˜¤ë¸Œì íŠ¸ ì´ˆê¸° ì¿¼í„°ë‹ˆì–¸
let gizmoEnabled = false;
let hoveredAxis = null;

const RING_STYLE = {
  x: { color: 0xff4444, opacity: 0.7 },
  y: { color: 0x00ff00, opacity: 0.7 },
  z: { color: 0x4488ff, opacity: 0.7 }
};
const DIM_COLOR   = 0x777777;
const DIM_OPACITY = 0.25;
const HOVER_SCALE = 1.18;

/* ========== ì„ íƒ/ë“œë˜ê·¸/Undo ìƒíƒœ ========== */


const draggable = [];
const raycaster = new THREE.Raycaster();
const mouse     = new THREE.Vector2();
const movePlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
const planeHit  = new THREE.Vector3();
let dragOffset  = new THREE.Vector3();

let selectedMesh = null;
const selectedSet = new Set();

let baseMoveStep = 0.02;
let snapStep     = 0.05;

let dragging = false;
let dragMode = null; // 'orbit', 'pan', 'elevate', 'move', 'rect', 'rotate'
let lastX = 0, lastY = 0;

let snapEnabled   = false;
let magnetEnabled = false;

/* íŒŒì´í”„ ê¸¸ì´ ê´€ë ¨ ì…ë ¥(HTMLì—ëŠ” ì—†ìŒ, í”„ë¡¬í”„íŠ¸ ê¸°ë³¸ê°’ìš©) */
const pipe20LenInput       = document.getElementById("pipe20Len") || null;
const pipe15LenInput       = document.getElementById("pipe15Len") || null;
const selectedPipeLenInput = document.getElementById("selectedPipeLen") || null;


/* ë“œë˜ê·¸ ë°•ìŠ¤ */
const selectionRectEl = document.getElementById("selectionRect");
let rectStartX = 0, rectStartY = 0, rectEndX = 0, rectEndY = 0;


let rectAdditive = false;          // Ctrl ëˆ„ë¥´ë©´ ì¶”ê°€ ì„ íƒ
let rectBaseSelected = new Set();  // ë“œë˜ê·¸ ì‹œì‘ ì‹œì  ì„ íƒ ë°±ì—…
let rectHoverSet = new Set();      // ë“œë˜ê·¸ ì¤‘ ê³„ì‚°ëœ ì„ì‹œ ì„ íƒ




/* íšŒì „ ê°ë„ UI */
const angleUI = document.getElementById("angleLabel");

/* íšŒì „ ê°ë„ HUD (ë‹¨ì¶•í‚¤ìš©) */
let angleHudTimer = null;
function showRotateHUD(axis, angleRad) {
  if (!angleUI) return;

  // ë¼ë””ì•ˆ â†’ ë„(degree)
  let deg = THREE.MathUtils.radToDeg(angleRad);

  // ë³´ê¸° ì¢‹ê²Œ -180 ~ 180 ë¡œ ì •ê·œí™”
  deg = ((deg + 180) % 360 + 360) % 360 - 180;

  // ì†Œìˆ˜ í•œ ìë¦¬ê¹Œì§€
  deg = Math.round(deg * 10) / 10;

  angleUI.style.display = "block";
  angleUI.textContent = `${axis.toUpperCase()} ${deg}Â°`;
  angleUI.style.left = "50%";
  angleUI.style.top  = "15%";

  if (angleHudTimer) clearTimeout(angleHudTimer);
  angleHudTimer = setTimeout(() => {
    angleUI.style.display = "none";
  }, 800);
}


/* ===== ê·¸ë¦¬ë“œ, ì¡°ëª… ===== */
const grid = new THREE.GridHelper(100, 100, 0x999999, 0x999999);
grid.position.y = 0;
scene.add(grid);

/* ===== ì¤‘ì•™ ì‹­ì (X=ë¹¨ê°•, Z=íŒŒë‘) ===== */

const axisLength = 25;        // â˜… ê¸¸ì´ (ì›í•˜ë©´ ìˆ«ìë§Œ ë³€ê²½)
const axisY      = 0.000;     // ê·¸ë¦¬ë“œì™€ ê±°ì˜ ë™ì¼ ë†’ì´
const axisThickness = 0.02;   // ì„  êµµê¸° (0.01~0.05 ì¶”ì²œ)

// Xì¶• ë¹¨ê°• íŒŒì´í”„
{
  const path = new THREE.LineCurve3(
    new THREE.Vector3(-axisLength, axisY, 0),
    new THREE.Vector3(axisLength, axisY, 0)
  );

  const geo = new THREE.TubeGeometry(path, 1, axisThickness, 8, false);
  const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 10;  // ê·¸ë¦¬ë“œ ìœ„ì— ë‚˜ì˜¤ê²Œ
  scene.add(mesh);
}

// Zì¶• íŒŒë‘ íŒŒì´í”„
{
  const path = new THREE.LineCurve3(
    new THREE.Vector3(0, axisY, -axisLength),
    new THREE.Vector3(0, axisY, axisLength)
  );

  const geo = new THREE.TubeGeometry(path, 1, axisThickness, 8, false);
  const mat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 10;  // ê·¸ë¦¬ë“œ ìœ„
  scene.add(mesh);
}






// ì¡°ëª…
const ambient = new THREE.AmbientLight(0xffffff,0.9);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff,0.5);
dirLight.position.set(5,10,5);
scene.add(dirLight);




const bodyMat = new THREE.MeshStandardMaterial({
  color:0x5c5c5c,
  roughness:0.6,
  metalness:0.2
});


const FITTING_SCALE = 0.06;
const MM_PER_UNIT = 100;

const KS_OD = {
  "15A": 21.7,
  "20A": 27.2,
  "12mm": 12,
  "15mm": 15
};




const ELBOW45_PORT_OFFSETS = {
  port1: { x: 0.5, y: 0.8, z: 0 },
  port2: { x: -0.5, y: -0.7, z: -1 }
};

// ====== Nominal(í˜¸ì¹­) ìŠ¤ì¼€ì¼ ë¹„ìœ¨ ======
const NOMINAL_SCALE = {
  "15A": 1.0,
  "20A": KS_OD["20A"] / KS_OD["15A"] // â‰ˆ 1.253456221...
};

// í˜„ì¬ ì‘ì—… í˜¸ì¹­ (ì›í•˜ë©´ ê¸°ë³¸ê°’ì„ 20Aë¡œ)
let CURRENT_NOMINAL = "15A";   // â† "20A"ë¡œ ë°”ê¾¸ë©´ ê¸°ë³¸ì´ 20A

// ë¶€ì†(í”¼íŒ…)ì—ë§Œ ì ìš©í•  ìŠ¤ì¼€ì¼ ìœ í‹¸
function applyNominalScaleToFitting(mesh, nominal) {
  const k = NOMINAL_SCALE[nominal] ?? 1.0;
  mesh.scale.multiplyScalar(k);
}

// (ì„ íƒ) í˜¸ì¹­ ë°”ê¾¸ëŠ” í•¨ìˆ˜


function isPlateObject(obj) {
  return !!(obj?.userData?.isRectPlate || (obj?.userData?.isPlate && obj?.userData?.plateShape === "circle"));
}

function setObjectOpacityDeep(obj, opacity01) {
  obj.traverse(o => {
    if (!o.isMesh || !o.material) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];
    mats.forEach(m => {
      if (!m) return;
      m.transparent = true;
      m.opacity = opacity01;
      // ì™„ì „ íˆ¬ëª…ì— ê°€ê¹Œìš°ë©´ í´ë¦­/ì„ íƒì´ í—·ê°ˆë¦´ ìˆ˜ ìˆì–´ì„œ(ì›í•˜ë©´)
      // m.depthWrite = (opacity01 >= 0.99);
      m.needsUpdate = true;
    });
  });
}







// ì¹˜ìˆ˜ í‘œì‹œ ë³´ì • ë£° (êµ¬ë²„ì „ í˜¸í™˜) - ì´ íŒŒì¼ì—ì„œëŠ” 'ì‹¤ì œ ì¹˜ìˆ˜ ê³ ì •'ì„ ì•ˆ í•˜ë¯€ë¡œ no-op
function applySTLDimDisplayRule(mesh){
  // ê³¼ê±° ë²„ì „ì—ì„œ mesh.userData.stlName ê¸°ì¤€ìœ¼ë¡œ 'í‘œì‹œ ì¹˜ìˆ˜(mm)'ë§Œ ë³´ì •í•˜ë˜ í›…
  // í˜„ì¬ëŠ” ì¹˜ìˆ˜ì„ ì´ íšŒì „/ë³€í˜•ì„ ê·¸ëŒ€ë¡œ ë”°ë¼ê°€ê²Œ ë‘ëŠ” ì •ì±…ì´ë¼ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  return mesh;
}

/* ==================================================
   ì¹˜ìˆ˜(Dimension) ì‹œìŠ¤í…œ (ì„ íƒëœ ê°ì²´ë§Œ í‘œì‹œ)
================================================== */

// âœ… ì¹˜ìˆ˜ ì˜¤ë¸Œì íŠ¸(ì”¬ì— ë– ìˆëŠ” ì¹˜ìˆ˜ ê·¸ë£¹ë“¤) ê´€ë¦¬ (ì¤‘ë³µ ì„ ì–¸ ê¸ˆì§€!)


let dimensionEnabled = false;
const dimensionObjects = [];


// âœ… ì¹˜ìˆ˜ ìë™ ê°±ì‹ (ì„ íƒ ì˜¤ë¸Œì íŠ¸ê°€ ë³€í•˜ë©´ ì¹˜ìˆ˜ ë‹¤ì‹œ ê·¸ë¦¬ê¸°)
let dimFollowObj = null;
const dimFollowMatrix = new THREE.Matrix4();

function updateDimensionsAuto() {
  if (!dimensionEnabled) return;

  const obj = selectedMesh;
  if (!obj) {
    hideAllDimensions();
    dimFollowObj = null;
    return;
  }

  obj.updateWorldMatrix(true, false);

  // ê°™ì€ ì˜¤ë¸Œì íŠ¸ + ë³€í˜•(ì´ë™/íšŒì „/ìŠ¤ì¼€ì¼) ë³€í™” ì—†ìœ¼ë©´ ìŠ¤í‚µ
  if (dimFollowObj === obj && dimFollowMatrix.equals(obj.matrixWorld)) return;

  dimFollowObj = obj;
  dimFollowMatrix.copy(obj.matrixWorld);

  // âœ… ë³€í–ˆìœ¼ë©´ ì¹˜ìˆ˜ ë‹¤ì‹œ ìƒì„±
 showDimensionsSmartForSelection();

}




// mm â†’ ì›”ë“œ ë‹¨ìœ„ ë³€í™˜
function mmToWorld(mm) {
  return mm / MM_PER_UNIT;
}

// mm í‘œì‹œ í¬ë§·
function formatMm(mm) {
  // ì†Œìˆ˜ì  1ìë¦¬ ê³ ì •
  return (Math.round(mm * 10) / 10).toFixed(1);
}


// Canvas ê¸°ë°˜ í…ìŠ¤íŠ¸ ìŠ¤í”„ë¼ì´íŠ¸
function createTextSprite(text) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  canvas.width = 512;
  canvas.height = 256;

  const tex = new THREE.CanvasTexture(canvas);
tex.generateMipmaps = false;

// ğŸ”´ ì´ 3ì¤„ì´ í•µì‹¬
tex.minFilter = THREE.LinearFilter;
tex.magFilter = THREE.LinearFilter;
tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;

tex.premultiplyAlpha = false;
tex.needsUpdate = true;


 const mat = new THREE.SpriteMaterial({
  map: tex,
  transparent: true,
  alphaTest: 0.01,   // ğŸ”¥ ë°•ìŠ¤ ì œê±°ì— ë§¤ìš° ì¤‘ìš”
  depthTest: false,
  depthWrite: false
});


  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(0.25, 0.05, 1);
  sprite.renderOrder = 999;

  // âœ… ì¬ì‚¬ìš©ìš© ì €ì¥
  sprite.userData._canvas = canvas;
  sprite.userData._ctx = ctx;
  sprite.userData._tex = tex;

  // ìµœì´ˆ 1íšŒ ê·¸ë¦¬ê¸°
  updateTextSprite(sprite, text);

  return sprite;
}

function updateTextSprite(sprite, text) {
  const ctx = sprite.userData._ctx;
  const canvas = sprite.userData._canvas;
  const tex = sprite.userData._tex;

  // ===== ìŠ¤íƒ€ì¼ =====
  const fontSize = 96;
  const font = `${fontSize}px Arial`;
  ctx.font = font;

  // ğŸ”¥ í…ìŠ¤íŠ¸ ì‹¤ì œ í­ ì¸¡ì •
  const metrics = ctx.measureText(text);
  const padding = 40;

  const textWidth = Math.ceil(metrics.width + padding * 2);
  const textHeight = Math.ceil(fontSize + padding * 2);

  // ğŸ”¥ ìº”ë²„ìŠ¤ í¬ê¸° ë™ì  ì¡°ì •
  if (canvas.width !== textWidth || canvas.height !== textHeight) {
    canvas.width = textWidth;
    canvas.height = textHeight;
  }

  // ë‹¤ì‹œ ìŠ¤íƒ€ì¼ ì„¸íŒ… (canvas resize ì‹œ ì´ˆê¸°í™”ë¨)
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // ì™¸ê³½ì„ 
  ctx.strokeStyle = "#000000";
  ctx.lineWidth = 10;
  ctx.strokeText(text, canvas.width / 2, canvas.height / 2);

  // ë³¸ë¬¸
  ctx.fillStyle = "#ffffff";
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  tex.needsUpdate = true;

    // ğŸ”§ ìŠ¤í”„ë¼ì´íŠ¸ í¬ê¸° ë³´ì • (ë¹„ìœ¨ ìœ ì§€)
  const aspect = canvas.width / canvas.height;

  // âœ… ì—¬ê¸° ìˆ«ìë§Œ ë°”ê¾¸ë©´ ì „ì²´ ì¹˜ìˆ˜ í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì ˆë¨
  const baseH = 0.48;            // â† ì„¸ë¡œ(ì›”ë“œ ë‹¨ìœ„) : 0.12~0.30 ì¶”ì²œ
  sprite.scale.set(baseH * aspect, baseH, 1);

}





// ëí‘œì‹œ(X ëª¨ì–‘)
function makeEndMark(pos, dimDir, size) {
  const up = new THREE.Vector3(0, 1, 0);
  let perp = new THREE.Vector3().crossVectors(dimDir, up);
  if (perp.lengthSq() < 1e-6) perp = new THREE.Vector3().crossVectors(dimDir, new THREE.Vector3(1, 0, 0));
  perp.normalize();

  const a1 = pos.clone().addScaledVector(dimDir,  size).addScaledVector(perp,  size);
  const a2 = pos.clone().addScaledVector(dimDir, -size).addScaledVector(perp, -size);
  const b1 = pos.clone().addScaledVector(dimDir,  size).addScaledVector(perp, -size);
  const b2 = pos.clone().addScaledVector(dimDir, -size).addScaledVector(perp,  size);

  const geo = new THREE.BufferGeometry().setFromPoints([a1, a2, b1, b2]);
  const mat = new THREE.LineBasicMaterial({ color: 0x111111, depthTest: false });
  const seg = new THREE.LineSegments(geo, mat);
  seg.renderOrder = 998;
  return seg;
}
// âœ… ëë‹¨ ê°€ë¡œ ë§‰ëŒ€(í‹±) í‘œì‹œ
function makeEndTick(pos, dimDir, size) {
  const up = new THREE.Vector3(0, 1, 0);
  let perp = new THREE.Vector3().crossVectors(dimDir, up);
  if (perp.lengthSq() < 1e-6) perp = new THREE.Vector3().crossVectors(dimDir, new THREE.Vector3(1, 0, 0));
  perp.normalize();

  const a = pos.clone().addScaledVector(perp,  size);
  const b = pos.clone().addScaledVector(perp, -size);

  const geo = new THREE.BufferGeometry().setFromPoints([a, b]);
  const mat = new THREE.LineBasicMaterial({ color: 0x111111, depthTest: false });
  const line = new THREE.Line(geo, mat);
  line.renderOrder = 998;
  return line;
}

// â€œì—°ì¥ì„  + ì¹˜ìˆ˜ì„  + ëí‘œì‹œ + í…ìŠ¤íŠ¸â€
function createDimensionWithExtensions(objP1, objP2, labelText, offsetDir, offsetDist) {
  const p1 = objP1.clone();
  const p2 = objP2.clone();

  const dimDir = new THREE.Vector3().subVectors(p2, p1);
  const len = dimDir.length();
  if (len < 1e-6) return null;
  dimDir.normalize();

  const off = offsetDir.clone().normalize().multiplyScalar(offsetDist);

  const d1 = p1.clone().add(off);
  const d2 = p2.clone().add(off);

  const dimGeo = new THREE.BufferGeometry().setFromPoints([d1, d2]);
  const dimMat = new THREE.LineBasicMaterial({ color: 0x111111, depthTest: false });
  const dimLine = new THREE.Line(dimGeo, dimMat);
  dimLine.renderOrder = 998;

  const extGeo = new THREE.BufferGeometry().setFromPoints([p1, d1, p2, d2]);
  const extMat = new THREE.LineBasicMaterial({ color: 0x111111, depthTest: false });
  const extLines = new THREE.LineSegments(extGeo, extMat);
  extLines.renderOrder = 998;

const markSize = Math.max(0.06, Math.min(0.22, offsetDist * 0.45));

// âœ… ê²€ì€ ê°€ë¡œì„ (í‹±)
const t1 = makeEndTick(d1, dimDir, markSize);
const t2 = makeEndTick(d2, dimDir, markSize);

const mid = new THREE.Vector3().addVectors(d1, d2).multiplyScalar(0.5);
const label = createTextSprite(labelText);
label.position.copy(mid).addScaledVector(offsetDir, 0.12);

const group = new THREE.Group();

// âœ… ë°˜ë“œì‹œ ì—¬ê¸°: ì—°ì¥ì„  + ì¹˜ìˆ˜ì„  + ëí‹± + í…ìŠ¤íŠ¸
group.add(extLines, dimLine, t1, t2, label);

// âŒ Xí‘œì‹œ ì“°ê³  ì‹¶ì„ ë•Œë§Œ ì‚¬ìš©
// const m1 = makeEndMark(d1, dimDir, markSize);
// const m2 = makeEndMark(d2, dimDir, markSize);
// group.add(m1, m2);

group.userData.isDimension = true;
return group;

}

function hideAllDimensions() {
  while (dimensionObjects.length) {
    const o = dimensionObjects.pop();
    scene.remove(o);
  }
}


// âœ… selectionOutline(ì ì„  ìœ¤ê³½ì„ )ì„ ë¬´ì‹œí•˜ê³  ì›”ë“œ ë°”ìš´ë”©ë°•ìŠ¤ ê³„ì‚°
function getWorldBoxIgnoreOutline(obj) {
  const box = new THREE.Box3();
  let has = false;

  if (!obj) return null;

  // ì›”ë“œ í–‰ë ¬ ìµœì‹ í™”
  obj.updateWorldMatrix(true, true);

  obj.traverse(ch => {
    // âœ… ì ì„  ìœ¤ê³½ì„ ì€ ë¬´ì‹œ (ì¹˜ìˆ˜ ì˜¤ì°¨ì˜ ì›ì¸)
    if (ch?.userData?.isSelectionOutline) return;

    if (ch.isMesh && ch.geometry) {
      ch.geometry.computeBoundingBox();
      const bb = ch.geometry.boundingBox;
      if (!bb) return;

      // ë¡œì»¬ bbox â†’ ì›”ë“œ bboxë¡œ ë³€í™˜
      const b = bb.clone();
      b.applyMatrix4(ch.matrixWorld);

      if (!has) {
        box.copy(b);
        has = true;
      } else {
        box.union(b);
      }
    }
  });

  return has ? box : null;
}




function showOverallDimensionsForSelection() {
  hideAllDimensions();

  const targets =
    selectedSet.size > 0 ? [...selectedSet] :
    (selectedMesh ? [selectedMesh] : []);

  if (targets.length === 0) return;

  // âœ… ì—¬ê¸° í•µì‹¬: min/max ì´ˆê¸°í™”
  let minX =  Infinity, minY =  Infinity, minZ =  Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

  targets.forEach(obj => {
  if (!obj) return;

  // âœ… ìœ¤ê³½ì„ (ì„ íƒ ì ì„ ) ì œì™¸í•œ bboxë¡œ ê³„ì‚°
  const b = getWorldBoxIgnoreOutline(obj);
  if (!b || !isFinite(b.min.x) || !isFinite(b.max.x)) return;

  minX = Math.min(minX, b.min.x);
  maxX = Math.max(maxX, b.max.x);
  minY = Math.min(minY, b.min.y);
  maxY = Math.max(maxY, b.max.y);
  minZ = Math.min(minZ, b.min.z);
  maxZ = Math.max(maxZ, b.max.z);
});

  if (!isFinite(minX) || !isFinite(maxX)) return;

  const wMm = (maxX - minX) * MM_PER_UNIT; // X
  const hMm = (maxY - minY) * MM_PER_UNIT; // Y
  const dMm = (maxZ - minZ) * MM_PER_UNIT; // Z

  const cy = (minY + maxY) / 2;
  const cz = (minZ + maxZ) / 2;

  const offset = 0.6;

  // X ë°©í–¥
  {
    const p1 = new THREE.Vector3(minX, cy, maxZ);
    const p2 = new THREE.Vector3(maxX, cy, maxZ);
    const off = new THREE.Vector3(0, 0, 1);

    const dim = createDimensionWithExtensions(p1, p2, formatMm(wMm), off, offset);
    if (dim) { scene.add(dim); dimensionObjects.push(dim); }
  }

  // Z ë°©í–¥
  {
    const p1 = new THREE.Vector3(maxX, cy, minZ);
    const p2 = new THREE.Vector3(maxX, cy, maxZ);
    const off = new THREE.Vector3(1, 0, 0);

    const dim = createDimensionWithExtensions(p1, p2, formatMm(dMm), off, offset);
    if (dim) { scene.add(dim); dimensionObjects.push(dim); }
  }

  // Y ë°©í–¥
 // Y ë°©í–¥ (ë†’ì´)  âœ… ì™¼ìª½ìœ¼ë¡œ ì´ë™í•´ì„œ Zì¹˜ìˆ˜(íŒŒë€ì¶•)ì™€ ê²¹ì¹¨ ë°©ì§€
{
  // âœ… ì˜¤ë¥¸ìª½(maxX) ë§ê³  ì™¼ìª½(minX)ì—ì„œ ë†’ì´ ì¹˜ìˆ˜ ê·¸ë¦¬ê¸°
  const p1 = new THREE.Vector3(minX, minY, cz);
  const p2 = new THREE.Vector3(minX, maxY, cz);

  // âœ… ì™¼ìª½ìœ¼ë¡œ ì˜¤í”„ì…‹(-X) ë°©í–¥ìœ¼ë¡œ ë¹¼ê¸°
  const off = new THREE.Vector3(-1, 0, 0);

  const dim = createDimensionWithExtensions(p1, p2, formatMm(hMm), off, offset);
  if (dim) { scene.add(dim); dimensionObjects.push(dim); }
}

}

function showDimensionsSmartForSelection() {
  const targets =
    selectedSet.size > 0 ? [...selectedSet] :
    (selectedMesh ? [selectedMesh] : []);

  if (targets.length === 0) {
    hideAllDimensions();
    return;
  }

  // âœ… ë‹¨ì¼ ì„ íƒì´ë©´: íŒŒì´í”„/íŒì€ "ì „ìš© ì¹˜ìˆ˜" (ì§€ë¦„ ì•ˆ ë‚˜ì˜¤ê²Œ)
  if (targets.length === 1) {
    const obj = targets[0];
    if (obj?.userData?.isPipe || obj?.userData?.isRectPlate || obj?.userData?.isPlate) {
      showDimensionsForSelection(obj);  // â† íŒŒì´í”„ëŠ” lengthMmë§Œ í‘œì‹œë¨
      return;
    }
  }

  // âœ… ê·¸ ì™¸(ë‹¤ì¤‘ ì„ íƒ/ë¶€ì†ë“¤) = ì „ì²´ ì™¸ê³½ ì¹˜ìˆ˜
  showOverallDimensionsForSelection();
}




// âœ… ì—¬ê¸°ë¶€í„°ê°€ í•µì‹¬: íŒŒì´í”„ ëŒ€ê°ì„  ë¬¸ì œ í•´ê²°(ì¹´ë©”ë¼ ê¸°ì¤€ ì œê±°)
function showDimensionsForSelection(obj) {
  hideAllDimensions();
  if (!obj) return;

  // =========================
  // âœ… PIPE ì¹˜ìˆ˜
  // =========================
  if (obj.userData?.isPipe) {
  const lenMm = obj.userData.lengthMm;
  if (!lenMm) return;

  // âœ… íšŒì „/ì´ë™ ë°˜ì˜ëœ "ì›”ë“œ ì–‘ ëì "
  const ends = getPipeEndPointsWorld(obj);
  if (!ends || ends.length < 2) return;

  const p1 = ends[0];
  const p2 = ends[1];

  // ì¹˜ìˆ˜ì„  ë°©í–¥
  const dimDir = new THREE.Vector3().subVectors(p2, p1).normalize();

  // âœ… ì¹´ë©”ë¼ ê¸°ì¤€ìœ¼ë¡œ ì˜†ìœ¼ë¡œ ë¹¼ê¸°(í•­ìƒ ë³´ê¸° ì¢‹ê²Œ)
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);

  // dimDirê³¼ ì¹´ë©”ë¼ ë°©í–¥ ë‘˜ ë‹¤ì— ìˆ˜ì§ì¸ ë°©í–¥(ì¹˜ìˆ˜ì„  ì˜¤í”„ì…‹ ë°©í–¥)
  let offsetDir = new THREE.Vector3().crossVectors(dimDir, camDir);
  if (offsetDir.lengthSq() < 1e-8) {
    // ê±°ì˜ í‰í–‰ì´ë©´ camera.upë¡œ ëŒ€ì²´
    offsetDir = new THREE.Vector3().crossVectors(dimDir, camera.up);
  }
  offsetDir.normalize();

  const offsetDist = 0.35; // âœ… ê±°ë¦¬(ì›í•˜ë©´ 0.25~0.5 ì¡°ì ˆ)

  const dim = createDimensionWithExtensions(
    p1, p2,
    formatMm(lenMm),
    offsetDir,
    offsetDist
  );

  if (dim) {
    scene.add(dim);
    dimensionObjects.push(dim);
  }
  return;
}


  // =========================
  // âœ… ì‚¬ê°íŒ ì¹˜ìˆ˜
  // =========================
  if (obj.userData?.isRectPlate) {
  const wMm = obj.userData.widthMm  || 0;
  const hMm = obj.userData.heightMm || 0;
  if (!wMm || !hMm) return;

  obj.updateWorldMatrix(true, false);

  // âœ… ì‚¬ê°íŒì€ BoxGeometry(w, t, h) ë¡œ ë§Œë“¤ì—ˆìŒ: (x=ê°€ë¡œ, z=ì„¸ë¡œ)
  const wU = wMm / MM_PER_UNIT;
  const hU = hMm / MM_PER_UNIT;

  // ë¡œì»¬ ê¸°ì¤€(ìœ—ë©´ y=0 ê¸°ì¤€ìœ¼ë¡œë„ ë˜ëŠ”ë°, ì¹˜ìˆ˜ì„ ì€ â€œì˜†ìœ¼ë¡œâ€ ë¹¼ë‹ˆ yëŠ” 0ìœ¼ë¡œ ì¶©ë¶„)
  const x1L = new THREE.Vector3(-wU/2, 0,  hU/2);
  const x2L = new THREE.Vector3( wU/2, 0,  hU/2);

  const z1L = new THREE.Vector3( wU/2, 0, -hU/2);
  const z2L = new THREE.Vector3( wU/2, 0,  hU/2);

  // âœ… ì›”ë“œë¡œ ë³€í™˜ (íšŒì „/ì´ë™ ë°˜ì˜)
  const xP1 = obj.localToWorld(x1L.clone());
  const xP2 = obj.localToWorld(x2L.clone());
  const zP1 = obj.localToWorld(z1L.clone());
  const zP2 = obj.localToWorld(z2L.clone());

  // âœ… íŒŒì´í”„ì²˜ëŸ¼ â€œì¹´ë©”ë¼ ê¸°ì¤€â€ìœ¼ë¡œ ì˜†ìœ¼ë¡œ ë¹¼ê¸°
  const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);

  const dxDir = new THREE.Vector3().subVectors(xP2, xP1).normalize();
  let offX = new THREE.Vector3().crossVectors(dxDir, camDir);
  if (offX.lengthSq() < 1e-8) offX = new THREE.Vector3().crossVectors(dxDir, camera.up);
  offX.normalize();

  const dzDir = new THREE.Vector3().subVectors(zP2, zP1).normalize();
  let offZ = new THREE.Vector3().crossVectors(dzDir, camDir);
  if (offZ.lengthSq() < 1e-8) offZ = new THREE.Vector3().crossVectors(dzDir, camera.up);
  offZ.normalize();

  const offsetDist = 0.35;

  const dimW = createDimensionWithExtensions(xP1, xP2, formatMm(wMm), offX, offsetDist);
  const dimH = createDimensionWithExtensions(zP1, zP2, formatMm(hMm), offZ, offsetDist);

  if (dimW) { scene.add(dimW); dimensionObjects.push(dimW); }
  if (dimH) { scene.add(dimH); dimensionObjects.push(dimH); }
  return;
}

  // =========================
  // âœ… ì›í˜•íŒ ì¹˜ìˆ˜
  // =========================
 if (obj.userData?.isPlate && obj.userData?.plateShape === "circle") {
  const dMm = obj.userData.diameterMm || 0;
  if (!dMm) return;

  obj.updateWorldMatrix(true, false);

  const rU = (dMm / 2) / MM_PER_UNIT;

  // âœ… ë¡œì»¬ì—ì„œ ì§€ë¦„ì„ (ì˜ˆ: +X â†” -X)
  const p1L = new THREE.Vector3(-rU, 0, 0);
  const p2L = new THREE.Vector3( rU, 0, 0);

  const p1 = obj.localToWorld(p1L.clone());
  const p2 = obj.localToWorld(p2L.clone());

  // âœ… íŒŒì´í”„ì²˜ëŸ¼ â€œì¹´ë©”ë¼ ê¸°ì¤€â€ìœ¼ë¡œ ì˜†ìœ¼ë¡œ ë¹¼ê¸°
  const dimDir = new THREE.Vector3().subVectors(p2, p1).normalize();
  const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);

  let offsetDir = new THREE.Vector3().crossVectors(dimDir, camDir);
  if (offsetDir.lengthSq() < 1e-8) offsetDir = new THREE.Vector3().crossVectors(dimDir, camera.up);
  offsetDir.normalize();

  const offsetDist = 0.35;

  const dim = createDimensionWithExtensions(
    p1, p2,
    `Ã˜ ${Math.round(dMm * 10000) / 10000} mm`,
    offsetDir,
    offsetDist
  );

  if (dim) { scene.add(dim); dimensionObjects.push(dim); }
  return;
}

}





/* ========== ê³µí†µ ìœ í‹¸ ========== */
function updateRingHoverVisuals(axis) {
  if (!ringX || !ringY || !ringZ) return;

  function setRingVisual(ring, style, scaleFactor) {
    ring.material.color.set(style.color);
    ring.material.opacity = style.opacity;
    ring.scale.set(scaleFactor, scaleFactor, scaleFactor);
  }

  if (axis === null) {
    setRingVisual(ringX, {color: RING_STYLE.x.color, opacity: RING_STYLE.x.opacity}, 1);
    setRingVisual(ringY, {color: RING_STYLE.y.color, opacity: RING_STYLE.y.opacity}, 1);
    setRingVisual(ringZ, {color: RING_STYLE.z.color, opacity: RING_STYLE.z.opacity}, 1);
    return;
  }

  const dimStyle = { color: DIM_COLOR, opacity: DIM_OPACITY };

  if (axis === "x") {
    setRingVisual(ringX, {color: RING_STYLE.x.color, opacity: 1.0}, HOVER_SCALE);
    setRingVisual(ringY, dimStyle, 1);
    setRingVisual(ringZ, dimStyle, 1);
  } else if (axis === "y") {
    setRingVisual(ringY, {color: RING_STYLE.y.color, opacity: 1.0}, HOVER_SCALE);
    setRingVisual(ringX, dimStyle, 1);
    setRingVisual(ringZ, dimStyle, 1);
  } else if (axis === "z") {
    setRingVisual(ringZ, {color: RING_STYLE.z.color, opacity: 1.0}, HOVER_SCALE);
    setRingVisual(ringX, dimStyle, 1);
    setRingVisual(ringY, dimStyle, 1);
  }
}

/* ì„ íƒëœ ê²ƒë“¤ì˜ ë°”ìš´ë”© ë°•ìŠ¤ ì¤‘ì‹¬ êµ¬í•˜ê¸° */
function getSelectionCenter() {
  const targets = selectedSet.size > 0 ? [...selectedSet]
                                      : (selectedMesh ? [selectedMesh] : []);
  if (targets.length === 0) return null;

  const box = new THREE.Box3();
  let hasBox = false;
  targets.forEach(o => {
    const b = new THREE.Box3().setFromObject(o);
    if (!hasBox) {
      box.copy(b);
      hasBox = true;
    } else {
      box.union(b);
    }
  });
  if (!hasBox) return null;

  const center = new THREE.Vector3();
  box.getCenter(center);
  return center;
}

/* ========== íšŒì „ Gizmo í¬ê¸°/ìœ„ì¹˜ ê°±ì‹  ========== */
function updateRotationGizmo() {
  if (!rotationGizmo) return;

  if (!gizmoEnabled) {
    rotationGizmo.visible = false;
    return;
  }

  if (!selectedMesh && selectedSet.size === 0) {
    rotationGizmo.visible = false;
    return;
  }

  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
  if (targets.length === 0) {
    rotationGizmo.visible = false;
    return;
  }

  const box = new THREE.Box3();
  let hasBox = false;
  targets.forEach(obj => {
    if (!obj) return;
    const objBox = new THREE.Box3().setFromObject(obj);
    if (!hasBox) {
      box.copy(objBox);
      hasBox = true;
    } else {
      box.union(objBox);
    }
  });

  if (!hasBox) {
    rotationGizmo.visible = false;
    return;
  }

  const center = new THREE.Vector3();
  box.getCenter(center);

  const dist   = camera.position.distanceTo(center);
  const fovRad = THREE.MathUtils.degToRad(camera.fov);

  const worldHeight   = 2 * dist * Math.tan(fovRad / 2);
  const worldPerPixel = worldHeight / window.innerHeight;
  const targetRadiusPx = 80;

  let radiusWorld = worldPerPixel * targetRadiusPx;
  if (!isFinite(radiusWorld) || radiusWorld <= 0) radiusWorld = 1;
  radiusWorld = Math.max(0.2, Math.min(radiusWorld, 3));

  rotationGizmo.position.copy(center);
  rotationGizmo.rotation.set(0, 0, 0);
  rotationGizmo.scale.setScalar(radiusWorld);
  rotationGizmo.visible = true;

  updateRingHoverVisuals(hoveredAxis);
}

/* ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ */
function updateCamera() {
  const x = camTarget.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = camTarget.y + radius * Math.cos(phi);
  const z = camTarget.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x, y, z);
  camera.lookAt(camTarget);

  updateRotationGizmo();

  // âœ… ì¹´ë©”ë¼ íšŒì „/ì´ë™ ì‹œ ì¹˜ìˆ˜ë„ ê°™ì´ ì¬ê³„ì‚°
 if (dimensionEnabled) {
  showDimensionsSmartForSelection();
}


}







/* ============================
   íšŒì „ Gizmo (X/Y/Z ì¶•)
============================ */
function initRotationGizmo() {
  rotationGizmo = new THREE.Group();

  const ringRadius = 1;
  const ringTube   = 0.15;
  const ringGeo = new THREE.TorusGeometry(ringRadius, ringTube, 24, 64);

  const matY = new THREE.MeshBasicMaterial({
    color: RING_STYLE.y.color,
    transparent: true,
    opacity: RING_STYLE.y.opacity,
    depthTest: true,
    depthWrite: false
  });
  ringY = new THREE.Mesh(ringGeo, matY);
  ringY.rotation.x = Math.PI / 2;
  ringY.userData.axis = "y";
  rotationGizmo.add(ringY);

  const matX = new THREE.MeshBasicMaterial({
    color: RING_STYLE.x.color,
    transparent: true,
    opacity: RING_STYLE.x.opacity,
    depthTest: true,
    depthWrite: false
  });
  ringX = new THREE.Mesh(ringGeo.clone(), matX);
  ringX.rotation.y = Math.PI / 2;
  ringX.userData.axis = "x";
  rotationGizmo.add(ringX);

  const matZ = new THREE.MeshBasicMaterial({
    color: RING_STYLE.z.color,
    transparent: true,
    opacity: RING_STYLE.z.opacity,
    depthTest: true,
    depthWrite: false
  });
  ringZ = new THREE.Mesh(ringGeo.clone(), matZ);
  ringZ.userData.axis = "z";
  rotationGizmo.add(ringZ);

  const edgeGeo = new THREE.TorusGeometry(ringRadius * 1.02, 0.02, 12, 64);
  const edgeMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.9
  });

  const edgeY = new THREE.Mesh(edgeGeo, edgeMat);
  edgeY.rotation.x = Math.PI / 2;
  rotationGizmo.add(edgeY);

  const edgeX = new THREE.Mesh(edgeGeo.clone(), edgeMat);
  edgeX.rotation.y = Math.PI / 2;
  rotationGizmo.add(edgeX);

  const edgeZ = new THREE.Mesh(edgeGeo.clone(), edgeMat);
  rotationGizmo.add(edgeZ);

  const hitTube = ringTube * 2.4;
  const hitGeo = new THREE.TorusGeometry(ringRadius, hitTube, 16, 32);
  const hitMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.0,
    depthTest: false,
    depthWrite: false
  });

  hitRingY = new THREE.Mesh(hitGeo, hitMat);
  hitRingY.rotation.x = Math.PI / 2;
  hitRingY.userData.axis = "y";
  rotationGizmo.add(hitRingY);

  hitRingX = new THREE.Mesh(hitGeo.clone(), hitMat.clone());
  hitRingX.rotation.y = Math.PI / 2;
  hitRingX.userData.axis = "x";
  rotationGizmo.add(hitRingX);

  hitRingZ = new THREE.Mesh(hitGeo.clone(), hitMat.clone());
  hitRingZ.userData.axis = "z";
  rotationGizmo.add(hitRingZ);

  rotationGizmo.visible = false;
  scene.add(rotationGizmo);

  updateRingHoverVisuals(null);
}
initRotationGizmo();

/* ===== ë“œë˜ê·¸ ë°•ìŠ¤ ===== */
function createSelectionRect(x, y, additive) {
  rectStartX = x;
  rectStartY = y;
  rectEndX   = x;
  rectEndY   = y;

  rectAdditive = !!additive;

  // âœ… ë“œë˜ê·¸ ì‹œì‘ ì‹œì  ì„ íƒ ìƒíƒœ ë°±ì—…
  rectBaseSelected = new Set(selectedSet);

  // âœ… ì„ì‹œ ì„ íƒ ì´ˆê¸°í™”
  rectHoverSet = new Set(rectBaseSelected);

  selectionRectEl.style.left   = x + "px";
  selectionRectEl.style.top    = y + "px";
  selectionRectEl.style.width  = "0px";
  selectionRectEl.style.height = "0px";
  selectionRectEl.style.display = "block";
}


function updateSelectionRect(x, y) {
  rectEndX = x;
  rectEndY = y;

  const minX = Math.min(rectStartX, rectEndX);
  const minY = Math.min(rectStartY, rectEndY);
  const maxX = Math.max(rectStartX, rectEndX);
  const maxY = Math.max(rectStartY, rectEndY);

  selectionRectEl.style.left   = minX + "px";
  selectionRectEl.style.top    = minY + "px";
  selectionRectEl.style.width  = (maxX - minX) + "px";
  selectionRectEl.style.height = (maxY - minY) + "px";

  // âœ… ë§¤ í”„ë ˆì„ clearAllSelection() ê¸ˆì§€!
  // ëŒ€ì‹  "ì´ë²ˆ í”„ë ˆì„ ë°•ìŠ¤ ì•ˆì— ë“¤ì–´ì˜¨ í›„ë³´"ë§Œ ê³„ì‚°í•´ì„œ ì„ì‹œ ì…‹ ë§Œë“¤ê¸°

  const nextSet = new Set(rectBaseSelected); // ê¸°ë³¸ = ì‹œì‘ ì‹œì  ì„ íƒ ìœ ì§€(ë˜ëŠ” Ctrl ì¶”ê°€)

  const proj = new THREE.Vector3();

  draggable.forEach(obj => {
    // ê·¸ë£¹/ë©”ì‹œ ìƒê´€ì—†ì´ ì›”ë“œ bbox ì¤‘ì‹¬ì ë§Œ ì”€ (ê°€ë³ê³  ì¶©ë¶„íˆ ì •í™•)
    const box = new THREE.Box3().setFromObject(obj);
    const center = new THREE.Vector3();
    box.getCenter(center);

    proj.copy(center).project(camera);
    const sx = ( proj.x * 0.5 + 0.5 ) * window.innerWidth;
    const sy = (-proj.y * 0.5 + 0.5 ) * window.innerHeight;

    if (sx >= minX && sx <= maxX && sy >= minY && sy <= maxY) {
      nextSet.add(obj);
    }
  });

  // âœ… "ìœ¤ê³½ì„ "ì€ ë°”ë€ ê²ƒë§Œ ì²˜ë¦¬ (diff ì ìš©)
  // - ì œê±°: hoverSetì— ìˆì—ˆëŠ”ë° nextì— ì—†ìŒ
  rectHoverSet.forEach(o => {
    if (!nextSet.has(o)) {
      selectedSet.delete(o);
      unmarkSelected(o);
    }
  });

  // - ì¶”ê°€: nextì— ìˆëŠ”ë° hoverSetì— ì—†ìŒ
  nextSet.forEach(o => {
    if (!rectHoverSet.has(o)) {
      selectedSet.add(o);
      markSelected(o);
    }
  });

  rectHoverSet = nextSet;

  // ë§ˆì§€ë§‰ ì„ íƒì„ selectedMeshë¡œ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  selectedMesh = selectedSet.size > 0 ? [...selectedSet][selectedSet.size - 1] : null;

  updateRotationGizmo();
}



function hideSelectionRect() {
  if (!selectionRectEl) return;
  selectionRectEl.style.display = "none";
}
window.snapPlateToPillarsTop = function () {
  const all = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (all.length < 2) {
    alert("ê¸°ë‘¥ë“¤ + ë§ˆê°íŒì„ ê°™ì´ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const plate = selectedMesh; // âœ… ë§ˆì§€ë§‰ ì„ íƒì´ ë§ˆê°íŒ
  if (!plate) return;

  saveState();

  // 1) ê¸°ë‘¥ë“¤(plate ì œì™¸) bbox
  const pillars = all.filter(o => o !== plate);
  const pBox = new THREE.Box3();
  pillars.forEach(o => pBox.union(new THREE.Box3().setFromObject(o)));

  const pillarsCenter = new THREE.Vector3();
  pBox.getCenter(pillarsCenter);

  const topY = pBox.max.y; // ê¸°ë‘¥ ìµœìƒë‹¨

  // 2) plate bbox
  const plateBox = new THREE.Box3().setFromObject(plate);
  const plateCenter = new THREE.Vector3();
  plateBox.getCenter(plateCenter);

  // 3) XZ ì„¼í„° ì •ë ¬
  plate.position.x += (pillarsCenter.x - plateCenter.x);
  plate.position.z += (pillarsCenter.z - plateCenter.z);

  // 4) plate ë°”ë‹¥ë©´(minY)ì´ topYì— ë‹¿ê²Œ
  const newPlateBox = new THREE.Box3().setFromObject(plate);
  const newPlateMinY = newPlateBox.min.y;
  plate.position.y += (topY - newPlateMinY);

  updateRotationGizmo();
};





/* ========== Undo / Clipboard ========== */
const undoStack = [];
const redoStack = [];
const UNDO_LIMIT = 30;
let clipboardList = [];

// âœ… Ctrl+C : ì„ íƒ ë³µì‚¬
function copySelected() {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (targets.length === 0) return;

  clipboardList = targets.map(src => {
    // âœ… ë³µì‚¬ ìˆœê°„ì—ë§Œ ì ì„  ì œê±° â†’ cloneì— ê°™ì´ ë”¸ë ¤ê°€ëŠ” ë¬¸ì œ ë°©ì§€
    const wasSelected = selectedSet.has(src);
    if (wasSelected) unmarkSelected(src);

    const clone = src.clone(true);
    clone.userData = { ...(src.userData || {}) };

    // cloneì— í˜¹ì‹œ ë‚¨ì•„ìˆì„ ì ì„ /í”ì ë„ ì œê±°
    stripSelectionOutlineDeep(clone);

    makeMaterialsUnique(clone);

    // ì›ë³¸ ì ì„  ë³µêµ¬
    if (wasSelected) markSelected(src);

    return clone;
  });

  console.log("Copied:", clipboardList.length);
}


// âœ… Ctrl+V : ë¶™ì—¬ë„£ê¸° (ì‚´ì§ ì˜†ìœ¼ë¡œ)
function pasteClipboard() {
  if (!clipboardList || clipboardList.length === 0) return;

  saveState();

  clearAllSelection();

  let last = null;
  clipboardList.forEach(srcClone => {
    const clone = srcClone.clone(true);
    clone.userData = { ...(srcClone.userData || {}) };
    makeMaterialsUnique(clone);
stripSelectionOutlineDeep(clone);

makeMaterialsUnique(clone);

    // ì‚´ì§ ì´ë™í•´ì„œ ë³´ì´ê²Œ
    clone.position.add(new THREE.Vector3(0.3, 0, 0.3));

    scene.add(clone);
    draggable.push(clone);

    selectedSet.add(clone);
    markSelected(clone);
    last = clone;
  });

  selectedMesh = last;
  setSelectedObject(selectedMesh);
  updateRotationGizmo();
}

// âœ… Ctrl+A : ì „ì²´ ì„ íƒ
function selectAll() {
  selectAllDraggables();
}


// âœ… í˜„ì¬ ìƒíƒœ ì €ì¥ (ì‘ì—… ì‹œì‘ ì§ì „ì— í˜¸ì¶œ)
function saveState() {
  const snapshot = [];
  draggable.forEach(obj => {
    const wasSelected = selectedSet.has(obj);
    if (wasSelected) unmarkSelected(obj);

    const clone = obj.clone(true);
    clone.userData = { ...obj.userData };
    snapshot.push(clone);

    if (wasSelected) markSelected(obj);
  });

  undoStack.push(snapshot);
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();

  // âœ… ìƒˆ ì‘ì—…ì´ ìƒê¸°ë©´ redoëŠ” ë¬´íš¨
  redoStack.length = 0;
}

function applySnapshot(snapshot) {
  draggable.forEach(o => scene.remove(o));
  draggable.length = 0;

  selectedSet.clear();
  selectedMesh = null;

  snapshot.forEach(clone => {
    scene.add(clone);
    draggable.push(clone);
  });

  updateRotationGizmo();
}

// âœ… Undo
function undo() {
  // âœ… "ë˜ëŒë¦´ ì´ì „ ìƒíƒœ"ê°€ ìˆìœ¼ë ¤ë©´ ìµœì†Œ 2ê°œ í•„ìš”
  if (undoStack.length < 2) return;

  // âœ… í˜„ì¬ ìƒíƒœ(ë§¨ ìœ„)ë¥¼ redoë¡œ ì´ë™
  const current = undoStack.pop();
  redoStack.push(current);

  // âœ… ì´ì œ ë§¨ ìœ„ê°€ "ì´ì „ ìƒíƒœ"
  const prev = undoStack[undoStack.length - 1];
  applySnapshot(prev);
}

// âœ… Redo
function redo() {
  if (redoStack.length === 0) return;

  const next = redoStack.pop();
  undoStack.push(next);
  applySnapshot(next);
}




function stripSelectionOutlineDeep(obj) {
  if (!obj) return;

  // 1) íŠ¸ë¦¬ ì•ˆì— ì„ì—¬ìˆëŠ” "ì ì„  ì˜¤ë¸Œì íŠ¸" ì œê±°
  const toRemove = [];
  obj.traverse(ch => {
    if (ch?.userData?.isSelectionOutline) toRemove.push(ch);
  });
  toRemove.forEach(ch => {
    if (ch.parent) ch.parent.remove(ch);
  });

  // 2) userData.selectionOutline í”ì  ì œê±° (ë©”ì‹œ/ê·¸ë£¹ ëª¨ë‘)
  obj.traverse(ch => {
    if (ch?.userData?.selectionOutline) {
      delete ch.userData.selectionOutline;
    }
  });
}



/* ========== STL ë°”ì´ë„ˆë¦¬ íŒë³„/íŒŒì‹± ========== */
function isBinarySTL(buffer) {
  if (buffer.byteLength < 84) return false;
  const dv = new DataView(buffer);
  const faces = dv.getUint32(80, true);
  const expected = 84 + faces * 50;
  return expected === buffer.byteLength;
}

function parseBinarySTL(buffer) {
  const dv = new DataView(buffer);
  const faces = dv.getUint32(80, true);
  const positions = new Float32Array(faces * 9);
  const normals   = new Float32Array(faces * 9);
  let offset = 84;
  let posIndex = 0;

  for (let i=0; i<faces; i++) {
    const nx = dv.getFloat32(offset, true); offset += 4;
    const ny = dv.getFloat32(offset, true); offset += 4;
    const nz = dv.getFloat32(offset, true); offset += 4;

    for (let v=0; v<3; v++) {
      const x = dv.getFloat32(offset, true); offset += 4;
      const y = dv.getFloat32(offset, true); offset += 4;
      const z = dv.getFloat32(offset, true); offset += 4;
      positions[posIndex]   = x;
      positions[posIndex+1] = y;
      positions[posIndex+2] = z;
      normals[posIndex]   = nx;
      normals[posIndex+1] = ny;
      normals[posIndex+2] = nz;
      posIndex += 3;
    }
    offset += 2;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  geo.setAttribute("normal",   new THREE.BufferAttribute(normals, 3));
  geo.computeBoundingSphere();
  geo.computeBoundingBox();
  return geo;
}

/* ========== íŒŒì¼ ì„ íƒ ì²˜ë¦¬ ========== */
const fileInput   = document.getElementById("fileInput");
const fileListDiv = document.getElementById("fileList");
let selectedIndex = -1;
const loadedSTL   = [];

fileInput.addEventListener("change", (e)=>{
  const files = Array.from(e.target.files);
  loadedSTL.length = 0;
  fileListDiv.innerHTML = "";
  selectedIndex = -1;

  if (files.length === 0) return;

  files.forEach((file, idx)=>{
    const reader = new FileReader();
    reader.onload = (ev)=>{
      const buffer = ev.target.result;
      if (!isBinarySTL(buffer)) {
        alert(file.name + " : ASCII STLë¡œ ë³´ì…ë‹ˆë‹¤. (í˜„ì¬ ì˜ˆì œëŠ” ë°”ì´ë„ˆë¦¬ë§Œ ì§€ì›)");
        return;
      }
      const geo = parseBinarySTL(buffer);
      loadedSTL.push({ name: file.name, geometry: geo });

      const div = document.createElement("div");
      div.textContent = file.name;
      div.className = "file-item";
      div.onclick = ()=>{
        const items = fileListDiv.querySelectorAll(".file-item");
        items.forEach(el=>el.style.background="");
        div.style.background = "#555";
        // âœ… ì²« ì„ íƒë„ UI ë°˜ì˜
        try {
          const key = (file.name || "").toLowerCase();
          const p = STL_DIM_OFFSETS[key];
          setSTLOffsetInputs(key, p?.x||0, p?.y||0, p?.z||0);
        } catch(e) {}
        selectedIndex = idx;
      
        // âœ… íŒŒì¼ ì„ íƒ ì‹œ ì €ì¥ëœ ë³´ì •ê°’ UIì— í‘œì‹œ
        try {
          const key = (file.name || "").toLowerCase();
          const p = STL_DIM_OFFSETS[key];
          setSTLOffsetInputs(key, p?.x||0, p?.y||0, p?.z||0);
        } catch(e) {}
};
      fileListDiv.appendChild(div);

      if (selectedIndex === -1) {
        selectedIndex = 0;
        div.style.background = "#555";
        // âœ… ì²« ì„ íƒë„ UI ë°˜ì˜
        try {
          const key = (file.name || "").toLowerCase();
          const p = STL_DIM_OFFSETS[key];
          setSTLOffsetInputs(key, p?.x||0, p?.y||0, p?.z||0);
        } catch(e) {}
      }
    };
    reader.readAsArrayBuffer(file);
  });
});

/* ========== STL ì •ì  ê¸°ë°˜ í¬íŠ¸ ì¤‘ì‹¬ ê³„ì‚° ========== */
function computeThreadCenters(geometry) {
  geometry.computeBoundingBox();
  const bb = geometry.boundingBox;
  const posAttr = geometry.getAttribute("position");
  if (!posAttr) return null;
  const arr = posAttr.array;

  const groups = { xp:[], xm:[], zp:[], zm:[], yp:[], ym:[] };

  const spanX = bb.max.x - bb.min.x;
  const spanY = bb.max.y - bb.min.y;
  const spanZ = bb.max.z - bb.min.z;
  const epsX  = spanX * 0.12;
  const epsY  = spanY * 0.12;
  const epsZ  = spanZ * 0.12;

  for (let i=0; i<arr.length; i+=3) {
    const x = arr[i];
    const y = arr[i+1];
    const z = arr[i+2];

    if (bb.max.x - x < epsX) groups.xp.push(new THREE.Vector3(x,y,z));
    if (x - bb.min.x < epsX) groups.xm.push(new THREE.Vector3(x,y,z));
    if (bb.max.z - z < epsZ) groups.zp.push(new THREE.Vector3(x,y,z));
    if (z - bb.min.z < epsZ) groups.zm.push(new THREE.Vector3(x,y,z));

    if (bb.max.y - y < epsY) groups.yp.push(new THREE.Vector3(x,y,z));
    if (y - bb.min.y < epsY) groups.ym.push(new THREE.Vector3(x,y,z));
  }

  const avg = pts => {
    const c = new THREE.Vector3();
    pts.forEach(p=>c.add(p));
    c.multiplyScalar(1/pts.length);
    return c;
  };

  const result = {};
  if (groups.xp.length>=3) result.xp = avg(groups.xp);
  if (groups.xm.length>=3) result.xm = avg(groups.xm);
  if (groups.zp.length>=3) result.zp = avg(groups.zp);
  if (groups.zm.length>=3) result.zm = avg(groups.zm);
  if (groups.yp.length>=3) result.yp = avg(groups.yp);
  if (groups.ym.length>=3) result.ym = avg(groups.ym);

  return result;
}

// âœ… ìº¡(í‰í‰í•œ ëë‹¨) ë©´ì„ ì´ìš©í•´ì„œ í¬íŠ¸(ìŠ¤ëƒ… í¬ì¸íŠ¸) 2ê°œ ìë™ ì¶”ì •
// - ë‚˜ì‚¬ì‚° ì—†ëŠ” "í‰í‰í•œ ëë‹¨" ëª¨ë¸ì¼ìˆ˜ë¡ ì •í™•ë„ê°€ ì˜¬ë¼ê°‘ë‹ˆë‹¤.
// - ì§€ì˜¤ë©”íŠ¸ë¦¬ê°€ indexed / non-indexed ìƒê´€ì—†ì´ position ê¸°ì¤€ìœ¼ë¡œ ì‚¼ê°í˜•ì„ í›‘ìŠµë‹ˆë‹¤.
function computeCapPortsFromGeometry(geometry, wantCount = 2) {
  const posAttr = geometry && geometry.attributes && geometry.attributes.position;
  if (!posAttr || posAttr.count < 3) return null;

  const bins = new Map();

  const a = new THREE.Vector3();
  const b = new THREE.Vector3();
  const c = new THREE.Vector3();
  const ab = new THREE.Vector3();
  const ac = new THREE.Vector3();
  const n  = new THREE.Vector3();
  const triCenter = new THREE.Vector3();

  // normalì„ 0.1 ë‹¨ìœ„ë¡œ ì–‘ìí™”í•´ì„œ binning (ìº¡ì€ normal ë°©í–¥ì´ ê±°ì˜ ì¼ì •í•´ì„œ areaê°€ í¬ê²Œ ëª¨ì„)
  function keyFromNormal(nx, ny, nz) {
    const qx = Math.round(nx * 10) / 10;
    const qy = Math.round(ny * 10) / 10;
    const qz = Math.round(nz * 10) / 10;
    return `${qx},${qy},${qz}`;
  }

  // positionì€ (i, i+1, i+2)ê°€ í•œ triangleì´ë¼ê³  ê°€ì • (STLâ†’positions ë°©ì‹ì´ë©´ ë³´í†µ ì´ êµ¬ì¡°)
  for (let i = 0; i < posAttr.count; i += 3) {
    a.fromBufferAttribute(posAttr, i);
    b.fromBufferAttribute(posAttr, i + 1);
    c.fromBufferAttribute(posAttr, i + 2);

    ab.subVectors(b, a);
    ac.subVectors(c, a);
    n.crossVectors(ab, ac);

    const area2 = n.length();
    if (!isFinite(area2) || area2 < 1e-10) continue;

    const area = area2 * 0.5;
    n.multiplyScalar(1 / area2); // normalize

    const key = keyFromNormal(n.x, n.y, n.z);

    triCenter.copy(a).add(b).add(c).multiplyScalar(1 / 3);

    let bin = bins.get(key);
    if (!bin) {
      bin = {
        n: new THREE.Vector3(
          Math.round(n.x * 10) / 10,
          Math.round(n.y * 10) / 10,
          Math.round(n.z * 10) / 10
        ).normalize(),
        area: 0,
        c: new THREE.Vector3(0, 0, 0)
      };
      bins.set(key, bin);
    }

    bin.area += area;
    bin.c.addScaledVector(triCenter, area);
  }

  const candidates = Array.from(bins.values())
    .filter(v => v.area > 1e-6)
    .sort((p, q) => q.area - p.area);

  if (candidates.length === 0) return null;

  const ports = [];
  const topArea = candidates[0].area;

  for (const cand of candidates) {
    if (ports.length >= wantCount) break;

    // ë„ˆë¬´ ì‘ì€ ë©´ ê·¸ë£¹ì€ ì œì™¸ (ìº¡ì´ ì•„ë‹Œ ì¡ë©´)
    if (cand.area < topArea * 0.08) continue;

    const dir = cand.n.clone().normalize();

    // ì´ë¯¸ ì„ íƒëœ normalê³¼ ë„ˆë¬´ ë¹„ìŠ·í•˜ë©´ ìŠ¤í‚µ
    const tooClose = ports.some(p => p.normalVec.dot(dir) > 0.90);
    if (tooClose) continue;

    const center = cand.c.clone().multiplyScalar(1 / cand.area);

    ports.push({
      pos: [center.x, center.y, center.z],
      normal: [dir.x, dir.y, dir.z],
      normalVec: dir,
      area: cand.area
    });
  }

  if (ports.length < wantCount) return null;

  // normalì´ "ë°”ê¹¥"ì„ í–¥í•˜ë„ë¡ ì •ë ¬ (bbox centerì—ì„œ í¬íŠ¸ ë°©í–¥ìœ¼ë¡œ ì–‘ì˜ dot)
  geometry.computeBoundingBox();
  const bb = geometry.boundingBox;
  const mid = new THREE.Vector3();
  bb.getCenter(mid);

  ports.forEach(p => {
    const v = new THREE.Vector3(p.pos[0], p.pos[1], p.pos[2]);
    const dir = new THREE.Vector3(p.normal[0], p.normal[1], p.normal[2]).normalize();
    if (v.clone().sub(mid).dot(dir) < 0) dir.multiplyScalar(-1);
    p.normal = [dir.x, dir.y, dir.z];
    delete p.normalVec;
  });

  return ports.slice(0, wantCount);
}





/* ========== íŒŒì´í”„ attach í¬ì¸íŠ¸ (ì–‘ ë) ========== */
function getPipeEndPointsWorld(mesh) {
  const geom = mesh.geometry;
  geom.computeBoundingBox();
  const bb = geom.boundingBox;
  const yTop = bb.max.y;
  const yBot = bb.min.y;
  const localPoints = [
    new THREE.Vector3(0, yTop, 0),
    new THREE.Vector3(0, yBot, 0)
  ];
  return localPoints.map(p => mesh.localToWorld(p.clone()));
}

/* ========== inline ë¶€ì† ëë‹¨ ê³„ì‚° ========== */
function getInlineEndPointsWorld(mesh) {
  const geom = mesh.geometry;
  geom.computeBoundingBox();
  const bb = geom.boundingBox;

  const size = new THREE.Vector3();
  bb.getSize(size);

  const cx = (bb.min.x + bb.max.x)/2;
  const cy = (bb.min.y + bb.max.y)/2;
  const cz = (bb.min.z + bb.max.z)/2;

  const name = (mesh.userData && mesh.userData.stlName || "").toLowerCase();
  const meta = FITTING_META[name] || {};

  const axis = meta.axis || "z";
  const fracIn1 = (meta.fracIn1 != null) ? meta.fracIn1 : 0;
  const fracIn2 = (meta.fracIn2 != null) ? meta.fracIn2 : 0;

  let p1, p2;
  if (axis === "x") {
    const len = size.x;
    p1 = new THREE.Vector3(bb.max.x - len*fracIn1, cy, cz);
    p2 = new THREE.Vector3(bb.min.x + len*fracIn2, cy, cz);
  } else if (axis === "y") {
    const len = size.y;
    p1 = new THREE.Vector3(cx, bb.max.y - len*fracIn1, cz);
    p2 = new THREE.Vector3(cx, bb.min.y + len*fracIn2, cz);
  } else {
    const len = size.z;
    p1 = new THREE.Vector3(cx, cy, bb.max.z - len*fracIn1);
    p2 = new THREE.Vector3(cx, cy, bb.min.z + len*fracIn2);
  }

  return [
    mesh.localToWorld(p1.clone()),
    mesh.localToWorld(p2)
  ];
}

/* ========== STL ë¶€ì† attach í¬ì¸íŠ¸ (ì¢…í•©) ========== */
function getWorldAttachPointsForMesh(mesh) {
  const geom = mesh.geometry;
  geom.computeBoundingBox();

  if (mesh.userData && mesh.userData.isPipe) {
    return getPipeEndPointsWorld(mesh);
  }

  if (mesh.userData && mesh.userData.kind === "inline") {
    return getInlineEndPointsWorld(mesh);
  }

  // âœ… (ì¶”ê°€) ì»¤ìŠ¤í…€ ë¶€ì†(ì˜ˆ: 12mm/15mm íë¸Œ) snapPoints ì§€ì›
  // snapPoints í˜•ì‹: [{ pos: Vector3 | [x,y,z] | {x,y,z}, normal?: ... }, ...]
  if (mesh.userData && Array.isArray(mesh.userData.snapPoints) && mesh.userData.snapPoints.length) {
    mesh.updateWorldMatrix(true, false);
    return mesh.userData.snapPoints
      .map(sp => {
        if (!sp || !sp.pos) return null;

        let v;
        if (sp.pos instanceof THREE.Vector3) {
          v = sp.pos.clone();
        } else if (Array.isArray(sp.pos) && sp.pos.length >= 3) {
          v = new THREE.Vector3(sp.pos[0], sp.pos[1], sp.pos[2]);
        } else if (typeof sp.pos === "object" && sp.pos.x != null && sp.pos.y != null && sp.pos.z != null) {
          v = new THREE.Vector3(sp.pos.x, sp.pos.y, sp.pos.z);
        } else {
          return null;
        }
        return mesh.localToWorld(v);
      })
      .filter(Boolean);
  }

  if (mesh.userData && mesh.userData.threadCenters) {
    const centers = mesh.userData.threadCenters;
    const pts = [];

    for (const k in centers) {
      const val = centers[k];
      if (!val) continue;

      let v;
      if (val instanceof THREE.Vector3) {
        v = val.clone();
      } else if (Array.isArray(val) && val.length >= 3) {
        v = new THREE.Vector3(val[0], val[1], val[2]);
      } else if (typeof val === "object" && val.x != null && val.y != null && val.z != null) {
        v = new THREE.Vector3(val.x, val.y, val.z);
      } else {
        continue;
      }
      pts.push(mesh.localToWorld(v));
    }

    if (pts.length > 0) return pts;
  }

  return getInlineEndPointsWorld(mesh);
}

/* ========== ë°”ë‹¥(y=0)ì— ì˜¬ë ¤ë†“ê¸° ========== */
function placeOnGround(obj) {
  obj.updateWorldMatrix(true, false);
  const box = new THREE.Box3().setFromObject(obj);
  if (!isFinite(box.min.y)) return;
  const dy = box.min.y;
  obj.position.y -= dy;
}

function placeSelectionOnGround() {
  if (!selectedMesh && selectedSet.size === 0) {
    alert("ë¨¼ì € ë°”ë‹¥ì— ë§ì¶œ ê°œì²´ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }
  saveState();
  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
  targets.forEach(o => placeOnGround(o));
  updateRotationGizmo();
}


/* ========== ì„ íƒ/ì ì„  ìœ¤ê³½ì„  ìœ í‹¸ ========== */
function markSelected(obj) {
  // ê·¸ë£¹ì´ë©´ ë‚´ë¶€ Meshë“¤ì—ê²Œ ì¬ê·€ ì ìš©
  if (obj instanceof THREE.Group) {
    obj.traverse(child => {
      if (child.isMesh) markSelected(child);
    });
    return;
  }

  if (!obj.geometry) return;

  // ì´ë¯¸ ìœ¤ê³½ì„ ì´ ìˆìœ¼ë©´ ë˜ ë§Œë“¤ì§€ ì•ŠìŒ
  if (obj.userData && obj.userData.selectionOutline) return;

  // ë¶€ì† ì™¸ê³½ì„ (edge) ì¶”ì¶œ
  const edgeGeo = new THREE.EdgesGeometry(obj.geometry);

  const dashedMat = new THREE.LineDashedMaterial({
    color: 0xffff00,   // ë…¸ë€ ì ì„ 
    dashSize: 0.004,   // ì  ê¸¸ì´
    gapSize: 0.002,    // ì ê³¼ ì  ì‚¬ì´ ê°„ê²©
    linewidth: 1
  });

  const outline = new THREE.LineSegments(edgeGeo, dashedMat);

// âœ… ë ˆì´ìºìŠ¤íŠ¸ì—ì„œ ì œì™¸ (ì„ íƒ í•´ì œ ì•ˆ ë˜ë˜ ë¬¸ì œ í•´ê²°)
outline.raycast = function(){};
outline.userData.isSelectionOutline = true;

// ë³¸ì²´ì™€ ê²¹ì³ì„œ ê¹œë¹¡ì´ëŠ” í˜„ìƒ ì¤„ì´ë ¤ê³  ì‚´ì§ í‚¤ì›€
outline.scale.set(1.001, 1.001, 1.001);
outline.computeLineDistances();

// ì„ íƒëœ ì˜¤ë¸Œì íŠ¸ì— ìì‹ìœ¼ë¡œ ë¶™ì—¬ì„œ ê°™ì´ ì›€ì§ì´ê²Œ
obj.add(outline);

// ë‚˜ì¤‘ì— ì œê±°í•  ìˆ˜ ìˆê²Œ ì €ì¥
obj.userData = obj.userData || {};
obj.userData.selectionOutline = outline;

}

function unmarkSelected(obj) {
  // ê·¸ë£¹ì´ë©´ ë‚´ë¶€ Meshë“¤ì—ê²Œ ì¬ê·€ ì ìš©
  if (obj instanceof THREE.Group) {
    obj.traverse(child => {
      if (child.isMesh) unmarkSelected(child);
    });
    return;
  }

  if (!obj.userData) return;
  const outline = obj.userData.selectionOutline;
  if (outline && outline.parent) {
    outline.parent.remove(outline);
  }
  delete obj.userData.selectionOutline;
}



function clearAllSelection() {
  selectedSet.forEach(o => {
    unmarkSelected(o);
  });
  selectedSet.clear();
  selectedMesh = null;

  // ğŸ”¹ ì¹˜ìˆ˜ ì œê±°
  hideAllDimensions();

  // ğŸ”¹ ìœ¤ê³½ì„ ë„ ê°™ì´ ì œê±°
  setSelectedObject(null);

  updateRotationGizmo();
}



function selectOnly(obj) {
  clearAllSelection();
  selectedSet.add(obj);
  markSelected(obj);
  selectedMesh = obj;

  // ğŸ”¹ ë‹¨ì¼ ì„ íƒ â†’ ìœ¤ê³½ì„  ì´ ê°ì²´ì— ì ìš©
  setSelectedObject(selectedMesh);

    // âœ… ì¹˜ìˆ˜ëŠ” Dí‚¤ ONì¼ ë•Œë§Œ

 if (dimensionEnabled && selectedMesh) showDimensionsForSelection(selectedMesh);




  updateRotationGizmo();
}



function toggleSelect(obj) {
  if (selectedSet.has(obj)) {
    selectedSet.delete(obj);
    unmarkSelected(obj);
    if (selectedMesh === obj) {
      selectedMesh = selectedSet.size > 0 ? [...selectedSet][selectedSet.size-1] : null;
    }
  } else {
    selectedSet.add(obj);
    markSelected(obj);
    selectedMesh = obj;
  }

  // ğŸ”¹ ë§ˆì§€ë§‰ ì„ íƒëœ ì• ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ¤ê³½ì„  í‘œì‹œ
  setSelectedObject(selectedMesh);

    // âœ… ì¹˜ìˆ˜ëŠ” Dí‚¤ ONì¼ ë•Œë§Œ
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);


  updateRotationGizmo();
}



function translateSelection(dx, dy, dz) {
  if (!selectedMesh && selectedSet.size === 0) return;
  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
  targets.forEach(o => {
    o.position.x += dx;
    o.position.y += dy;
    o.position.z += dz;
  });
  updateRotationGizmo();
}

// â˜… ì¹´ë©”ë¼(í™”ë©´) ê¸°ì¤€ìœ¼ë¡œ ì„ íƒëœ ì˜¤ë¸Œì íŠ¸ ì´ë™
function moveSelectionViewRelative(deltaRight, deltaForward) {
  if (!selectedMesh && selectedSet.size === 0) return;

  // ì¹´ë©”ë¼ê°€ ë³´ê³  ìˆëŠ” ë°©í–¥
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);

  // í™”ë©´ì—ì„œ "ì˜¤ë¥¸ìª½" ë°©í–¥ (ìˆ˜í‰ í‰ë©´ì— íˆ¬ì˜)
  const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
  const rightOnPlane = new THREE.Vector3(right.x, 0, right.z);

  // í™”ë©´ì—ì„œ "ì•/ìœ„ìª½" ë°©í–¥ (ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ìª½ì„ í‰ë©´ì— íˆ¬ì˜)
  const forwardOnPlane = new THREE.Vector3(dir.x, 0, dir.z);

  if (rightOnPlane.lengthSq() < 1e-6 || forwardOnPlane.lengthSq() < 1e-6) return;
  rightOnPlane.normalize();
  forwardOnPlane.normalize();

  // ìµœì¢… ì´ë™ ë²¡í„°
  const move = new THREE.Vector3();
  move.addScaledVector(rightOnPlane,   deltaRight);
  move.addScaledVector(forwardOnPlane, deltaForward);

  translateSelection(move.x, 0, move.z);
}



function selectAllDraggables() {
  clearAllSelection();
  draggable.forEach(o=>{
    selectedSet.add(o);
    markSelected(o);
  });
  selectedMesh = draggable[draggable.length-1] || null;
  updateRotationGizmo();
}

/* ì¬ì§ˆ ë³µì‚¬ ìœ í‹¸ */
function makeMaterialsUnique(obj) {
  obj.traverse(o => {
    if (o.isMesh && o.material) {
      o.material = o.material.clone();
    }
  });
}


/* =========================================================
   âœ… STL ì¹˜ìˆ˜ ë³´ì •(ë¶€ì†ë³„) : +mm ì˜¤í”„ì…‹ìœ¼ë¡œ ì¶•ë³„ ìŠ¤ì¼€ì¼ ë³´ì •
   - ì €ì¥/ë³µì›: localStorage("pipe3d_stl_dim_offsets")
   - ì ìš© ëŒ€ìƒ: ì„ íƒëœ ë¶€ì†(ê¸°ë³¸ì ìœ¼ë¡œ pipe/plate ì œì™¸)
========================================================= */
const STL_DIM_OFFSETS_KEY = "pipe3d_stl_dim_offsets";
let STL_DIM_OFFSETS = {};
try {
  STL_DIM_OFFSETS = JSON.parse(localStorage.getItem(STL_DIM_OFFSETS_KEY) || "{}") || {};
} catch(e) {
  STL_DIM_OFFSETS = {};
}

function persistSTLOffsets() {
  try { localStorage.setItem(STL_DIM_OFFSETS_KEY, JSON.stringify(STL_DIM_OFFSETS)); } catch(e){}
}

// âœ… í˜„ì¬ í‘œì‹œ ì¹˜ìˆ˜(mm) ê¸°ì¤€ìœ¼ë¡œ +mm ë§Œí¼ ì¶•ë³„ ëŠ˜ë¦¬ê¸°
function applyDimensionOffsetMM(mesh, addXmm=0, addYmm=0, addZmm=0){
  if (!mesh) return;

  // íŒŒì´í”„/íŒì€ ì œì™¸(ì›í•˜ë©´ ì—¬ê¸°ì„œ í’€ì–´ë„ ë¨)
  if (mesh.userData?.isPipe || mesh.userData?.isRectPlate || (mesh.userData?.isPlate && mesh.userData?.plateShape)) return;

  // í˜„ì¬ ì›”ë“œ ê¸°ì¤€ í¬ê¸°(Units)
  mesh.updateWorldMatrix(true, true);
  const box = getWorldBoxIgnoreOutline(mesh) || new THREE.Box3().setFromObject(mesh);

  const sizeU = new THREE.Vector3();
  box.getSize(sizeU);

  // Units â†’ mm
  const curX = sizeU.x * MM_PER_UNIT;
  const curY = sizeU.y * MM_PER_UNIT;
  const curZ = sizeU.z * MM_PER_UNIT;

  if (curX <= 1e-9 || curY <= 1e-9 || curZ <= 1e-9) return;

  const tgtX = Math.max(0.001, curX + (parseFloat(addXmm)||0));
  const tgtY = Math.max(0.001, curY + (parseFloat(addYmm)||0));
  const tgtZ = Math.max(0.001, curZ + (parseFloat(addZmm)||0));

  const sx = tgtX / curX;
  const sy = tgtY / curY;
  const sz = tgtZ / curZ;

  mesh.scale.x *= sx;
  mesh.scale.y *= sy;
  mesh.scale.z *= sz;

  mesh.updateWorldMatrix(true, true);

  // ê¸°ë¡(ëˆ„ì )
  const ox = (parseFloat(addXmm)||0), oy = (parseFloat(addYmm)||0), oz = (parseFloat(addZmm)||0);
  mesh.userData.dimOffsetMM = {
    x: (mesh.userData.dimOffsetMM?.x || 0) + ox,
    y: (mesh.userData.dimOffsetMM?.y || 0) + oy,
    z: (mesh.userData.dimOffsetMM?.z || 0) + oz
  };
}

// ì €ì¥ëœ í”„ë¦¬ì…‹ ì ìš©(ë°°ì¹˜ ì‹œ ìë™)
function applySavedSTLOffsetIfAny(mesh, stlName){
  const key = (stlName || mesh?.userData?.stlName || "").toLowerCase();
  if (!key) return;
  const p = STL_DIM_OFFSETS[key];
  if (!p) return;
  applyDimensionOffsetMM(mesh, p.x||0, p.y||0, p.z||0);
}

// UI â†” ë°ì´í„°
function getSTLOffsetInputs(){
  const elX = document.getElementById("stlOffX");
  const elY = document.getElementById("stlOffY");
  const elZ = document.getElementById("stlOffZ");
  return {
    x: elX ? parseFloat(elX.value) || 0 : 0,
    y: elY ? parseFloat(elY.value) || 0 : 0,
    z: elZ ? parseFloat(elZ.value) || 0 : 0
  };
}
function setSTLOffsetInputs(name, x=0, y=0, z=0){
  const elX = document.getElementById("stlOffX");
  const elY = document.getElementById("stlOffY");
  const elZ = document.getElementById("stlOffZ");
  const elN = document.getElementById("stlOffName");
  if (elX) elX.value = (x||0);
  if (elY) elY.value = (y||0);
  if (elZ) elZ.value = (z||0);
  if (elN) elN.value = (name||"");
}

function getSelectedStlKey(){
  const obj = selectedMesh;
  if (!obj) return null;
  const name = (obj.userData?.stlName || obj.name || "").toLowerCase();
  return name || null;
}

function refreshSTLOffsetUIFromSelection(){
  const key = getSelectedStlKey();
  if (!key) { setSTLOffsetInputs("",0,0,0); return; }

  const p = STL_DIM_OFFSETS[key];
  setSTLOffsetInputs(key, p?.x||0, p?.y||0, p?.z||0);
}

function applySTLOffsetToSelection(){
  if (!selectedMesh) { alert("ë¨¼ì € ë³´ì •í•  ë¶€ì†ì„ ì„ íƒí•˜ì„¸ìš”."); return; }
  const key = getSelectedStlKey();
  if (!key) { alert("ì„ íƒ ë¶€ì†ì˜ stlNameì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."); return; }

  const {x,y,z} = getSTLOffsetInputs();

  if (Math.abs(x)+Math.abs(y)+Math.abs(z) < 1e-9) {
    alert("X/Y/Z ì¤‘ í•˜ë‚˜ë¼ë„ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  saveState();
  applyDimensionOffsetMM(selectedMesh, x, y, z);
  placeOnGround(selectedMesh);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsSmartForSelection();
}

function saveSTLOffsetPresetForSelection(){
  if (!selectedMesh) { alert("ë¨¼ì € ë¶€ì†ì„ ì„ íƒí•˜ì„¸ìš”."); return; }
  const key = getSelectedStlKey();
  if (!key) { alert("ì„ íƒ ë¶€ì†ì˜ stlNameì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."); return; }

  const {x,y,z} = getSTLOffsetInputs();
  STL_DIM_OFFSETS[key] = { x, y, z };
  persistSTLOffsets();
  alert(`ì €ì¥ ì™„ë£Œ: ${key}\nX:+${x}mm / Y:+${y}mm / Z:+${z}mm`);
}

function clearSTLOffsetPresetForSelection(){
  if (!selectedMesh) { alert("ë¨¼ì € ë¶€ì†ì„ ì„ íƒí•˜ì„¸ìš”."); return; }
  const key = getSelectedStlKey();
  if (!key) { alert("ì„ íƒ ë¶€ì†ì˜ stlNameì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."); return; }

  delete STL_DIM_OFFSETS[key];
  persistSTLOffsets();
  refreshSTLOffsetUIFromSelection();
  alert(`ì‚­ì œ ì™„ë£Œ: ${key}`);
}


/* ========== ì„ íƒëœ STL ë°°ì¹˜ ========== */
function spawnSelected(){
  if (selectedIndex < 0 || selectedIndex >= loadedSTL.length) {
    alert("ë¨¼ì € ë°°ì¹˜í•  STL íŒŒì¼ì„ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }
  saveState();
  const data = loadedSTL[selectedIndex];
  const mat = bodyMat.clone();
  const mesh = new THREE.Mesh(data.geometry.clone(), mat);

  mesh.geometry.computeBoundingBox();
  const c = new THREE.Vector3();
  mesh.geometry.boundingBox.getCenter(c);
  mesh.geometry.translate(-c.x, -c.y, -c.z);

  mesh.position.set(0,0,0);
  mesh.scale.set(FITTING_SCALE, FITTING_SCALE, FITTING_SCALE);

  
  // âœ… STLë³„ ì¹˜ìˆ˜ ë³´ì • í”„ë¦¬ì…‹(ì €ì¥ëœ +mm) ìë™ ì ìš©
  applySavedSTLOffsetIfAny(mesh, data.name);
mesh.userData.kind    = "generic";
  mesh.userData.stlName = data.name;

  placeOnGround(mesh);

   scene.add(mesh);
  draggable.push(mesh);

  clearAllSelection();
  selectedSet.add(mesh);
  markSelected(mesh);
  selectedMesh = mesh;

  // ğŸ”¹ ë§‰ ë°°ì¹˜í•œ ë¶€ì†ì—ë„ ìœ¤ê³½ì„  í‘œì‹œ
  setSelectedObject(selectedMesh);

  updateRotationGizmo();
}


/* ========== ë‚´ì¥ ë¶€ì† ìƒì„±ë“¤ ========== */
//íŒŒì´í”„ ê¸¸ì´ ìˆ˜ì •//
function resizeSelectedPipePrompt() {
  if (!selectedMesh || !selectedMesh.userData?.isPipe) {
    alert("ê¸¸ì´ë¥¼ ìˆ˜ì •í•  íŒŒì´í”„ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const cur = selectedMesh.userData.lengthMm || 100;
  const input = prompt("ìƒˆ íŒŒì´í”„ ê¸¸ì´(mm)", cur);
  if (input === null) return;

  const newLenMm = parseFloat(input);
  if (!newLenMm || newLenMm <= 0) {
    alert("0ë³´ë‹¤ í° ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  saveState();

  const radiusMm =
    selectedMesh.userData.radiusMm ||
    (KS_OD[selectedMesh.userData.size] / 2);

  const radiusUnits = radiusMm / MM_PER_UNIT;
  const lenUnits = newLenMm / MM_PER_UNIT;

  const geo = new THREE.CylinderGeometry(
    radiusUnits,
    radiusUnits,
    lenUnits,
    24
  );

  selectedMesh.geometry.dispose();
  selectedMesh.geometry = geo;
  selectedMesh.userData.lengthMm = newLenMm;

  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);

}






/* =================================================================
   [ìˆ˜ì •ë¨] KS 15A ì†Œì¼“ (Chamfered + Vertical)
   - ëª¨ë”°ê¸°(Chamfer): 1mm ì ìš© (LatheGeometry ì‚¬ìš©)
   - êµ¬ì¡°: Yì¶• ë°©í–¥(ìˆ˜ì§)ìœ¼ë¡œ ì„œ ìˆëŠ” í˜•íƒœ
   - ì¬ì§ˆ: DoubleSide (êµ¬ë© ë°©ì§€)
   ================================================================= */
window.spawnProceduralSocket15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì •
  const TOTAL_LEN_MM = 35; // ì „ì²´ ê¸¸ì´
  const HALF_LEN = (TOTAL_LEN_MM / 2) / MM_PER_UNIT; 

  const bodyDiaMm = 27;    
  const bandDiaMm = 31;    
  const bandHeightMm = 8;  
  const chamferMm = 1;     // [í•µì‹¬] ëª¨ë”°ê¸° 1mm ì¶”ê°€
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  // [ì•ˆì „ì¥ì¹˜] side: THREE.DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide 
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„± ---
  const bodyLen = (TOTAL_LEN_MM - (bandHeightMm * 2)) / MM_PER_UNIT; 
  const bodyGeo = new THREE.CylinderGeometry(rBody, rBody, bodyLen, 32);
  
  const mainMesh = new THREE.Mesh(bodyGeo, mat);
  
  // Yì¶• ë°©í–¥(ìœ„)ìœ¼ë¡œ ì„œ ìˆìŒ (íšŒì „ ì—†ìŒ)

  // --- 3. ìì‹ ë¶€í’ˆ(Band) ë¶™ì´ê¸° - ëª¨ë”°ê¸° ì ìš© ---
  // CylinderGeometry ëŒ€ì‹  ë‹¨ë©´ì„ ê·¸ë ¤ì„œ íšŒì „ì‹œí‚¤ëŠ” LatheGeometry ì‚¬ìš©
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ ê·¸ë¦¬ê¸°
    // 1. ë°”ë‹¥ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, -hBand/2));
    // 2. ë°”ë‹¥ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ì‹œì‘ì )
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2));
    // 3. ë°”ë‹¥ ì¸¡ë©´ (ëª¨ë”°ê¸° ëì )
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer));
    // 4. ìœ„ìª½ ì¸¡ë©´ (ëª¨ë”°ê¸° ì‹œì‘ì )
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));
    // 5. ìœ„ìª½ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ëì )
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));
    // 6. ìœ„ìª½ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, hBand/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals(); // ë¶€ë“œëŸ¬ìš´ ê³¡ë©´ ì²˜ë¦¬
    return new THREE.Mesh(geo, mat);
  }

  // ë°´ë“œ ìœ„ì¹˜ ê³„ì‚° (ìœ„/ì•„ë˜ ëŒ€ì¹­)
  const bandOffset = (bodyLen / 2) + (hBand / 2);

  // (1) ìœ„ìª½ ë°´ë“œ
  const bandTop = createChamferedBand();
  bandTop.position.set(0, bandOffset, 0); 
  mainMesh.add(bandTop);

  // (2) ì•„ë˜ìª½ ë°´ë“œ
  const bandBottom = createChamferedBand();
  bandBottom.position.set(0, -bandOffset, 0); 
  mainMesh.add(bandBottom);

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "socket",     
      subKind: "15a",     
      stlName: "Socket15A_Chamfer", // ì´ë¦„ ë³€ê²½ë¨

      // [ìŠ¤ëƒ… í¬ì¸íŠ¸]
      // ë³¸ì²´ê°€ ì„œ ìˆìœ¼ë¯€ë¡œ ë¡œì»¬ Yì¶•([0,1,0])ì´ ê³§ ìœ„ìª½ì…ë‹ˆë‹¤.
      snapPoints: [
        { pos: [0, HALF_LEN, 0], normal: [0, 1, 0] },  // ìœ„ (Top)
        { pos: [0, -HALF_LEN, 0], normal: [0, -1, 0] } // ì•„ë˜ (Bottom)
      ],
      
      threadCenters: {
        port1: [0, HALF_LEN, 0],
        port2: [0, -HALF_LEN, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};





/* =================================================================
   [ë³µêµ¬ ë° ìˆ˜ì •] 90ë„ ì—˜ë³´ 15A (Chamfered + Snap Fixed)
   - ë°´ë“œ ëª¨ë”°ê¸°(Chamfer) 1mm ì ìš©
   - ìŠ¤ëƒ… í¬ì¸íŠ¸ ë³´ì •(4mm Out) ì ìš©
   ================================================================= */
window.spawnProceduralElbow15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (15A)
  const ELBOW_RADIUS_MM = 23; 
  const BODY_DIA_MM = 27;     
  const BAND_DIA_MM = 31;     
  const BAND_HEIGHT_MM = 8;   
  const CHAMFER_MM = 1; // ëª¨ë”°ê¸° 1mm

  const R_MAIN = ELBOW_RADIUS_MM / MM_PER_UNIT; 
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  // ìŠ¤ëƒ… ë³´ì •ê°’ (ë°´ë“œ ì ˆë°˜)
  const snapOffset = hBand / 2; // 4mm

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ (í† ëŸ¬ìŠ¤) ---
  const torusGeo = new THREE.TorusGeometry(R_MAIN, rBody, 32, 32, Math.PI / 2);
  const mainMesh = new THREE.Mesh(torusGeo, mat);

  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© í•¨ìˆ˜) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
    pts.push(new THREE.Vector2(0, -hBand/2));
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ì‹œì‘ì  ë°´ë“œ
  const bandStart = createChamferedBand();
  bandStart.position.set(R_MAIN, 0, 0); 
  mainMesh.add(bandStart);

  // (2) ëì  ë°´ë“œ
  const bandEnd = createChamferedBand();
  bandEnd.position.set(0, R_MAIN, 0);
  bandEnd.rotation.z = Math.PI / 2; 
  mainMesh.add(bandEnd);


  // --- 4. ìŠ¤ëƒ… í¬ì¸íŠ¸ ê³„ì‚° (ë³´ì • ì ìš©) ---
  const startSnapY = -snapOffset; // ì•„ë˜ë¡œ 4mm
  const endSnapX = -snapOffset;   // ì™¼ìª½ìœ¼ë¡œ 4mm

  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "elbow",     
      subKind: "15a",     
      stlName: "Elbow15A_Chamfer",

      snapPoints: [
        { pos: [R_MAIN, startSnapY, 0], normal: [0, -1, 0] }, 
        { pos: [endSnapX, R_MAIN, 0], normal: [-1, 0, 0] }  
      ],
      
      threadCenters: {
        port1: [R_MAIN, startSnapY, 0],
        port2: [endSnapX, R_MAIN, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìˆ˜ì •ë¨] 45ë„ ì—˜ë³´ 15A (Chamfered Band + Snap Fixed)
   - ë°´ë“œ ëª¨ë”°ê¸°(Chamfer) 1mm ì ìš© (LatheGeometry ì‚¬ìš©)
   - ìŠ¤ëƒ… í¬ì¸íŠ¸ ë³´ì •(4mm Out) ê¸°ëŠ¥ ìœ ì§€
   ================================================================= */
window.spawnProcedural45Elbow15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (15A)
  const ELBOW_RADIUS_MM = 23; 
  const BODY_DIA_MM = 27;     
  const BAND_DIA_MM = 31;     
  const BAND_HEIGHT_MM = 8;   
  
  // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm
  const chamferMm = 1;

  const R_MAIN = ELBOW_RADIUS_MM / MM_PER_UNIT; 
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;
  
  // [í•µì‹¬] ìŠ¤ëƒ… í¬ì¸íŠ¸ ë³´ì •ê°’ (ë°´ë“œ ì ˆë°˜ ë‘ê»˜)
  const snapOffset = hBand / 2;

  const ANGLE = Math.PI / 4; // 45ë„

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ (í† ëŸ¬ìŠ¤) ---
  const torusGeo = new THREE.TorusGeometry(R_MAIN, rBody, 32, 32, ANGLE);
  const mainMesh = new THREE.Mesh(torusGeo, mat);


  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© í•¨ìˆ˜) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ ê·¸ë¦¬ê¸°
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ì‹œì‘ì  ë°´ë“œ
  const bandStart = createChamferedBand();
  bandStart.position.set(R_MAIN, 0, 0); 
  // LatheëŠ” ê¸°ë³¸ Yì¶• ì •ë ¬ì´ë¯€ë¡œ í† ëŸ¬ìŠ¤ ì‹œì‘ì ì˜ ì ‘ì„ (Yì¶•)ê³¼ ì¼ì¹˜ -> íšŒì „ ë¶ˆí•„ìš”
  mainMesh.add(bandStart);

  // (2) ëì  ë°´ë“œ
  const bandEnd = createChamferedBand();
  
  const endX_center = R_MAIN * Math.cos(ANGLE);
  const endY_center = R_MAIN * Math.sin(ANGLE);
  
  bandEnd.position.set(endX_center, endY_center, 0);
  bandEnd.rotation.z = ANGLE; // 45ë„ íšŒì „
  mainMesh.add(bandEnd);


  // --- 4. ìŠ¤ëƒ… í¬ì¸íŠ¸ ê³„ì‚° (ê¸°ì¡´ ë¡œì§ ìœ ì§€ - ë°”ê¹¥ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°) ---
  
  // (1) ì‹œì‘ì 
  const startSnapX = R_MAIN;
  const startSnapY = -snapOffset; 

  // (2) ëì 
  const tanX = -Math.sin(ANGLE); 
  const tanY = Math.cos(ANGLE);  
  
  const endSnapX = endX_center + (tanX * snapOffset);
  const endSnapY = endY_center + (tanY * snapOffset);

  const nx = tanX;
  const ny = tanY;

  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "elbow45",     
      subKind: "15a",     
      stlName: "Elbow45_15A_Chamfer", // ì´ë¦„ ë³€ê²½

      snapPoints: [
        { pos: [startSnapX, startSnapY, 0], normal: [0, -1, 0] }, 
        { pos: [endSnapX, endSnapY, 0], normal: [nx, ny, 0] } 
      ],
      
      threadCenters: {
        port1: [startSnapX, startSnapY, 0],
        port2: [endSnapX, endSnapY, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 15A ì •í‹° (Tee) - Chamfer & Safe Version
   - ì¹˜ìˆ˜: ì¤‘ì‹¬~ëë‹¨ 27mm (ë³´ë‚´ì£¼ì‹  ìµœì¢… ê·œê²© ì ìš©)
   - êµ¬ì¡°: ê°€ë¡œ ëª¸í†µ(Run)ì´ ë©”ì¸, ì„¸ë¡œ(Branch)ê°€ ìì‹
   - ì—…ê·¸ë ˆì´ë“œ: ë°´ë“œ ëª¨ë”°ê¸°(1mm) + DoubleSide ì ìš©
   ================================================================= */
window.spawnProceduralTee15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (KS 15A)
  const FACE_POS_MM = 27; 
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 

  const bodyDiaMm = 27;
  const bandDiaMm = 31;
  const bandHeightMm = 8;
  const chamferMm = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  // [ì•ˆì „ì¥ì¹˜] DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide 
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„±: ê°€ë¡œ ëª¸í†µ (Run) ---
  const bandOffset = FACE_POS - (hBand / 2);
  const runLen = (bandOffset * 2) - 0.02; 
  
  const runGeo = new THREE.CylinderGeometry(rBody, rBody, runLen, 32);
  const mainMesh = new THREE.Mesh(runGeo, mat);

  // ë³¸ì²´ë¥¼ ë°”ë‹¥ì— ëˆ•í˜ (Zì¶• -90ë„ íšŒì „)
  // ê²°ê³¼: Local Yì¶• -> World Xì¶• (ì¢Œìš°)
  //      Local Xì¶• -> World Yì¶• (ìœ„ì•„ë˜)
  mainMesh.rotation.z = -Math.PI / 2;


  // --- 3. ìì‹ ë¶€í’ˆ ë¶™ì´ê¸° ---
  
  // (1) ì„¸ë¡œ ëª¸í†µ (Branch)
  const branchLen = bandOffset - 0.01;
  const branchGeo = new THREE.CylinderGeometry(rBody, rBody, branchLen, 32);
  const branchMesh = new THREE.Mesh(branchGeo, mat);
  
  // ì„¸ë¡œ ëª¸í†µì„ ë¶€ëª¨ì˜ Local Xì¶•(World Yì¶•) ë°©í–¥ìœ¼ë¡œ ëˆ•í˜
  branchMesh.rotation.z = -Math.PI / 2; // Cylinder Y -> Local X
  branchMesh.position.x = branchLen / 2; // ë¶€ëª¨ X+ ë°©í–¥ ì´ë™
  mainMesh.add(branchMesh);


  // (2) ë°´ë“œ ìƒì„± í•¨ìˆ˜ (ëª¨ë”°ê¸° ì ìš© - LatheGeometry)
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (3) ë°´ë“œ ë°°ì¹˜

  // 1. Right Band (World X+) -> Parent Local Y+
  const bandRight = createChamferedBand();
  bandRight.position.set(0, bandOffset, 0); 
  mainMesh.add(bandRight);

  // 2. Left Band (World X-) -> Parent Local Y-
  const bandLeft = createChamferedBand();
  bandLeft.position.set(0, -bandOffset, 0); 
  mainMesh.add(bandLeft);

  // 3. Top Band (World Y+) -> Parent Local X+
  const bandTop = createChamferedBand();
  // LatheëŠ” Yì¶•ìœ¼ë¡œ ì„œ ìˆìœ¼ë¯€ë¡œ, Local Xì¶•ì„ ë³´ê²Œ í•˜ë ¤ë©´ Zì¶•ìœ¼ë¡œ -90ë„ íšŒì „
  bandTop.rotation.z = -Math.PI / 2; 
  bandTop.position.set(bandOffset, 0, 0); 
  mainMesh.add(bandTop);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "tee",        
      subKind: "15a",     
      stlName: "Tee15A_Chamfer",

      // ìŠ¤ëƒ… í¬ì¸íŠ¸ (ë¶€ëª¨ ë¡œì»¬ ê¸°ì¤€)
      // MainMeshê°€ Z -90ë„ íšŒì „ë˜ì–´ ìˆìœ¼ë¯€ë¡œ:
      // Local [0, 1, 0] -> World [1, 0, 0] (Right)
      // Local [1, 0, 0] -> World [0, 1, 0] (Top)
      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Right (World X+)
        { pos: [0, -FACE_POS, 0], normal: [0, -1, 0] }, // Left (World X-)
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] }    // Top (World Y+)
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0],
        port2: [0, -FACE_POS, 0],
        port3: [FACE_POS, 0, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 15A í¬ë¡œìŠ¤ í‹° (Chamfer + Vertical)
   - ì¹˜ìˆ˜: ì¤‘ì‹¬~ëë‹¨ 27mm
   - êµ¬ì¡°: ì‹­ì(+) ëª¨ì–‘ (ì„œ ìˆìŒ)
   - ì—…ê·¸ë ˆì´ë“œ: ë°´ë“œ ëª¨ë”°ê¸°(1mm) ì ìš© (LatheGeometry)
   ================================================================= */
window.spawnProceduralCrossTee15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (KS 15A)
  const FACE_POS_MM = 27;   // ì¤‘ì‹¬ì—ì„œ ëë‹¨ê¹Œì§€ ê±°ë¦¬
  const BODY_DIA_MM = 27;   
  const BAND_DIA_MM = 31;   
  const BAND_HEIGHT_MM = 8; 
  const CHAMFER_MM = 1;     // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  // ë‹¨ìœ„ ë³€í™˜
  const facePos = FACE_POS_MM / MM_PER_UNIT;
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  const totalLen = facePos * 2;

  // [ì•ˆì „ì¥ì¹˜] DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ êµ¬ì¡° (ì‹­ì êµì°¨) ---
  
  // (1) ìˆ˜ì§ ê¸°ë‘¥ (Vertical Column) - Yì¶•
  const vGeo = new THREE.CylinderGeometry(rBody, rBody, totalLen, 32);
  const mainMesh = new THREE.Mesh(vGeo, mat);

  // (2) ìˆ˜í‰ íŒ” (Horizontal Arm) - Xì¶•
  const hGeo = new THREE.CylinderGeometry(rBody, rBody, totalLen, 32);
  hGeo.rotateZ(Math.PI / 2); // Xì¶•ìœ¼ë¡œ ëˆ•í˜
  
  const crossMesh = new THREE.Mesh(hGeo, mat);
  mainMesh.add(crossMesh);


  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© - LatheGeometry) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // ë°´ë“œ ìœ„ì¹˜ ê³„ì‚°
  const offset = facePos - (hBand / 2);

  // (1) ìœ„ìª½ (Top, Y+)
  const bandTop = createChamferedBand();
  bandTop.position.set(0, offset, 0); 
  mainMesh.add(bandTop);

  // (2) ì•„ë˜ìª½ (Bottom, Y-)
  const bandBottom = createChamferedBand();
  bandBottom.position.set(0, -offset, 0); 
  mainMesh.add(bandBottom);

  // (3) ì˜¤ë¥¸ìª½ (Right, X+)
  const bandRight = createChamferedBand();
  // LatheëŠ” Yì¶•ì´ ê¸°ë³¸ì´ë¯€ë¡œ Zì¶•ìœ¼ë¡œ -90ë„ íšŒì „í•˜ì—¬ Xì¶• ë°©í–¥ì„ ë³´ê²Œ í•¨
  bandRight.rotation.z = -Math.PI / 2; 
  bandRight.position.set(offset, 0, 0); 
  mainMesh.add(bandRight);

  // (4) ì™¼ìª½ (Left, X-)
  const bandLeft = createChamferedBand();
  bandLeft.rotation.z = Math.PI / 2; 
  bandLeft.position.set(-offset, 0, 0); 
  mainMesh.add(bandLeft);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "cross", 
      subKind: "15a",     
      stlName: "CrossTee15A_Chamfer",

      snapPoints: [
        { pos: [0, facePos, 0], normal: [0, 1, 0] },   // ìœ„
        { pos: [0, -facePos, 0], normal: [0, -1, 0] }, // ì•„ë˜
        { pos: [facePos, 0, 0], normal: [1, 0, 0] },   // ì˜¤ë¥¸ìª½
        { pos: [-facePos, 0, 0], normal: [-1, 0, 0] }  // ì™¼ìª½
      ],
      
      threadCenters: {
        port1: [0, facePos, 0],
        port2: [0, -facePos, 0],
        port3: [facePos, 0, 0],
        port4: [-facePos, 0, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ì—…ê·¸ë ˆì´ë“œ] KS 15A S.O.í‹° (Single Mesh Version)
   - êµ¬ì¡°: Group ì œê±° -> 'ê°€ë¡œ ëª¸í†µ(Run)'ì„ Main Meshë¡œ ìŠ¹ê²©
   - ìŠ¤ëƒ…: ë‹¨ì¼ ë©”ì‰¬ êµ¬ì¡° ë•ë¶„ì— ê°ë„ ìµœìƒ
   - ì¹˜ìˆ˜: isFitting: true ì„¤ì •ìœ¼ë¡œ ì „ì²´ ë°•ìŠ¤ ì¹˜ìˆ˜ í‘œì‹œ
   ================================================================= */
window.spawnProceduralSOTee15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (KS 15A í‘œì¤€)
  const FACE_POS_MM = 27; 
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 

  const bodyDiaMm = 27;    
  const bandDiaMm = 31;    
  const bandHeightMm = 8;  
  const chamferMm = 1;   
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  // ì¬ì§ˆ
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9,
    metalness: 0.0,
    flatShading: false
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„±: ê°€ë¡œ ëª¸í†µ (Run) ---
  const bandOffset = FACE_POS - (hBand / 2);
  const runLen = (bandOffset * 2) - 0.02; 
  
  // ê°€ë¡œ ëª¸í†µ (Cylinder)
  const runGeo = new THREE.CylinderGeometry(rBody, rBody, runLen, 32);
  const mainMesh = new THREE.Mesh(runGeo, mat);

  // ë³¸ì²´ë¥¼ ë°”ë‹¥ì— ëˆ•í˜ (Zì¶• -90ë„ íšŒì „ -> Local Yê°€ World Xê°€ ë¨)
  mainMesh.rotation.z = -Math.PI / 2;


  // --- 3. ìì‹ ë¶€í’ˆ ë¶™ì´ê¸° ---
  
  // (1) ì„¸ë¡œ ëª¸í†µ (Branch) -> World Z (ë’¤ìª½)
  const branchLen = bandOffset - 0.01;
  const branchMesh = new THREE.Mesh(new THREE.CylinderGeometry(rBody, rBody, branchLen, 32), mat);
  
  // ë¶€ëª¨ê°€ Zë¡œ ëˆ„ì› ìœ¼ë¯€ë¡œ, ë¶€ëª¨ì˜ Local Zì¶• = World Zì¶•
  branchMesh.rotation.x = Math.PI / 2; // Cylinder Y -> Local Z
  branchMesh.position.z = branchLen / 2; // ë’¤ë¡œ ë»—ìŒ
  mainMesh.add(branchMesh);

  // (2) ìˆ˜ì§ ëª¸í†µ (Side Outlet) -> World Y (ìœ„ìª½)
  const sideLen = bandOffset - 0.01;
  const sideMesh = new THREE.Mesh(new THREE.CylinderGeometry(rBody, rBody, sideLen, 32), mat);
  
  // ë¶€ëª¨ì˜ Local Xì¶• = World Yì¶• (ìœ„ìª½)
  sideMesh.rotation.z = -Math.PI / 2; // Cylinder Y -> Local X
  sideMesh.position.x = sideLen / 2; // ìœ„ë¡œ ë»—ìŒ
  mainMesh.add(sideMesh);


  // (3) ë (Band) ìƒì„± í•¨ìˆ˜
  function createSolidBand() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBody, -hBand/2));         
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBody, hBand/2));          
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32); 
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (4) ë  ë°°ì¹˜ (ë¶€ëª¨ ë¡œì»¬ ì¢Œí‘œê³„ ê¸°ì¤€)
  
  // 1. Right Band (World X+) -> Parent Local Y+
  const bandRight = createSolidBand();
  bandRight.position.set(0, bandOffset, 0); 
  mainMesh.add(bandRight);

  // 2. Left Band (World X-) -> Parent Local Y-
  const bandLeft = createSolidBand();
  bandLeft.position.set(0, -bandOffset, 0);
  mainMesh.add(bandLeft);

  // 3. Back Band (World Z+) -> Parent Local Z+ (ì •í‹°ì˜ ê¼¬ë¦¬)
  const bandBack = createSolidBand();
  bandBack.rotation.x = Math.PI / 2; 
  bandBack.position.set(0, 0, bandOffset);
  mainMesh.add(bandBack);

  // 4. Top Band (World Y+) -> Parent Local X+ (Side Outlet)
  const bandTop = createSolidBand();
  bandTop.rotation.z = -Math.PI / 2;
  bandTop.position.set(bandOffset, 0, 0); // ì£¼ì˜: ë¶€ëª¨ Xì¶• ë°©í–¥ì„
  mainMesh.add(bandTop);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    // ë¶€ì† ëª¨ë“œ (ë°•ìŠ¤ ì¹˜ìˆ˜)
      isPipe: false,      // íŒŒì´í”„ ì•„ë‹˜
      kind: "tee",        // ê¸°ë³¸ì€ í‹° ì„±ì§ˆ
      subKind: "s_o",     // S.O. êµ¬ë¶„
      stlName: "SOTee15A_SingleMesh",

      // ìŠ¤ëƒ… í¬ì¸íŠ¸ (ë¶€ëª¨ ë¡œì»¬ ì¢Œí‘œê³„ ê¸°ì¤€)
      // ë¶€ëª¨ Y=ê¸¸ì´(ì¢Œìš°), ë¶€ëª¨ Z=ê¹Šì´(ì „í›„), ë¶€ëª¨ X=ë†’ì´(ìƒí•˜)
      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Right (World X+)
        { pos: [0, -FACE_POS, 0], normal: [0, -1, 0] }, // Left (World X-)
        { pos: [0, 0, FACE_POS], normal: [0, 0, 1] },   // Back (World Z+)
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] }    // Top (World Y+)
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0],
        port2: [0, -FACE_POS, 0],
        port3: [0, 0, FACE_POS],
        port4: [FACE_POS, 0, 0]
      }
  };

  // ìì‹ë“¤ë„ ë³¸ì²´ ë°ì´í„° ê³µìœ 
  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ì—…ê·¸ë ˆì´ë“œ] KS 15A S.O.ì—˜ë³´ (Single Mesh Version)
   - êµ¬ì¡°: Group ì œê±° -> 'ë’¤ìª½ ëª¸í†µ(Y-Body)'ì„ Main Meshë¡œ ìŠ¹ê²©
   - ë°°ì¹˜: ê¸°ë³¸ì ìœ¼ë¡œ ë°”ë‹¥ì— ë†“ì—¬ Right(X+), Back(Z+), Top(Y+)ì„ ë°”ë¼ë´„
   - íš¨ê³¼: ìŠ¤ëƒ… ê°ë„ ìµœìƒ + ì „ì²´ í¬ê¸°(Box) ì¹˜ìˆ˜ í‘œì‹œ
   ================================================================= */
window.spawnProceduralSOElbow15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (KS 15A S.O.Elbow)
  const FACE_POS_MM = 27; // ì¤‘ì‹¬~ëë‹¨ ê±°ë¦¬
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 

  const bodyDiaMm = 27;    
  const bandDiaMm = 31;    
  const bandHeightMm = 8;  
  const chamferMm = 1;   
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  // ì¬ì§ˆ (ë¶€ë“œëŸ¬ìš´ ê³¡ë©´)
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9,
    metalness: 0.0,
    flatShading: false 
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„±: ë’¤ìª½ ëª¸í†µ (Back) ---
  // ì¤‘ì‹¬ì—ì„œ ì‹œì‘í•´ Yì¶•ìœ¼ë¡œ ë»—ëŠ” ì›í†µ
  const bandOffset = FACE_POS - (hBand / 2);
  const armLen = bandOffset; 
  
  // Yì¶• ë°©í–¥ ì›í†µ (ê¸°ë³¸)
  const yGeo = new THREE.CylinderGeometry(rBody, rBody, armLen, 32);
  // ì›ì ì„ (0,0,0)ì— ë‘ê³  Y+ ë°©í–¥ìœ¼ë¡œ ë»—ê²Œ ì´ë™
  yGeo.translate(0, armLen / 2, 0);
  
  const mainMesh = new THREE.Mesh(yGeo, mat);

  // [íšŒì „] ë³¸ì²´ë¥¼ Xì¶•ìœ¼ë¡œ -90ë„ íšŒì „
  // ê²°ê³¼: ë³¸ì²´(Yì¶•) -> World Zì¶•(Back)ì´ ë¨
  // ë³¸ì²´ì˜ Local X -> World X
  // ë³¸ì²´ì˜ Local Z -> World Y (Up)
  mainMesh.rotation.x = -Math.PI / 2;


  // --- 3. ìì‹ ë¶€í’ˆ ë¶™ì´ê¸° ---
  
  // (1) ì˜¤ë¥¸ìª½ ëª¸í†µ (Right Arm) -> World X
  // ë³¸ì²´ì˜ Local Xì¶•ê³¼ ì¼ì¹˜í•˜ë¯€ë¡œ Zì¶•ìœ¼ë¡œ -90ë„ íšŒì „ì‹œì¼œ ëˆ•í˜
  const xArm = new THREE.Mesh(yGeo.clone(), mat); // yGeo ì¬ì‚¬ìš© (ì´ë¯¸ translateë¨)
  xArm.rotation.z = -Math.PI / 2; // Y -> X
  mainMesh.add(xArm);

  // (2) ìœ„ìª½ ëª¸í†µ (Top Arm) -> World Y
  // ë³¸ì²´ì˜ Local Zì¶•ê³¼ ì¼ì¹˜í•˜ë¯€ë¡œ Xì¶•ìœ¼ë¡œ 90ë„ íšŒì „
  const zArm = new THREE.Mesh(yGeo.clone(), mat);
  zArm.rotation.x = Math.PI / 2; // Y -> Z
  mainMesh.add(zArm);

  // (3) ì¤‘ì‹¬ë¶€ êµ¬ì²´ (Center Sphere)
  const centerGeo = new THREE.SphereGeometry(rBody, 32, 32);
  const centerMesh = new THREE.Mesh(centerGeo, mat);
  mainMesh.add(centerMesh);


  // (4) ë (Band) ìƒì„± í•¨ìˆ˜
  function createSolidBand() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBody, -hBand/2));         
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBody, hBand/2));          
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32); 
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (5) ë  ë°°ì¹˜ (ë³¸ì²´ ë¡œì»¬ ì¢Œí‘œê³„ ê¸°ì¤€)
  
  // 1. Back Band (World Z+) -> Parent Local Y+
  const bandBack = createSolidBand();
  bandBack.position.set(0, bandOffset, 0); 
  mainMesh.add(bandBack);

  // 2. Right Band (World X+) -> Parent Local X+
  const bandRight = createSolidBand();
  bandRight.rotation.z = -Math.PI / 2; 
  bandRight.position.set(bandOffset, 0, 0); 
  mainMesh.add(bandRight);

  // 3. Top Band (World Y+) -> Parent Local Z+
  const bandTop = createSolidBand();
  bandTop.rotation.x = Math.PI / 2; 
  bandTop.position.set(0, 0, bandOffset);
  mainMesh.add(bandTop);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    // ë¶€ì† ëª¨ë“œ (ë°•ìŠ¤ ì¹˜ìˆ˜)
      isPipe: false,      // íŒŒì´í”„ ì•„ë‹˜
      kind: "elbow",      
      subKind: "s_o",     // S.O. êµ¬ë¶„
      stlName: "SOElbow15A_SingleMesh",

      // ìŠ¤ëƒ… í¬ì¸íŠ¸ (ë¶€ëª¨ ë¡œì»¬ ì¢Œí‘œê³„ ê¸°ì¤€)
      // Parent Y=Back(Z), Parent X=Right(X), Parent Z=Top(Y)
      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Back (World Z+)
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] },   // Right (World X+)
        { pos: [0, 0, FACE_POS], normal: [0, 0, 1] }    // Top (World Y+)
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0], // Back
        port2: [FACE_POS, 0, 0], // Right
        port3: [0, 0, FACE_POS]  // Top
      }
  };

  // ìì‹ë“¤ë„ ë³¸ì²´ ë°ì´í„° ê³µìœ 
  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 15A í”Œëœì§€ (Chamfered Version)
   - ì¹˜ìˆ˜: ì‚¬ìš©ì ì œê³µ ìµœì¢…ê°’ (OD 77, Thk 7.9, Hub 35/7, PCD 60)
   - ì—…ê·¸ë ˆì´ë“œ: ì›íŒ ë° í—ˆë¸Œì— ëª¨ë”°ê¸°(1mm) ì ìš©
   - êµ¬ì¡°: LatheGeometry ì‚¬ìš© (íšŒì „ì²´)
   ================================================================= */
window.spawnProceduralFlange15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì •
  const FLANGE_OD_MM = 77;      
  const FLANGE_THK_MM = 7.9;    
  const HUB_OD_MM = 35;         
  const HUB_LEN_MM = 7;         
  const BOLT_BCD_MM = 60;    
  const HOLE_DIA_MM = 5;
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm
  
  // ë‹¨ìœ„ ë³€í™˜
  const rFlange = (FLANGE_OD_MM / 2) / MM_PER_UNIT;
  const hDisk = FLANGE_THK_MM / MM_PER_UNIT;
  const rHub = (HUB_OD_MM / 2) / MM_PER_UNIT;
  const hHub = HUB_LEN_MM / MM_PER_UNIT;
  const rBolt = (BOLT_BCD_MM / 2) / MM_PER_UNIT;
  const rHole = (HOLE_DIA_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });
  
  const matBolt = new THREE.MeshStandardMaterial({
    color: 0x222222, 
    roughness: 1.0 
  });

  // --- 2. ë³¸ì²´(Main Mesh): ì›íŒ(Disk) - ëª¨ë”°ê¸° ì ìš© ---
  // LatheGeometryë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ—ë©´ ëª¨ì„œë¦¬ë¥¼ ê¹ìŒ
  function createChamferedDisk() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ (ì¤‘ì‹¬ -> ì˜¤ë¥¸ìª½ -> ìœ„ -> ì¤‘ì‹¬)
    // 1. ë°”ë‹¥ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, -hDisk/2));
    // 2. ë°”ë‹¥ ì˜¤ë¥¸ìª½ ë
    pts.push(new THREE.Vector2(rFlange, -hDisk/2));
    // 3. ìœ„ìª½ ì˜¤ë¥¸ìª½ ë (ëª¨ë”°ê¸° ì‹œì‘ì )
    pts.push(new THREE.Vector2(rFlange, hDisk/2 - hChamfer));
    // 4. ìœ„ìª½ ì•ˆìª½ (ëª¨ë”°ê¸° ëì )
    pts.push(new THREE.Vector2(rFlange - hChamfer, hDisk/2));
    // 5. ìœ„ìª½ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, hDisk/2));

    const geo = new THREE.LatheGeometry(pts, 64); // ì›íŒì€ ë‘¥ê¸€ê²Œ(64)
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  const mainMesh = createChamferedDisk();


  // --- 3. ìì‹ ë¶€í’ˆ ë¶™ì´ê¸° ---

  // (1) í—ˆë¸Œ (Hub) - ëª¨ë”°ê¸° ì ìš©
  function createChamferedHub() {
    const pts = [];
    // í—ˆë¸Œë„ ìœ—ë©´ ëª¨ì„œë¦¬ë¥¼ ê¹ìŒ
    pts.push(new THREE.Vector2(0, -hHub/2));
    pts.push(new THREE.Vector2(rHub, -hHub/2));
    pts.push(new THREE.Vector2(rHub, hHub/2 - hChamfer));
    pts.push(new THREE.Vector2(rHub - hChamfer, hHub/2));
    pts.push(new THREE.Vector2(0, hHub/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  const hubMesh = createChamferedHub();
  // ìœ„ì¹˜: ì›íŒ ìœ„ìª½(Y+)ìœ¼ë¡œ ì´ë™
  hubMesh.position.set(0, (hDisk/2 + hHub/2), 0);
  mainMesh.add(hubMesh);


  // (2) ë³¼íŠ¸ êµ¬ë© (4ê°œ) - Cylinder ìœ ì§€
  const boltGeo = new THREE.CylinderGeometry(rHole, rHole, hDisk + 0.002, 16);

  for(let i=0; i<4; i++) {
      const angle = (Math.PI / 2) * i;
      const bx = Math.cos(angle) * rBolt;
      const bz = Math.sin(angle) * rBolt;
      
      const bolt = new THREE.Mesh(boltGeo, matBolt);
      bolt.position.set(bx, 0, bz); 
      mainMesh.add(bolt);
  }

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "flange",     
      subKind: "15a",     
      stlName: "Flange15A_Chamfer",

      snapPoints: [
        { 
            // ë°”ë‹¥ (Y-)
            pos: [0, -hDisk/2, 0], 
            normal: [0, -1, 0] 
        },
        { 
            // ìœ„ (í—ˆë¸Œ ë, Y+)
            pos: [0, (hDisk/2 + hHub), 0], 
            normal: [0, 1, 0] 
        }
      ],
      
      threadCenters: {
        port1: [0, -hDisk/2, 0],
        port2: [0, (hDisk/2 + hHub), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ì™„ì„±] KS ë ˆë“€ì„œ 20A x 15A (Chamfered)
   - êµ¬ì¡°: í•˜ë‹¨ 20A(ë„“ìŒ) -> ìƒë‹¨ 15A(ì¢ìŒ)
   - ì—…ê·¸ë ˆì´ë“œ: ìƒ/í•˜ë‹¨ ë°´ë“œ ëª¨ë”°ê¸°(1mm) ì ìš©
   - ì¬ì§ˆ: DoubleSide (êµ¬ë© ë°©ì§€)
   ================================================================= */
window.spawnProceduralReducer20A15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (ë†’ì´ 38.8mm)
  const HEIGHT_MM = 38.8;       
  const BAND_HEIGHT_MM = 10;    
  const OD_20A_MM = 39;         
  const BODY_20A_MM = 34;       
  const OD_15A_MM = 31;         
  const BODY_15A_MM = 28;       
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  // ì‹œìŠ¤í…œ í˜¸í™˜ìš©
  const SYSTEM_PIPE_OD_20A = 27.2; 

  // ë‹¨ìœ„ ë³€í™˜
  const hTotal = HEIGHT_MM / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  const r20Band = (OD_20A_MM / 2) / MM_PER_UNIT;
  const r15Band = (OD_15A_MM / 2) / MM_PER_UNIT;
  const r20Body = (BODY_20A_MM / 2) / MM_PER_UNIT;
  const r15Body = (BODY_15A_MM / 2) / MM_PER_UNIT;

  // [ì•ˆì „ì¥ì¹˜] DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´(Main Mesh): ëª¸í†µ (Tapered) ---
  const hBody = hTotal - (2 * hBand);
  
  // ìœ„ìª½ 15A(ì¢ìŒ), ì•„ë˜ìª½ 20A(ë„“ìŒ)
  const bodyGeo = new THREE.CylinderGeometry(r15Body, r20Body, hBody, 32);
  const mainMesh = new THREE.Mesh(bodyGeo, mat);


  // --- 3. ìì‹ ë¶€í’ˆ(Band) - ëª¨ë”°ê¸° ì ìš© ---
  
  // (ê³µí†µ í•¨ìˆ˜) ë°˜ì§€ë¦„ì„ ë°›ì•„ ëª¨ë”°ê¸° ë°´ë“œ ìƒì„±
  function createChamferedBand(radius) {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(radius - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(radius, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(radius, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(radius - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ìƒë‹¨ ë°´ë“œ (15A, r15Band) - ìœ„ìª½
  const band15 = createChamferedBand(r15Band);
  const band15Y = (hBody / 2) + (hBand / 2);
  band15.position.set(0, band15Y, 0);
  mainMesh.add(band15);

  // (2) í•˜ë‹¨ ë°´ë“œ (20A, r20Band) - ì•„ë˜ìª½
  const band20 = createChamferedBand(r20Band);
  const band20Y = -((hBody / 2) + (hBand / 2));
  band20.position.set(0, band20Y, 0);
  mainMesh.add(band20);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "reducer",    
      subKind: "20a",     
      
      od: SYSTEM_PIPE_OD_20A, 
      stlName: "Reducer20x15_Chamfer",

      snapPoints: [
          // í•˜ë‹¨ (20A ìª½) - ì•„ë˜ ë°©í–¥
          { pos: [0, -hTotal/2, 0], normal: [0, -1, 0] },
          
          // ìƒë‹¨ (15A ìª½) - ìœ„ ë°©í–¥
          { pos: [0, hTotal/2, 0],  normal: [0, 1, 0] }
      ],
      
      threadCenters: {
          port1: [0, -hTotal/2, 0],
          port2: [0, hTotal/2, 0]
      }
  };

  mainMesh.children.forEach(c => c.userData = Object.assign({}, mainMesh.userData));

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ìˆ˜ì •] KS 15A ìœ ë‹ˆì˜¨ (Octagon + Chamfer)
   - ëª¨ì„œë¦¬ ê¹ì„(Chamfer) ì ìš©
   - ë°©ì‹: LatheGeometry(8ë¶„í• ) ì‚¬ìš©
   ================================================================= */
window.spawnProceduralUnion15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const TOTAL_LEN_MM = 44; 
  const HEX_CENTER_LEN_MM = 16; 
  const HEX_CENTER_W_MM = 44;   
  const HEX_END_W_MM = 30;      
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  const totalLen = TOTAL_LEN_MM / MM_PER_UNIT;
  const hCenter = HEX_CENTER_LEN_MM / MM_PER_UNIT;
  const rCenter = (HEX_CENTER_W_MM / 2) / MM_PER_UNIT;
  const rEnd = (HEX_END_W_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  const hEnd = (totalLen - hCenter) / 2;
  const halfLen = totalLen / 2;

  const matHex = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: true, // ê°ì§„ ëŠë‚Œ
    side: THREE.DoubleSide
  });

  // --- ë‹¤ê°í˜• ìƒì„± í•¨ìˆ˜ (Lathe ì‚¬ìš©) ---
  function createChamferedPoly(radius, height, segments) {
    const pts = [];
    // ë‹¨ë©´ ê·¸ë¦¬ê¸° (ì•„ë˜ -> ìœ„)
    pts.push(new THREE.Vector2(0, -height/2));
    pts.push(new THREE.Vector2(radius - hChamfer, -height/2)); // ë°”ë‹¥ ëª¨ë”°ê¸° ì‹œì‘
    pts.push(new THREE.Vector2(radius, -height/2 + hChamfer)); // ë°”ë‹¥ ëª¨ë”°ê¸° ë
    pts.push(new THREE.Vector2(radius, height/2 - hChamfer));  // ìœ„ ëª¨ë”°ê¸° ì‹œì‘
    pts.push(new THREE.Vector2(radius - hChamfer, height/2));  // ìœ„ ëª¨ë”°ê¸° ë
    pts.push(new THREE.Vector2(0, height/2));

    const geo = new THREE.LatheGeometry(pts, segments);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHex);
  }

  // --- 2. ë³¸ì²´ (ê°€ìš´ë° í° 8ê°) ---
  const mainMesh = createChamferedPoly(rCenter, hCenter, 8); // 8ê°
  
  // 8ê° ì •ë©´ ì •ë ¬ (PI/8 íšŒì „)
  mainMesh.rotation.y = Math.PI / 8;

  // --- 3. ìì‹ (ì–‘ìª½ ì‘ì€ 8ê°) ---
  const offset = (hCenter / 2) + (hEnd / 2);

  // (1) ìœ„ìª½
  const hexTop = createChamferedPoly(rEnd, hEnd, 8);
  // LatheëŠ” ì´ë¯¸ Yì¶• ì •ë ¬ë¨. ìœ„ì¹˜ë§Œ ì´ë™. 
  // ìì‹ë„ íšŒì „(PI/8)ì´ í•„ìš”í•˜ì§€ë§Œ, ë¶€ëª¨ê°€ ì´ë¯¸ ëŒì•˜ìœ¼ë¯€ë¡œ ê·¸ëŒ€ë¡œ ë‘ 
  // (ë¶€ëª¨ì˜ íšŒì „ì´ ìì‹ì—ê²Œ ìƒì†ë¨ -> ë¶€ëª¨: 22.5ë„, ìì‹: 0ë„ ì¶”ê°€ = 22.5ë„)
  hexTop.position.set(0, offset, 0); 
  mainMesh.add(hexTop);

  // (2) ì•„ë˜ìª½
  const hexBottom = createChamferedPoly(rEnd, hEnd, 8);
  hexBottom.position.set(0, -offset, 0); 
  mainMesh.add(hexBottom);


  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "union",     
      subKind: "15a",     
      stlName: "Union15A_Chamfer",

      snapPoints: [
        { pos: [0, halfLen, 0], normal: [0, 1, 0] },   
        { pos: [0, -halfLen, 0], normal: [0, -1, 0] }  
      ],
      
      threadCenters: {
        port1: [0, halfLen, 0],
        port2: [0, -halfLen, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ì—…ê·¸ë ˆì´ë“œ] KS 15A í”ŒëŸ¬ê·¸ (Chamfered Square)
   - ë¨¸ë¦¬: ì‚¬ê°(4ê°) + ëª¨ë”°ê¸° ì ìš©
   - ë‚˜ì‚¬ì‚°: í…Œì´í¼ ì›í†µ (ê¸°ì¡´ ìœ ì§€)
   ================================================================= */
window.spawnProceduralPlug15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const HEAD_HEIGHT_MM = 10;    
  const HEAD_WIDTH_MM = 14;     
  const THREAD_LEN_MM = 2;     // *ê¸¸ì´ ìˆ˜ì • (ê¸°ì¡´ ì½”ë“œ 2mmëŠ” ë„ˆë¬´ ì§§ì•„ 22mmë¡œ ì¶”ì •/ë³µì›)
  const THREAD_TOP_MM = 22;     
  const THREAD_BOT_MM = 20;     
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const hHead = HEAD_HEIGHT_MM / MM_PER_UNIT;
  const wHead = HEAD_WIDTH_MM / MM_PER_UNIT; 
  const hThread = THREAD_LEN_MM / MM_PER_UNIT;
  const rThreadTop = (THREAD_TOP_MM / 2) / MM_PER_UNIT;
  const rThreadBot = (THREAD_BOT_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  const rHead = (HEAD_WIDTH_MM / 2) / MM_PER_UNIT; // ë°˜ì§€ë¦„ ë³€í™˜

  const matBody = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false
  });
  const matHead = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: true,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´: ë‚˜ì‚¬ì‚° (Thread) ---
  const threadGeo = new THREE.CylinderGeometry(rThreadTop, rThreadBot, hThread, 32);
  const mainMesh = new THREE.Mesh(threadGeo, matBody);


  // --- 3. ìì‹: ì‚¬ê° ë¨¸ë¦¬ (Square Head + Chamfer) ---
  // 4ë¶„í•  Lathe ì‚¬ìš© -> ì‚¬ê°ê¸°ë‘¥ ëª¨ë”°ê¸° íš¨ê³¼
  function createChamferedSquare() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHead/2));
    pts.push(new THREE.Vector2(rHead, -hHead/2)); // ë°”ë‹¥ì€ í‰í‰í•˜ê²Œ
    pts.push(new THREE.Vector2(rHead, hHead/2 - hChamfer)); // ìœ„ìª½ ëª¨ë”°ê¸° ì‹œì‘
    pts.push(new THREE.Vector2(rHead - hChamfer, hHead/2)); // ìœ„ìª½ ì•ˆìª½
    pts.push(new THREE.Vector2(0, hHead/2));

    const geo = new THREE.LatheGeometry(pts, 4); // 4ê° (Square)
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHead);
  }

  const headMesh = createChamferedSquare();
  
  // ì‚¬ê° ì •ë ¬ (45ë„ íšŒì „)
  headMesh.rotation.y = Math.PI / 4; 
  
  // ìœ„ì¹˜ ì´ë™
  headMesh.position.y = (hThread / 2) + (hHead / 2);
  
  mainMesh.add(headMesh);


  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "plug",     
      subKind: "15a",     
      stlName: "Plug15A_Chamfer",

      snapPoints: [
        { 
            pos: [0, -hThread/2, 0], 
            normal: [0, -1, 0] 
        }
      ],
      
      threadCenters: {
        port1: [0, -hThread/2, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ì—…ê·¸ë ˆì´ë“œ] KS ë¶€ì‹± 20A x 15A (Hex Chamfer)
   - ë¨¸ë¦¬: ìœ¡ê°(6ê°) + ëª¨ë”°ê¸° ì ìš©
   - ëª¸í†µ: ì›í˜• + ìœ—ë©´ ëª¨ë”°ê¸° ì ìš©
   ================================================================= */
window.spawnProceduralBushing20A15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const HEX_WIDTH_MM = 39;      
  const HEX_HEIGHT_MM = 5;      
  const CYL_OD_MM = 27.2;       
  const CYL_HEIGHT_MM = 5;      
  const TOTAL_HEIGHT_MM = 10;   
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const rHex = (HEX_WIDTH_MM / 2) / MM_PER_UNIT;
  const hHex = HEX_HEIGHT_MM / MM_PER_UNIT;
  const rCyl = (CYL_OD_MM / 2) / MM_PER_UNIT;
  const hCyl = CYL_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const matHex = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: true 
  });
  const matCyl = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false 
  });

  // --- 2. ë³¸ì²´: ìœ¡ê° ë¨¸ë¦¬ (Hex Head) ---
  function createChamferedHex() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHex/2));
    pts.push(new THREE.Vector2(rHex - hChamfer, -hHex/2)); // ë°”ë‹¥ ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rHex, -hHex/2 + hChamfer));
    pts.push(new THREE.Vector2(rHex, hHex/2 - hChamfer));  // ìœ„ ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rHex - hChamfer, hHex/2));
    pts.push(new THREE.Vector2(0, hHex/2));

    const geo = new THREE.LatheGeometry(pts, 6); // 6ê°
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHex);
  }

  const mainMesh = createChamferedHex();
  // ì •ë©´ ì •ë ¬ (PI/6 = 30ë„)
  mainMesh.rotation.y = Math.PI / 6; 


  // --- 3. ìì‹: ìƒë‹¨ ì›í†µ (Round Body) ---
  function createChamferedCyl() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hCyl/2));
    pts.push(new THREE.Vector2(rCyl, -hCyl/2));
    pts.push(new THREE.Vector2(rCyl, hCyl/2 - hChamfer)); // ìœ—ë©´ ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rCyl - hChamfer, hCyl/2));
    pts.push(new THREE.Vector2(0, hCyl/2));

    const geo = new THREE.LatheGeometry(pts, 32); // ì›í˜•
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matCyl);
  }

  const cylMesh = createChamferedCyl();
  const yOffset = (hHex / 2) + (hCyl / 2);
  cylMesh.position.set(0, yOffset, 0);
  
  mainMesh.add(cylMesh);


  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "bushing",    
      subKind: "20a",     
      stlName: "Bushing20x15_Chamfer",

      snapPoints: [
          { pos: [0, -hHex/2, 0], normal: [0, -1, 0] },
          { pos: [0, (hHex/2 + hCyl), 0], normal: [0, 1, 0] }
      ],
      
      threadCenters: {
          port1: [0, -hHex/2, 0],
          port2: [0, (hHex/2 + hCyl), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ìˆ˜ì •] ìº¡ 15A (Round Chamfered)
   - ë””ìì¸: ì „ì²´ ë‘¥ê·¼ ì›í˜•
   - ì—…ê·¸ë ˆì´ë“œ: ë¨¸ë¦¬ ë° ëª¸í†µ ëª¨ì„œë¦¬ ëª¨ë”°ê¸° ì ìš©
   ================================================================= */
window.spawnProceduralCap15A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const CAP_OD_MM = 30;         
  const TOTAL_HEIGHT_MM = 20;   
  const HEAD_H_MM = 8;          
  const BODY_H_MM = 12;         
  const BODY_OD_MM = 30;        
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const rHead = (CAP_OD_MM / 2) / MM_PER_UNIT;
  const hHead = HEAD_H_MM / MM_PER_UNIT;
  const rBody = (BODY_OD_MM / 2) / MM_PER_UNIT;
  const hBody = BODY_H_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const matRound = new THREE.MeshStandardMaterial({
      color: 0x444444, 
      roughness: 0.9,      
      metalness: 0.0, 
      flatShading: false,
      side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´: ì›í˜• ë¨¸ë¦¬ (Chamfered Head) ---
  function createChamferedHead() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHead/2));
    pts.push(new THREE.Vector2(rHead, -hHead/2));
    pts.push(new THREE.Vector2(rHead, hHead/2 - hChamfer)); // ìœ—ë©´ ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rHead - hChamfer, hHead/2));
    pts.push(new THREE.Vector2(0, hHead/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matRound);
  }

  const mainMesh = createChamferedHead();


  // --- 3. ìì‹: ì›í˜• ëª¸í†µ (Chamfered Body) ---
  function createChamferedBody() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBody/2));
    pts.push(new THREE.Vector2(rBody - hChamfer, -hBody/2)); // ì•„ë«ë©´ ëª¨ë”°ê¸° (ì§„ì…ë¶€)
    pts.push(new THREE.Vector2(rBody, -hBody/2 + hChamfer));
    pts.push(new THREE.Vector2(rBody, hBody/2));
    pts.push(new THREE.Vector2(0, hBody/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matRound);
  }

  const bodyMesh = createChamferedBody();
  const yOffset = -((hHead / 2) + (hBody / 2));
  bodyMesh.position.set(0, yOffset, 0);
  
  mainMesh.add(bodyMesh);


  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "cap",        
      subKind: "15a",     
      stlName: "Cap15A_Chamfer",

      snapPoints: [
        { 
            pos: [0, -(hHead/2 + hBody), 0], 
            normal: [0, -1, 0] 
        }
      ],
      threadCenters: {
        port1: [0, -(hHead/2 + hBody), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};





/* =================================================================
   [ìˆ˜ì •ë¨] KS 20A ì†Œì¼“ (Chamfered Version)
   - ëª¨ë”°ê¸°(Chamfer): 1mm ì ìš©
   - ë°©ì‹: ë°´ë“œ ë¶€ë¶„ì„ LatheGeometry(íšŒì „ì²´)ë¡œ ë³€ê²½í•˜ì—¬ ëª¨ì„œë¦¬ ê°€ê³µ
   - êµ¬ì¡°: ìˆ˜ì§(Vertical), DoubleSide ì¬ì§ˆ ìœ ì§€
   ================================================================= */
window.spawnProceduralSocket20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A)
  const TOTAL_LEN_MM = 40; 
  const HALF_LEN = (TOTAL_LEN_MM / 2) / MM_PER_UNIT; 

  const bodyDiaMm = 34;    
  const bandDiaMm = 39;    
  const bandHeightMm = 9;  
  const chamferMm = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  // [ì•ˆì „ì¥ì¹˜] side: THREE.DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„± ---
  const bodyLen = (TOTAL_LEN_MM - (bandHeightMm * 2)) / MM_PER_UNIT; 
  const bodyGeo = new THREE.CylinderGeometry(rBody, rBody, bodyLen, 32);
  
  const mainMesh = new THREE.Mesh(bodyGeo, mat);
  
  // Yì¶• ë°©í–¥(ìœ„)ìœ¼ë¡œ ì„œ ìˆìŒ

  // --- 3. ìì‹ ë¶€í’ˆ(Band) ë¶™ì´ê¸° - ëª¨ë”°ê¸° ì ìš© ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ ê·¸ë¦¬ê¸°
    // 1. ë°”ë‹¥ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, -hBand/2));
    // 2. ë°”ë‹¥ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2));
    // 3. ë°”ë‹¥ ì¸¡ë©´ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer));
    // 4. ìœ„ìª½ ì¸¡ë©´ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));
    // 5. ìœ„ìª½ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));
    // 6. ìœ„ìª½ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, hBand/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals(); // ë¶€ë“œëŸ¬ìš´ ê³¡ë©´ ì²˜ë¦¬
    return new THREE.Mesh(geo, mat);
  }
  
  const bandOffset = (bodyLen / 2) + (hBand / 2);

  // (1) ìœ„ìª½ ë°´ë“œ
  const bandTop = createChamferedBand();
  bandTop.position.set(0, bandOffset, 0); 
  mainMesh.add(bandTop);

  // (2) ì•„ë˜ìª½ ë°´ë“œ
  const bandBottom = createChamferedBand();
  bandBottom.position.set(0, -bandOffset, 0); 
  mainMesh.add(bandBottom);

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "socket",     
      subKind: "20a",     
      stlName: "Socket20A_Chamfer",

      snapPoints: [
        { pos: [0, HALF_LEN, 0], normal: [0, 1, 0] },  // ìœ„
        { pos: [0, -HALF_LEN, 0], normal: [0, -1, 0] } // ì•„ë˜
      ],
      
      threadCenters: {
        port1: [0, HALF_LEN, 0],
        port2: [0, -HALF_LEN, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìˆ˜ì •ë¨] 90ë„ ì—˜ë³´ 20A (Chamfered + Snap Fixed)
   - ë°´ë“œ ëª¨ë”°ê¸°(Chamfer) 1mm ì ìš© (LatheGeometry ì‚¬ìš©)
   - ìŠ¤ëƒ… í¬ì¸íŠ¸ ë³´ì •(4.5mm Out) ê¸°ëŠ¥ ìœ ì§€
   ================================================================= */
window.spawnProceduralElbow20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A)
  const ELBOW_RADIUS_MM = 27; 
  const BODY_DIA_MM = 34;     
  const BAND_DIA_MM = 39;     
  const BAND_HEIGHT_MM = 9;   
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  const R_MAIN = ELBOW_RADIUS_MM / MM_PER_UNIT; 
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  // ìŠ¤ëƒ… ë³´ì •ê°’
  const snapOffset = hBand / 2; // 4.5mm

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ (í† ëŸ¬ìŠ¤) ---
  const torusGeo = new THREE.TorusGeometry(R_MAIN, rBody, 32, 32, Math.PI / 2);
  const mainMesh = new THREE.Mesh(torusGeo, mat);


  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© í•¨ìˆ˜) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ ê·¸ë¦¬ê¸°
    // 1. ë°”ë‹¥ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, -hBand/2));
    // 2. ë°”ë‹¥ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2));
    // 3. ë°”ë‹¥ ì¸¡ë©´ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer));
    // 4. ìœ„ìª½ ì¸¡ë©´ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));
    // 5. ìœ„ìª½ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));
    // 6. ìœ„ìª½ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, hBand/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ì‹œì‘ì  ë°´ë“œ
  const bandStart = createChamferedBand();
  bandStart.position.set(R_MAIN, 0, 0); 
  // í† ëŸ¬ìŠ¤ ì‹œì‘ì ì˜ ì ‘ì„ ì´ Yì¶•ì´ë¯€ë¡œ íšŒì „ ë¶ˆí•„ìš” (LatheëŠ” Yì¶• ì •ë ¬)
  mainMesh.add(bandStart);

  // (2) ëì  ë°´ë“œ
  const bandEnd = createChamferedBand();
  bandEnd.position.set(0, R_MAIN, 0);
  bandEnd.rotation.z = Math.PI / 2; // Xì¶• ë°©í–¥ìœ¼ë¡œ ëˆ•í˜
  mainMesh.add(bandEnd);


  // --- 4. ìŠ¤ëƒ… í¬ì¸íŠ¸ ê³„ì‚° (ê¸°ì¡´ ìœ ì§€) ---
  const startSnapY = -snapOffset;
  const endSnapX = -snapOffset;

  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "elbow",     
      subKind: "20a",     
      stlName: "Elbow20A_Chamfer",

      snapPoints: [
        { pos: [R_MAIN, startSnapY, 0], normal: [0, -1, 0] }, 
        { pos: [endSnapX, R_MAIN, 0], normal: [-1, 0, 0] }  
      ],
      
      threadCenters: {
        port1: [R_MAIN, startSnapY, 0],
        port2: [endSnapX, R_MAIN, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ìˆ˜ì •ë¨] 45ë„ ì—˜ë³´ 20A (Chamfered + Snap Fixed)
   - ë°´ë“œ ëª¨ë”°ê¸°(Chamfer) 1mm ì ìš© (LatheGeometry ì‚¬ìš©)
   - ìŠ¤ëƒ… í¬ì¸íŠ¸ ë³´ì •(4.5mm Out) ê¸°ëŠ¥ ìœ ì§€
   ================================================================= */
window.spawnProcedural45Elbow20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A)
  const ELBOW_RADIUS_MM = 27; 
  const BODY_DIA_MM = 34;     
  const BAND_DIA_MM = 39;     
  const BAND_HEIGHT_MM = 9;   
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  const R_MAIN = ELBOW_RADIUS_MM / MM_PER_UNIT; 
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  // ìŠ¤ëƒ… ë³´ì •ê°’ (ë°´ë“œ ì ˆë°˜ ë‘ê»˜)
  const snapOffset = hBand / 2; // 4.5mm

  const ANGLE = Math.PI / 4; // 45ë„

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ (í† ëŸ¬ìŠ¤) ---
  const torusGeo = new THREE.TorusGeometry(R_MAIN, rBody, 32, 32, ANGLE);
  const mainMesh = new THREE.Mesh(torusGeo, mat);


  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© í•¨ìˆ˜) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ ê·¸ë¦¬ê¸°
    // 1. ë°”ë‹¥ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, -hBand/2));
    // 2. ë°”ë‹¥ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2));
    // 3. ë°”ë‹¥ ì¸¡ë©´ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer));
    // 4. ìœ„ìª½ ì¸¡ë©´ (ëª¨ë”°ê¸° ì‹œì‘)
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));
    // 5. ìœ„ìª½ ëª¨ì„œë¦¬ (ëª¨ë”°ê¸° ë)
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));
    // 6. ìœ„ìª½ ì¤‘ì‹¬
    pts.push(new THREE.Vector2(0, hBand/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ì‹œì‘ì  ë°´ë“œ
  const bandStart = createChamferedBand();
  bandStart.position.set(R_MAIN, 0, 0); 
  // LatheëŠ” Yì¶• ì •ë ¬ì´ë¯€ë¡œ í† ëŸ¬ìŠ¤ ì‹œì‘ì ì˜ ì ‘ì„ (Yì¶•)ê³¼ ì¼ì¹˜ -> íšŒì „ ë¶ˆí•„ìš”
  mainMesh.add(bandStart);

  // (2) ëì  ë°´ë“œ
  const bandEnd = createChamferedBand();
  
  const endX_center = R_MAIN * Math.cos(ANGLE);
  const endY_center = R_MAIN * Math.sin(ANGLE);
  
  bandEnd.position.set(endX_center, endY_center, 0);
  bandEnd.rotation.z = ANGLE; // 45ë„ íšŒì „
  mainMesh.add(bandEnd);


  // --- 4. ìŠ¤ëƒ… í¬ì¸íŠ¸ ê³„ì‚° (ê¸°ì¡´ ìœ ì§€) ---
  const startSnapX = R_MAIN;
  const startSnapY = -snapOffset; 

  const tanX = -Math.sin(ANGLE); 
  const tanY = Math.cos(ANGLE);  
  
  const endSnapX = endX_center + (tanX * snapOffset);
  const endSnapY = endY_center + (tanY * snapOffset);

  const nx = tanX;
  const ny = tanY;

  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "elbow45",     
      subKind: "20a",     
      stlName: "Elbow45_20A_Chamfer",

      snapPoints: [
        { pos: [startSnapX, startSnapY, 0], normal: [0, -1, 0] }, 
        { pos: [endSnapX, endSnapY, 0], normal: [nx, ny, 0] } 
      ],
      
      threadCenters: {
        port1: [startSnapX, startSnapY, 0],
        port2: [endSnapX, endSnapY, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 20A ì •í‹° (Chamfered Version)
   - ê·œê²©: ì¤‘ì‹¬~ëë‹¨ 32mm (20A)
   - ì—…ê·¸ë ˆì´ë“œ: ë°´ë“œ ëª¨ë”°ê¸°(1mm) ì ìš© (LatheGeometry)
   - ì¬ì§ˆ: DoubleSide (êµ¬ë© ë°©ì§€)
   ================================================================= */
window.spawnProceduralTee20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© (20A)
  const FACE_POS_MM = 32; 
  const BODY_DIA_MM = 34;
  const BAND_DIA_MM = 39;
  const BAND_HEIGHT_MM = 9;
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  // ë‹¨ìœ„ ë³€í™˜
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  // [ì•ˆì „ì¥ì¹˜] DoubleSide
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´(Main Mesh) ìƒì„±: ê°€ë¡œ ëª¸í†µ (Run) ---
  const bandOffset = FACE_POS - (hBand / 2);
  const runLen = (bandOffset * 2) - 0.02; 
  
  const runGeo = new THREE.CylinderGeometry(rBody, rBody, runLen, 32);
  const mainMesh = new THREE.Mesh(runGeo, mat);
  
  // ë³¸ì²´ë¥¼ ë°”ë‹¥ì— ëˆ•í˜ (Zì¶• -90ë„ -> Xì¶• ë°©í–¥ ì •ë ¬)
  mainMesh.rotation.z = -Math.PI / 2;

  // --- 3. ìì‹ ë¶€í’ˆ ë¶™ì´ê¸° ---
  
  // (1) ì„¸ë¡œ ëª¸í†µ (Branch)
  const branchLen = bandOffset - 0.01;
  const branchGeo = new THREE.CylinderGeometry(rBody, rBody, branchLen, 32);
  const branchMesh = new THREE.Mesh(branchGeo, mat);
  
  // ì„¸ë¡œ ëª¸í†µ íšŒì „ (ë¶€ëª¨ Xì¶• ë°©í–¥ìœ¼ë¡œ ëˆ•í˜)
  branchMesh.rotation.z = -Math.PI / 2; 
  branchMesh.position.x = branchLen / 2; 
  mainMesh.add(branchMesh);

  // (2) ë°´ë“œ ìƒì„± í•¨ìˆ˜ (ëª¨ë”°ê¸° ì ìš© - LatheGeometry)
  function createChamferedBand() { 
      const pts = [];
      // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
      pts.push(new THREE.Vector2(0, -hBand/2));             
      pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
      pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
      pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
      pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
      pts.push(new THREE.Vector2(0, hBand/2));              

      const geo = new THREE.LatheGeometry(pts, 32);
      geo.computeVertexNormals();
      return new THREE.Mesh(geo, mat);
  }

  // (3) ë°´ë“œ ë°°ì¹˜

  // Right Band (World X+) -> Parent Y+
  const bandRight = createChamferedBand();
  bandRight.position.set(0, bandOffset, 0); 
  mainMesh.add(bandRight);

  // Left Band (World X-) -> Parent Y-
  const bandLeft = createChamferedBand();
  bandLeft.position.set(0, -bandOffset, 0); 
  mainMesh.add(bandLeft);

  // Top Band (World Y+) -> Parent X+
  const bandTop = createChamferedBand();
  // LatheëŠ” Yì¶• ì •ë ¬ì´ë¯€ë¡œ, Xì¶• ë°©í–¥ì„ ë³´ê²Œ í•˜ë ¤ë©´ Zì¶•ìœ¼ë¡œ -90ë„ íšŒì „
  bandTop.rotation.z = -Math.PI / 2; 
  bandTop.position.set(bandOffset, 0, 0); 
  mainMesh.add(bandTop);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "tee",        
      subKind: "20a",     
      stlName: "Tee20A_Chamfer",

      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Right
        { pos: [0, -FACE_POS, 0], normal: [0, -1, 0] }, // Left
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] }    // Top
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0],
        port2: [0, -FACE_POS, 0],
        port3: [FACE_POS, 0, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 20A í¬ë¡œìŠ¤ í‹° (Chamfered Version)
   - ì¹˜ìˆ˜: ì¤‘ì‹¬~ëë‹¨ 32mm (20A ìµœì¢…)
   - êµ¬ì¡°: ì‹­ì(+) ëª¨ì–‘ (ì„œ ìˆìŒ)
   - ì—…ê·¸ë ˆì´ë“œ: ë°´ë“œ ëª¨ë”°ê¸°(1mm) ì ìš© (LatheGeometry)
   ================================================================= */
window.spawnProceduralCrossTee20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A ìµœì¢…)
  const FACE_POS_MM = 32;   // ì¤‘ì‹¬ì—ì„œ ëë‹¨ê¹Œì§€ ê±°ë¦¬
  const BODY_DIA_MM = 34;   
  const BAND_DIA_MM = 39;   
  const BAND_HEIGHT_MM = 9; 
  const CHAMFER_MM = 1;     // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm

  // ë‹¨ìœ„ ë³€í™˜
  const facePos = FACE_POS_MM / MM_PER_UNIT;
  const rBody = (BODY_DIA_MM / 2) / MM_PER_UNIT;
  const rBand = (BAND_DIA_MM / 2) / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  // ì „ì²´ ê¸¸ì´ (ì¤‘ì‹¬~ë * 2)
  const totalLen = facePos * 2;

  // [ì•ˆì „ì¥ì¹˜] ì–‘ë©´ ë Œë”ë§
  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´ êµ¬ì¡° (ì‹­ì êµì°¨) ---
  
  // (1) ìˆ˜ì§ ê¸°ë‘¥ (Vertical Column) - Yì¶•
  const vGeo = new THREE.CylinderGeometry(rBody, rBody, totalLen, 32);
  const mainMesh = new THREE.Mesh(vGeo, mat);

  // (2) ìˆ˜í‰ íŒ” (Horizontal Arm) - Xì¶•
  const hGeo = new THREE.CylinderGeometry(rBody, rBody, totalLen, 32);
  // Zì¶•ìœ¼ë¡œ 90ë„ íšŒì „ -> Xì¶•(ì¢Œìš°)ìœ¼ë¡œ ëˆ•í˜
  hGeo.rotateZ(Math.PI / 2); 
  
  const crossMesh = new THREE.Mesh(hGeo, mat);
  mainMesh.add(crossMesh);


  // --- 3. ë°´ë“œ ìƒì„± (ëª¨ë”°ê¸° ì ìš© - LatheGeometry) ---
  function createChamferedBand() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBand - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBand - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // ë°´ë“œ ìœ„ì¹˜ ê³„ì‚°
  const offset = facePos - (hBand / 2);

  // (1) ìœ„ìª½ (Top, Y+)
  const bandTop = createChamferedBand();
  bandTop.position.set(0, offset, 0); 
  mainMesh.add(bandTop);

  // (2) ì•„ë˜ìª½ (Bottom, Y-)
  const bandBottom = createChamferedBand();
  bandBottom.position.set(0, -offset, 0); 
  mainMesh.add(bandBottom);

  // (3) ì˜¤ë¥¸ìª½ (Right, X+)
  const bandRight = createChamferedBand();
  // LatheëŠ” Yì¶•ì´ ê¸°ë³¸ì´ë¯€ë¡œ Zì¶•ìœ¼ë¡œ -90ë„ íšŒì „í•˜ì—¬ Xì¶• ë°©í–¥ì„ ë³´ê²Œ í•¨
  bandRight.rotation.z = -Math.PI / 2; 
  bandRight.position.set(offset, 0, 0); 
  mainMesh.add(bandRight);

  // (4) ì™¼ìª½ (Left, X-)
  const bandLeft = createChamferedBand();
  bandLeft.rotation.z = Math.PI / 2; 
  bandLeft.position.set(-offset, 0, 0); 
  mainMesh.add(bandLeft);


  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "cross", 
      subKind: "20a",     
      stlName: "CrossTee20A_Chamfer",

      snapPoints: [
        { pos: [0, facePos, 0], normal: [0, 1, 0] },   // ìœ„
        { pos: [0, -facePos, 0], normal: [0, -1, 0] }, // ì•„ë˜
        { pos: [facePos, 0, 0], normal: [1, 0, 0] },   // ì˜¤ë¥¸ìª½
        { pos: [-facePos, 0, 0], normal: [-1, 0, 0] }  // ì™¼ìª½
      ],
      
      threadCenters: {
        port1: [0, facePos, 0],
        port2: [0, -facePos, 0],
        port3: [facePos, 0, 0],
        port4: [-facePos, 0, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [20A] S.O.í‹° (Single Mesh Version)
   - ê·œê²©: ì¤‘ì‹¬~ëë‹¨ 32mm (20A)
   ================================================================= */
window.spawnProceduralSOTee20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A)
  const FACE_POS_MM = 32; 
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 

  const bodyDiaMm = 34;    
  const bandDiaMm = 39;    
  const bandHeightMm = 9;  
  const chamferMm = 1;   
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false
  });

  // --- 2. ë³¸ì²´(Main Mesh) ---
  const bandOffset = FACE_POS - (hBand / 2);
  const runLen = (bandOffset * 2) - 0.02; 
  
  const runGeo = new THREE.CylinderGeometry(rBody, rBody, runLen, 32);
  const mainMesh = new THREE.Mesh(runGeo, mat);

  mainMesh.rotation.z = -Math.PI / 2;

  // --- 3. ìì‹ ë¶€í’ˆ ---
  // (1) ì„¸ë¡œ ëª¸í†µ (Branch) -> World Z
  const branchLen = bandOffset - 0.01;
  const branchMesh = new THREE.Mesh(new THREE.CylinderGeometry(rBody, rBody, branchLen, 32), mat);
  branchMesh.rotation.x = Math.PI / 2; 
  branchMesh.position.z = branchLen / 2; 
  mainMesh.add(branchMesh);

  // (2) ìˆ˜ì§ ëª¸í†µ (Side Outlet) -> World Y
  const sideLen = bandOffset - 0.01;
  const sideMesh = new THREE.Mesh(new THREE.CylinderGeometry(rBody, rBody, sideLen, 32), mat);
  sideMesh.rotation.z = -Math.PI / 2; 
  sideMesh.position.x = sideLen / 2; 
  mainMesh.add(sideMesh);

  // (3) ë°´ë“œ ìƒì„±
  function createSolidBand() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBody, -hBand/2));         
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBody, hBand/2));          
    pts.push(new THREE.Vector2(0, hBand/2));              
    const geo = new THREE.LatheGeometry(pts, 32); 
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (4) ë°´ë“œ ë°°ì¹˜
  const bandRight = createSolidBand();
  bandRight.position.set(0, bandOffset, 0); 
  mainMesh.add(bandRight);

  const bandLeft = createSolidBand();
  bandLeft.position.set(0, -bandOffset, 0);
  mainMesh.add(bandLeft);

  const bandBack = createSolidBand();
  bandBack.rotation.x = Math.PI / 2; 
  bandBack.position.set(0, 0, bandOffset);
  mainMesh.add(bandBack);

  const bandTop = createSolidBand();
  bandTop.rotation.z = -Math.PI / 2;
  bandTop.position.set(bandOffset, 0, 0); 
  mainMesh.add(bandTop);

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "tee",        
      subKind: "20a",     // S.O. êµ¬ë¶„ì„ ìœ„í•´ ì´ë¦„ ìœ ì§€í•˜ë˜ 20a ëª…ì‹œ
      stlName: "SOTee20A_SingleMesh",

      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Right
        { pos: [0, -FACE_POS, 0], normal: [0, -1, 0] }, // Left
        { pos: [0, 0, FACE_POS], normal: [0, 0, 1] },   // Back
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] }    // Top
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0],
        port2: [0, -FACE_POS, 0],
        port3: [0, 0, FACE_POS],
        port4: [FACE_POS, 0, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [20A] S.O.ì—˜ë³´ (Single Mesh Version)
   - ê·œê²©: ì¤‘ì‹¬~ëë‹¨ 32mm (20A)
   ================================================================= */
window.spawnProceduralSOElbow20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì • (20A)
  const FACE_POS_MM = 31.5; 
  const FACE_POS = FACE_POS_MM / MM_PER_UNIT; 

  const bodyDiaMm = 34;    
  const bandDiaMm = 39;    
  const bandHeightMm = 9;  
  const chamferMm = 1;   
  
  const rBody = (bodyDiaMm / 2) / MM_PER_UNIT;
  const rBand = (bandDiaMm / 2) / MM_PER_UNIT;
  const hBand = bandHeightMm / MM_PER_UNIT;
  const hChamfer = chamferMm / MM_PER_UNIT;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false 
  });

  // --- 2. ë³¸ì²´(Main Mesh) ---
  const bandOffset = FACE_POS - (hBand / 2);
  const armLen = bandOffset; 
  
  const yGeo = new THREE.CylinderGeometry(rBody, rBody, armLen, 32);
  yGeo.translate(0, armLen / 2, 0);
  
  const mainMesh = new THREE.Mesh(yGeo, mat);
  mainMesh.rotation.x = -Math.PI / 2;

  // --- 3. ìì‹ ë¶€í’ˆ ---
  // (1) ì˜¤ë¥¸ìª½ ëª¸í†µ
  const xArm = new THREE.Mesh(yGeo.clone(), mat); 
  xArm.rotation.z = -Math.PI / 2; 
  mainMesh.add(xArm);

  // (2) ìœ„ìª½ ëª¸í†µ
  const zArm = new THREE.Mesh(yGeo.clone(), mat);
  zArm.rotation.x = Math.PI / 2; 
  mainMesh.add(zArm);

  // (3) ì¤‘ì‹¬ë¶€ êµ¬ì²´
  const centerGeo = new THREE.SphereGeometry(rBody, 32, 32);
  const centerMesh = new THREE.Mesh(centerGeo, mat);
  mainMesh.add(centerMesh);

  // (4) ë°´ë“œ ìƒì„±
  function createSolidBand() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(rBody, -hBand/2));         
    pts.push(new THREE.Vector2(rBand, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(rBand, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(rBody, hBand/2));          
    pts.push(new THREE.Vector2(0, hBand/2));              
    const geo = new THREE.LatheGeometry(pts, 32); 
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (5) ë°´ë“œ ë°°ì¹˜
  const bandBack = createSolidBand();
  bandBack.position.set(0, bandOffset, 0); 
  mainMesh.add(bandBack);

  const bandRight = createSolidBand();
  bandRight.rotation.z = -Math.PI / 2; 
  bandRight.position.set(bandOffset, 0, 0); 
  mainMesh.add(bandRight);

  const bandTop = createSolidBand();
  bandTop.rotation.x = Math.PI / 2; 
  bandTop.position.set(0, 0, bandOffset);
  mainMesh.add(bandTop);

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "elbow",      
      subKind: "s_o_20a", // êµ¬ë¶„ìš©
      stlName: "SOElbow20A_SingleMesh",

      snapPoints: [
        { pos: [0, FACE_POS, 0], normal: [0, 1, 0] },   // Back (Z+)
        { pos: [FACE_POS, 0, 0], normal: [1, 0, 0] },   // Right (X+)
        { pos: [0, 0, FACE_POS], normal: [0, 0, 1] }    // Top (Y+)
      ],
      
      threadCenters: {
        port1: [0, FACE_POS, 0], 
        port2: [FACE_POS, 0, 0], 
        port3: [0, 0, FACE_POS]  
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  // --- 5. ë°°ì¹˜ ---
  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);

  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;

  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [ìµœì¢… ì™„ì„±] KS 20A í”Œëœì§€ (Chamfered Version)
   - ê·œê²©: KS 10K 20A (OD 100, Thk 14)
   - ì—…ê·¸ë ˆì´ë“œ: ì›íŒ ë° í—ˆë¸Œ ëª¨ë”°ê¸°(1mm) ì ìš©
   ================================================================= */
window.spawnProceduralFlange20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì •
  const FLANGE_OD_MM = 100;      
  const FLANGE_THK_MM = 14;      
  const HUB_OD_MM = 42;          
  const HUB_LEN_MM = 10;         
  const BOLT_BCD_MM = 75;        
  const HOLE_DIA_MM = 15;        
  const CHAMFER_MM = 1; // [ì¶”ê°€] ëª¨ë”°ê¸° 1mm
  
  const rFlange = (FLANGE_OD_MM / 2) / MM_PER_UNIT;
  const hDisk = FLANGE_THK_MM / MM_PER_UNIT;
  const rHub = (HUB_OD_MM / 2) / MM_PER_UNIT;
  const hHub = HUB_LEN_MM / MM_PER_UNIT;
  const rBolt = (BOLT_BCD_MM / 2) / MM_PER_UNIT;
  const rHole = (HOLE_DIA_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, 
    roughness: 0.9, 
    metalness: 0.0, 
    flatShading: false,
    side: THREE.DoubleSide
  });
  
  const matBolt = new THREE.MeshStandardMaterial({
    color: 0x222222, 
    roughness: 1.0 
  });

  // --- 2. ë³¸ì²´: ì›íŒ (Chamfered Disk) ---
  function createChamferedDisk() {
    const pts = [];
    // ë°˜ì‹œê³„ ë°©í–¥ ë‹¨ë©´ (ì¤‘ì‹¬ -> ì˜¤ë¥¸ìª½ ë°”ë‹¥ -> ì˜¤ë¥¸ìª½ ìœ„(ëª¨ë”°ê¸°) -> ì¤‘ì‹¬)
    pts.push(new THREE.Vector2(0, -hDisk/2));
    pts.push(new THREE.Vector2(rFlange, -hDisk/2));
    pts.push(new THREE.Vector2(rFlange, hDisk/2 - hChamfer)); // ëª¨ë”°ê¸° ì‹œì‘
    pts.push(new THREE.Vector2(rFlange - hChamfer, hDisk/2)); // ëª¨ë”°ê¸° ë
    pts.push(new THREE.Vector2(0, hDisk/2));

    const geo = new THREE.LatheGeometry(pts, 64);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  const mainMesh = createChamferedDisk();


  // --- 3. ìì‹ ë¶€í’ˆ ---

  // (1) í—ˆë¸Œ (Chamfered Hub)
  function createChamferedHub() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHub/2));
    pts.push(new THREE.Vector2(rHub, -hHub/2));
    pts.push(new THREE.Vector2(rHub, hHub/2 - hChamfer)); // ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rHub - hChamfer, hHub/2));
    pts.push(new THREE.Vector2(0, hHub/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  const hubMesh = createChamferedHub();
  hubMesh.position.set(0, (hDisk/2 + hHub/2), 0);
  mainMesh.add(hubMesh);

  // (2) ë³¼íŠ¸ êµ¬ë© (4ê°œ)
  const boltGeo = new THREE.CylinderGeometry(rHole, rHole, hDisk + 0.002, 16);
  for(let i=0; i<4; i++) {
      const angle = (Math.PI / 2) * i;
      const bx = Math.cos(angle) * rBolt;
      const bz = Math.sin(angle) * rBolt;
      
      const bolt = new THREE.Mesh(boltGeo, matBolt);
      bolt.position.set(bx, 0, bz); 
      mainMesh.add(bolt);
  }

  // --- 4. ì†ì„± ì„¤ì • ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "flange",     
      subKind: "20a",     
      stlName: "Flange20A_Chamfer",

      snapPoints: [
        { pos: [0, -hDisk/2, 0], normal: [0, -1, 0] },
        { pos: [0, (hDisk/2 + hHub), 0], normal: [0, 1, 0] }
      ],
      threadCenters: {
        port1: [0, -hDisk/2, 0],
        port2: [0, (hDisk/2 + hHub), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [25A] ë ˆë“€ì„œ 25A x 20A (Chamfered)
   - ê·œê²©: ë†’ì´ 48mm
   - ì—…ê·¸ë ˆì´ë“œ: ìƒ/í•˜ë‹¨ ë°´ë“œ ëª¨ë”°ê¸°(1mm) ì ìš©
   ================================================================= */
window.spawnProceduralReducer25A20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²© ì„¤ì •
  const HEIGHT_MM = 48;         
  const BAND_HEIGHT_MM = 11;    
  const OD_25A_MM = 48;         
  const BODY_25A_MM = 42;       
  const OD_20A_MM = 39;         
  const BODY_20A_MM = 34;       
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const hTotal = HEIGHT_MM / MM_PER_UNIT;
  const hBand = BAND_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  const r25Band = (OD_25A_MM / 2) / MM_PER_UNIT;
  const r25Body = (BODY_25A_MM / 2) / MM_PER_UNIT;
  const r20Band = (OD_20A_MM / 2) / MM_PER_UNIT;
  const r20Body = (BODY_20A_MM / 2) / MM_PER_UNIT;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false, side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´: ëª¸í†µ (Tapered Cylinder) ---
  const hBody = hTotal - (2 * hBand);
  const bodyGeo = new THREE.CylinderGeometry(r20Body, r25Body, hBody, 32);
  const mainMesh = new THREE.Mesh(bodyGeo, mat);


  // --- 3. ìì‹: ë°´ë“œ (Chamfered) ---
  function createChamferedBand(radius) {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBand/2));             
    pts.push(new THREE.Vector2(radius - hChamfer, -hBand/2)); 
    pts.push(new THREE.Vector2(radius, -hBand/2 + hChamfer)); 
    pts.push(new THREE.Vector2(radius, hBand/2 - hChamfer));  
    pts.push(new THREE.Vector2(radius - hChamfer, hBand/2));  
    pts.push(new THREE.Vector2(0, hBand/2));              

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, mat);
  }

  // (1) ìƒë‹¨ ë°´ë“œ (20A)
  const band20 = createChamferedBand(r20Band);
  const band20Y = (hBody / 2) + (hBand / 2);
  band20.position.set(0, band20Y, 0);
  mainMesh.add(band20);

  // (2) í•˜ë‹¨ ë°´ë“œ (25A)
  const band25 = createChamferedBand(r25Band);
  const band25Y = -((hBody / 2) + (hBand / 2));
  band25.position.set(0, band25Y, 0);
  mainMesh.add(band25);

  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "reducer",    
      subKind: "25a_20a", 
      stlName: "Reducer25x20_Chamfer",

      snapPoints: [
          { pos: [0, -hTotal/2, 0], normal: [0, -1, 0] },
          { pos: [0, hTotal/2, 0],  normal: [0, 1, 0] }
      ],
      threadCenters: {
          port1: [0, -hTotal/2, 0],
          port2: [0, hTotal/2, 0]
      }
  };

  mainMesh.children.forEach(c => c.userData = Object.assign({}, mainMesh.userData));

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [ìµœì¢… ìˆ˜ì •] KS 20A ìœ ë‹ˆì˜¨ (Octagon + Chamfer)
   - 8ê°(Octagon) í˜•íƒœ
   - ìœ—ë©´/ì•„ë«ë©´ ëª¨ë”°ê¸° ì ìš©
   ================================================================= */
window.spawnProceduralUnion20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const TOTAL_LEN_MM = 46;      
  const HEX_CENTER_LEN_MM = 16; 
  const HEX_CENTER_W_MM = 50;   
  const HEX_END_W_MM = 39;      
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const totalLen = TOTAL_LEN_MM / MM_PER_UNIT;
  const hCenter = HEX_CENTER_LEN_MM / MM_PER_UNIT;
  const rCenter = (HEX_CENTER_W_MM / 2) / MM_PER_UNIT;
  const rEnd = (HEX_END_W_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  const hEnd = (totalLen - hCenter) / 2;
  const halfLen = totalLen / 2;

  const matHex = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: true, side: THREE.DoubleSide
  });

  // --- Helper: Chamfered 8-gon ---
  function createChamferedPoly(radius, height) {
    const pts = [];
    pts.push(new THREE.Vector2(0, -height/2));
    pts.push(new THREE.Vector2(radius - hChamfer, -height/2));
    pts.push(new THREE.Vector2(radius, -height/2 + hChamfer));
    pts.push(new THREE.Vector2(radius, height/2 - hChamfer));
    pts.push(new THREE.Vector2(radius - hChamfer, height/2));
    pts.push(new THREE.Vector2(0, height/2));

    const geo = new THREE.LatheGeometry(pts, 8); // 8ê°
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHex);
  }

  // --- 2. ë³¸ì²´ (8ê°) ---
  const mainMesh = createChamferedPoly(rCenter, hCenter);
  mainMesh.rotation.y = Math.PI / 8; // ì •ë ¬

  // --- 3. ìì‹ (8ê°) ---
  const offset = (hCenter / 2) + (hEnd / 2);

  // Top
  const hexTop = createChamferedPoly(rEnd, hEnd);
  hexTop.position.set(0, offset, 0); 
  mainMesh.add(hexTop);

  // Bottom
  const hexBottom = createChamferedPoly(rEnd, hEnd);
  hexBottom.position.set(0, -offset, 0); 
  mainMesh.add(hexBottom);

  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "union",     
      subKind: "20a",     
      stlName: "Union20A_Chamfer",

      snapPoints: [
        { pos: [0, halfLen, 0], normal: [0, 1, 0] },   
        { pos: [0, -halfLen, 0], normal: [0, -1, 0] }  
      ],
      threadCenters: {
        port1: [0, halfLen, 0],
        port2: [0, -halfLen, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* =================================================================
   [20A] í”ŒëŸ¬ê·¸ (Chamfered Square)
   - ë¨¸ë¦¬: ì‚¬ê°(4ê°) + ëª¨ë”°ê¸° ì ìš©
   ================================================================= */
window.spawnProceduralPlug20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. 20A ê·œê²©
  const HEAD_HEIGHT_MM = 12;    
  const HEAD_WIDTH_MM = 17;     
  const THREAD_LEN_MM = 2;      
  const THREAD_TOP_MM = 27;     
  const THREAD_BOT_MM = 25;     
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const hHead = HEAD_HEIGHT_MM / MM_PER_UNIT;
  const wHead = HEAD_WIDTH_MM / MM_PER_UNIT; // í­
  const hThread = THREAD_LEN_MM / MM_PER_UNIT;
  const rThreadTop = (THREAD_TOP_MM / 2) / MM_PER_UNIT;
  const rThreadBot = (THREAD_BOT_MM / 2) / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;
  
  // BoxGeometryì˜ widthëŠ” ì§€ë¦„ì´ ì•„ë‹ˆë¯€ë¡œ, Latheì—ì„œ radiusëŠ” width/2
  const rHead = (HEAD_WIDTH_MM / 2) / MM_PER_UNIT;

  const matBody = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false
  });
  const matHead = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: true, side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´: ë‚˜ì‚¬ì‚° ---
  const threadGeo = new THREE.CylinderGeometry(rThreadTop, rThreadBot, hThread, 32);
  const mainMesh = new THREE.Mesh(threadGeo, matBody);

  // --- 3. ìì‹: ì‚¬ê° ë¨¸ë¦¬ (Chamfered) ---
  function createChamferedSquare() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHead/2));
    pts.push(new THREE.Vector2(rHead, -hHead/2));
    pts.push(new THREE.Vector2(rHead, hHead/2 - hChamfer)); // ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rHead - hChamfer, hHead/2));
    pts.push(new THREE.Vector2(0, hHead/2));

    const geo = new THREE.LatheGeometry(pts, 4); // 4ê°
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHead);
  }

  const headMesh = createChamferedSquare();
  headMesh.rotation.y = Math.PI / 4; // ì‚¬ê° ì •ë ¬
  headMesh.position.y = (hThread / 2) + (hHead / 2);
  mainMesh.add(headMesh);

  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "plug",       
      subKind: "20a",     
      stlName: "Plug20A_Chamfer",

      snapPoints: [
        { pos: [0, -hThread/2, 0], normal: [0, -1, 0] }
      ],
      threadCenters: {
        port1: [0, -hThread/2, 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [25A] ë¶€ì‹± 25A x 20A (Chamfered)
   - ìœ¡ê° ë¨¸ë¦¬(6ê°) + ì›í†µ ëª¸í†µ ëª¨ë”°ê¸° ì ìš©
   ================================================================= */
window.spawnProceduralBushing25A20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. ê·œê²©
  const HEX_WIDTH_MM = 46;      
  const HEX_HEIGHT_MM = 6;      
  const CYL_OD_MM = 34;         
  const CYL_HEIGHT_MM = 6;      
  const TOTAL_HEIGHT_MM = 12;   
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const rHex = (HEX_WIDTH_MM / 2) / MM_PER_UNIT;
  const hHex = HEX_HEIGHT_MM / MM_PER_UNIT;
  const rCyl = (CYL_OD_MM / 2) / MM_PER_UNIT;
  const hCyl = CYL_HEIGHT_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const matHex = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: true, side: THREE.DoubleSide
  });
  const matCyl = new THREE.MeshStandardMaterial({
    color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false, side: THREE.DoubleSide
  });

  // --- 2. ë³¸ì²´: ìœ¡ê° ë¨¸ë¦¬ (Chamfered 6-gon) ---
  function createChamferedHex() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHex/2));
    pts.push(new THREE.Vector2(rHex - hChamfer, -hHex/2));
    pts.push(new THREE.Vector2(rHex, -hHex/2 + hChamfer));
    pts.push(new THREE.Vector2(rHex, hHex/2 - hChamfer));
    pts.push(new THREE.Vector2(rHex - hChamfer, hHex/2));
    pts.push(new THREE.Vector2(0, hHex/2));

    const geo = new THREE.LatheGeometry(pts, 6); // 6ê°
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matHex);
  }

  const mainMesh = createChamferedHex();
  mainMesh.rotation.y = Math.PI / 6;

  // --- 3. ìì‹: ìƒë‹¨ ì›í†µ (Chamfered Cyl) ---
  function createChamferedCyl() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hCyl/2));
    pts.push(new THREE.Vector2(rCyl, -hCyl/2));
    pts.push(new THREE.Vector2(rCyl, hCyl/2 - hChamfer)); // ìœ—ë©´ ëª¨ë”°ê¸°
    pts.push(new THREE.Vector2(rCyl - hChamfer, hCyl/2));
    pts.push(new THREE.Vector2(0, hCyl/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matCyl);
  }

  const cylMesh = createChamferedCyl();
  const yOffset = (hHex / 2) + (hCyl / 2);
  cylMesh.position.set(0, yOffset, 0);
  mainMesh.add(cylMesh);

  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "bushing",    
      subKind: "25a_20a", 
      stlName: "Bushing25x20_Chamfer",

      snapPoints: [
          { pos: [0, -hHex/2, 0], normal: [0, -1, 0] },
          { pos: [0, (hHex/2 + hCyl), 0], normal: [0, 1, 0] }
      ],
      threadCenters: {
          port1: [0, -hHex/2, 0],
          port2: [0, (hHex/2 + hCyl), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};




/* =================================================================
   [20A] ìº¡ (Chamfered Round)
   - ê·œê²©: ì§€ë¦„ 38mm, ë†’ì´ 25mm
   - ì—…ê·¸ë ˆì´ë“œ: ë¨¸ë¦¬ ë° ëª¸í†µ ëª¨ë”°ê¸°(1mm) ì ìš©
   ================================================================= */
window.spawnProceduralCap20A = function() {
  saveState(); 

  const MM_PER_UNIT = 100;

  // 1. 20A ê·œê²©
  const CAP_OD_MM = 38;         
  const TOTAL_HEIGHT_MM = 25;   
  const HEAD_H_MM = 10;         
  const BODY_H_MM = 15;         
  const BODY_OD_MM = 38;        
  const CHAMFER_MM = 1; // [ì¶”ê°€]

  const rHead = (CAP_OD_MM / 2) / MM_PER_UNIT;
  const hHead = HEAD_H_MM / MM_PER_UNIT;
  const rBody = (BODY_OD_MM / 2) / MM_PER_UNIT;
  const hBody = BODY_H_MM / MM_PER_UNIT;
  const hChamfer = CHAMFER_MM / MM_PER_UNIT;

  const matRound = new THREE.MeshStandardMaterial({
      color: 0x444444, roughness: 0.9, metalness: 0.0, flatShading: false, side: THREE.DoubleSide 
  });

  // --- 2. ë³¸ì²´: ë¨¸ë¦¬ (Chamfered Head) ---
  function createChamferedHead() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hHead/2));
    pts.push(new THREE.Vector2(rHead, -hHead/2));
    pts.push(new THREE.Vector2(rHead, hHead/2 - hChamfer));
    pts.push(new THREE.Vector2(rHead - hChamfer, hHead/2));
    pts.push(new THREE.Vector2(0, hHead/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matRound);
  }

  const mainMesh = createChamferedHead();

  // --- 3. ìì‹: ëª¸í†µ (Chamfered Body) ---
  function createChamferedBody() {
    const pts = [];
    pts.push(new THREE.Vector2(0, -hBody/2));
    pts.push(new THREE.Vector2(rBody - hChamfer, -hBody/2));
    pts.push(new THREE.Vector2(rBody, -hBody/2 + hChamfer));
    pts.push(new THREE.Vector2(rBody, hBody/2));
    pts.push(new THREE.Vector2(0, hBody/2));

    const geo = new THREE.LatheGeometry(pts, 32);
    geo.computeVertexNormals();
    return new THREE.Mesh(geo, matRound);
  }

  const bodyMesh = createChamferedBody();
  const yOffset = -((hHead / 2) + (hBody / 2));
  bodyMesh.position.set(0, yOffset, 0);
  mainMesh.add(bodyMesh);

  // --- 4. ì†ì„± ---
  mainMesh.userData = {
      isFitting: true,    
      isPipe: false,      
      kind: "cap",        
      subKind: "20a",     
      stlName: "Cap20A_Chamfer",

      snapPoints: [
        { pos: [0, -(hHead/2 + hBody), 0], normal: [0, -1, 0] }
      ],
      threadCenters: {
        port1: [0, -(hHead/2 + hBody), 0]
      }
  };

  mainMesh.children.forEach(child => {
      child.userData = Object.assign({}, mainMesh.userData);
  });

  placeOnGround(mainMesh);
  scene.add(mainMesh);
  draggable.push(mainMesh);
  clearAllSelection();
  selectedSet.add(mainMesh);
  markSelected(mainMesh);
  selectedMesh = mainMesh;
  if (typeof updatePortVisuals === "function") updatePortVisuals(mainMesh);
  updateRotationGizmo();
};



/* ========== mm íë¸Œ ë¶€ì† ìƒì„± (All Chamfer / ëª¨ë“  ë©´ ëª¨ë”°ê¸°) ========== */
function addMmCubeFitting(sizeMm) {
  saveState();

  const mm = parseFloat(sizeMm);
  if (!mm || mm <= 0) return;

  const MM_PER_UNIT = 100;
  const unit = mm / MM_PER_UNIT;
  
  // ëª¨ë”°ê¸° í¬ê¸° (1mm)
  const chamfer = 0.2 / MM_PER_UNIT;

  // â”€â”€ Geometry: "ì´ì¤‘ ëª¨ë”°ê¸°" ê¸°ë²• ì ìš© â”€â”€
  // 1. 2D ëª¨ì–‘ì„ 'íŒ”ê°í˜•(ëª¨ì„œë¦¬ê°€ ê¹ì¸ ì‚¬ê°í˜•)'ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤. (ì˜†ë©´ 4ê°œ ëª¨ë”°ê¸° íš¨ê³¼)
  // 2. Extrude ì„¤ì •ì—ì„œ 'bevel'ì„ ì¼­ë‹ˆë‹¤. (ì•/ë’¤ 8ê°œ ëª¨ì„œë¦¬ ëª¨ë”°ê¸° íš¨ê³¼)
  // ê²°ê³¼ì ìœ¼ë¡œ 12ê°œ ëª¨ì„œë¦¬ê°€ ëª¨ë‘ ê¹ì¸ ì£¼ì‚¬ìœ„ ëª¨ì–‘ì´ ë©ë‹ˆë‹¤.

  // ë² ë²¨ì´ ì¶”ê°€ë  ê²ƒì„ ê³ ë ¤í•˜ì—¬ ê¸°ë³¸ í¬ê¸°ë¥¼ ì¤„ì„
  // (ì „ì²´í¬ê¸° - ëª¨ë”°ê¸°*2)
  const baseSize = unit - (chamfer * 2); 
  const half = baseSize / 2;

  const shape = new THREE.Shape();
  
  // [íŒ”ê°í˜• ê·¸ë¦¬ê¸°]
  // ì™¼ìª½ ì•„ë˜ë¶€í„° ì‹œê³„ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ê·¸ë¦¼
  shape.moveTo(-half, -half + chamfer);       // 1. ì¢Œì¸¡ í•˜ë‹¨ (ìœ„)
  shape.lineTo(-half + chamfer, -half);       // 2. ì¢Œì¸¡ í•˜ë‹¨ (ìš°)
  shape.lineTo( half - chamfer, -half);       // 3. ìš°ì¸¡ í•˜ë‹¨ (ì¢Œ)
  shape.lineTo( half, -half + chamfer);       // 4. ìš°ì¸¡ í•˜ë‹¨ (ìœ„)
  shape.lineTo( half,  half - chamfer);       // 5. ìš°ì¸¡ ìƒë‹¨ (ì•„ë˜)
  shape.lineTo( half - chamfer,  half);       // 6. ìš°ì¸¡ ìƒë‹¨ (ì¢Œ)
  shape.lineTo(-half + chamfer,  half);       // 7. ì¢Œì¸¡ ìƒë‹¨ (ìš°)
  shape.lineTo(-half,  half - chamfer);       // 8. ì¢Œì¸¡ ìƒë‹¨ (ì•„ë˜)
  shape.lineTo(-half, -half + chamfer);       // ë‹«ê¸°

  const extrudeSettings = {
    depth: baseSize,        // ê¹Šì´ (Zì¶• ë°©í–¥, ë² ë²¨ ì œì™¸ ê¸¸ì´)
    bevelEnabled: true,     // ë² ë²¨ ì¼œê¸°
    bevelThickness: chamfer,// ì•/ë’¤ ë°©í–¥ ëª¨ë”°ê¸° ë‘ê»˜
    bevelSize: chamfer,     // ì˜† ë°©í–¥ í™•ì¥ í¬ê¸°
    bevelSegments: 1,       // [ì¤‘ìš”] 1 = í‰í‰í•˜ê²Œ ê¹ìŒ (Chamfer)
    steps: 1
  };

  const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  
  // ì¤‘ì‹¬ ì •ë ¬
  geo.center(); 

  // â”€â”€ Material â”€â”€
  const mat = new THREE.MeshStandardMaterial({
    color: 0xbfc3c7,      
    roughness: 0.25,      
    metalness: 0.25,      
    emissive: 0x111111,   
    emissiveIntensity: 0.35,
    flatShading: true     // ê°ì§„ ë©´ì´ ì˜ ë³´ì´ë„ë¡ ì„¤ì •
  });

  const cube = new THREE.Mesh(geo, mat);

  // â”€â”€ Position â”€â”€
  cube.position.set(0, unit / 2, 0);

  // â”€â”€ userData â”€â”€
  cube.userData.isFitting = true;
  cube.userData.type = "mmCube";
  cube.userData.sizeMm = mm;

  // â”€â”€ Snap Points â”€â”€
  // ì‹¤ì œ unit í¬ê¸° ê¸°ì¤€
  const snapHalf = unit / 2;
  cube.userData.snapPoints = [
    { pos: [ snapHalf, 0, 0], normal: [ 1, 0, 0] }, // +X
    { pos: [-snapHalf, 0, 0], normal: [-1, 0, 0] }, // -X
    { pos: [0,  snapHalf, 0], normal: [0,  1, 0] }, // +Y
    { pos: [0, -snapHalf, 0], normal: [0, -1, 0] }, // -Y
    { pos: [0, 0,  snapHalf], normal: [0, 0,  1] }, // +Z
    { pos: [0, 0, -snapHalf], normal: [0, 0, -1] }  // -Z
  ];

  // â”€â”€ Scene ë“±ë¡ â”€â”€
  placeOnGround(cube);
  scene.add(cube);
  draggable.push(cube);

  clearAllSelection();
  selectedSet.add(cube);
  markSelected(cube);
  selectedMesh = cube;
  updateRotationGizmo();

  return cube;
}









/* ========== ì‚¬ê°í˜• íŒ(ê°€ë¡œ x ì„¸ë¡œ x ë‘ê»˜) ìƒì„± ========== */
// ì •ë©´ì—ì„œ ë´¤ì„ ë•Œ:
//  ê°€ë¡œ â†’ X ë°©í–¥ í¬ê¸°
//  ì„¸ë¡œ â†’ Y ë°©í–¥ í¬ê¸°
//  ë‘ê»˜ â†’ Z ë°©í–¥ í¬ê¸°
function spawnRectPlateWithPrompt() {
  const msg = "ê°€ë¡œ,ì„¸ë¡œ,ë‘ê»˜(mm)ë¥¼ ì…ë ¥í•˜ì„¸ìš”\nì˜ˆ) 600,300,18";
  const input = window.prompt(msg, "600,300,18");
  if (input === null) return;

  const parts = input.split(",").map(v => parseFloat(v.trim()));
  if (parts.length !== 3 || parts.some(v => !v || v <= 0)) {
    alert("ê°€ë¡œ,ì„¸ë¡œ,ë‘ê»˜ë¥¼ mm ë‹¨ìœ„ë¡œ ì…ë ¥í•˜ì„¸ìš”.\nì˜ˆ: 600,300,18");
    return;
  }

  const wMm = parts[0]; // ê°€ë¡œ
  const hMm = parts[1]; // ì„¸ë¡œ
  const tMm = parts[2]; // ë‘ê»˜

  // mm â†’ ì›”ë“œ ë‹¨ìœ„
  const w = wMm / MM_PER_UNIT;
  const h = hMm / MM_PER_UNIT;
  const t = tMm / MM_PER_UNIT;

  saveState();

  // â˜…â˜… ì •ë©´ ê¸°ì¤€:
  // ê°€ë¡œ = X
  // ì„¸ë¡œ = Z  â† ì—¬ê¸°ë¥¼ ë°”ê¿”ì¤Œ (Yê°€ ì•„ë‹ˆë¼ Z)
  // ë‘ê»˜ = Y
  const geo = new THREE.BoxGeometry(w, t, h);

const mat = new THREE.MeshStandardMaterial({
  color: 0x4b2e1f,   // ğŸŒ³ ì§„í•œ ê°ˆìƒ‰ (ì›”ë„› ê³„ì—´)
  roughness: 0.75,   // ë‚˜ë¬´ ì§ˆê°
  metalness: 0.05   // ê¸ˆì† ëŠë‚Œ ì œê±°
});


  const plate = new THREE.Mesh(geo, mat);
  plate.position.set(0, 0, 0);

  // ì •ë³´ ì €ì¥
  plate.userData.isRectPlate = true;
  plate.userData.widthMm  = wMm;
  plate.userData.heightMm = hMm;
  plate.userData.thickMm  = tMm;

  placeOnGround(plate);

  scene.add(plate);
  draggable.push(plate);

  clearAllSelection();
  selectedSet.add(plate);
  markSelected(plate);
  selectedMesh = plate;

  updateRotationGizmo();
}





/* ========== ì›í˜• íŒ(ì§€ë¦„ x ë‘ê»˜) ìƒì„± ========== */
/* =========================
   ì›í˜• íŒ (ì§€ë¦„, ë‘ê»˜)
   ì˜ˆ) 600,18  â†’ ì§€ë¦„ 600mm / ë‘ê»˜ 18mm
   ë°”ë‹¥ì— "ëˆ•í˜€ì§„" ë™ì „ì²˜ëŸ¼ ë°°ì¹˜
========================= */

// ë²„íŠ¼ì—ì„œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜
function spawnCirclePlatePrompt() {
  const txt = window.prompt("ì›í˜• íŒ : ì§€ë¦„,ë‘ê»˜(mm) ì…ë ¥ (ì˜ˆ: 600,18)", "600,18");
  if (!txt) return;

  const parts = txt.split(",").map(s => parseFloat(s.trim())).filter(v => !isNaN(v));
  if (parts.length < 2) {
    alert("ì§€ë¦„,ë‘ê»˜ ìˆœì„œë¡œ ë‘ ê°œì˜ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ) 600,18");
    return;
  }
  const diaMm = parts[0];
  const thkMm = parts[1];

  addCirclePlate(diaMm, thkMm);
}

function addCirclePlate(diaMm, thkMm) {
  saveState();

  const d  = parseFloat(diaMm) || 100;
  const t  = parseFloat(thkMm) || 10;

  const radiusUnits = (d / 2) / MM_PER_UNIT;
  const thickUnits  = t / MM_PER_UNIT;

  // ìƒ‰ ëŠë‚Œ
  const mat = new THREE.MeshStandardMaterial({
  color: 0x4b2e1f,   // ğŸŒ³ ì§„í•œ ê°ˆìƒ‰ (ì›”ë„› ê³„ì—´)
  roughness: 0.75,   // ë‚˜ë¬´ ì§ˆê°
  metalness: 0.05   // ê¸ˆì† ëŠë‚Œ ì œê±°
});


  // â— CylinderGeometry ê¸°ë³¸ ë°©í–¥ = Yì¶•(ìœ„/ì•„ë˜) ì´ë‹ˆê¹Œ
  //    ë”°ë¡œ íšŒì „ì‹œí‚¤ì§€ ì•Šìœ¼ë©´ "ë°”ë‹¥ì— ëˆ•íŒ íŒ"ì´ ëœë‹¤.
  const geo  = new THREE.CylinderGeometry(radiusUnits, radiusUnits, thickUnits, 48);
  const mesh = new THREE.Mesh(geo, mat);

  // âœ… ë” ì´ìƒ íŒŒì´í”„ì²˜ëŸ¼ íšŒì „ì‹œí‚¤ì§€ ë§ ê²ƒ!
  //    ì•„ë˜ì™€ ê°™ì€ ì¤„ì´ ì›ë˜ ìˆì—ˆë‹¤ë©´ ì „ë¶€ ì§€ì›Œì¤˜:
  //    mesh.rotation.x = Math.PI / 2;
  //    mesh.rotation.z = Math.PI / 2;

  mesh.position.set(0, 0, 0);

  mesh.userData.isPlate       = true;
  mesh.userData.plateShape    = "circle";
  mesh.userData.diameterMm    = d;
  mesh.userData.thicknessMm   = t;

  placeOnGround(mesh);       // ë°”ë‹¥(y=0)ì— ì˜¬ë ¤ë†“ê¸°

  scene.add(mesh);
  draggable.push(mesh);

  clearAllSelection();
  selectedSet.add(mesh);
  markSelected(mesh);
  selectedMesh = mesh;
  updateRotationGizmo();
}


window.resizeSelectedRectPlatePrompt = function () {
  if (!selectedMesh || !selectedMesh.userData?.isRectPlate) {
    alert("ì‚¬ê°íŒì„ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const w = selectedMesh.userData.widthMm  || 600;
  const h = selectedMesh.userData.heightMm || 300;
  const t = selectedMesh.userData.thickMm  || 18;

  const input = prompt(
    "ì‚¬ê°íŒ í¬ê¸° ì…ë ¥ (ê°€ë¡œ,ì„¸ë¡œ,ë‘ê»˜ mm)",
    `${w},${h},${t}`
  );
  if (!input) return;

  const parts = input.split(",").map(v => parseFloat(v.trim()));
  if (parts.length !== 3 || parts.some(v => !v || v <= 0)) {
    alert("ê°€ë¡œ,ì„¸ë¡œ,ë‘ê»˜ë¥¼ mm ë‹¨ìœ„ë¡œ ì •í™•íˆ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  const [wMm, hMm, tMm] = parts;

  saveState();

  const wU = wMm / MM_PER_UNIT;
  const hU = hMm / MM_PER_UNIT;
  const tU = tMm / MM_PER_UNIT;

  // ê¸°ì¡´ ì¤‘ì‹¬ ìœ ì§€
  const box = new THREE.Box3().setFromObject(selectedMesh);
  const center = new THREE.Vector3();
  box.getCenter(center);

  const newGeo = new THREE.BoxGeometry(wU, tU, hU);
  selectedMesh.geometry.dispose();
  selectedMesh.geometry = newGeo;

  selectedMesh.position.copy(center);

  selectedMesh.userData.widthMm  = wMm;
  selectedMesh.userData.heightMm = hMm;
  selectedMesh.userData.thickMm  = tMm;

  placeOnGround(selectedMesh);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);


};



window.resizeSelectedCirclePlatePrompt = function () {
  if (!selectedMesh || !selectedMesh.userData?.isPlate || selectedMesh.userData.plateShape !== "circle") {
    alert("ì›í˜•íŒì„ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const d = selectedMesh.userData.diameterMm  || 600;
  const t = selectedMesh.userData.thicknessMm || 18;

  const input = prompt(
    "ì›í˜•íŒ í¬ê¸° ì…ë ¥ (ì§€ë¦„,ë‘ê»˜ mm)",
    `${d},${t}`
  );
  if (!input) return;

  const parts = input.split(",").map(v => parseFloat(v.trim()));
  if (parts.length !== 2 || parts.some(v => !v || v <= 0)) {
    alert("ì§€ë¦„,ë‘ê»˜ë¥¼ mm ë‹¨ìœ„ë¡œ ì •í™•íˆ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  const [diaMm, thkMm] = parts;

  saveState();

  const rU = (diaMm / 2) / MM_PER_UNIT;
  const tU = thkMm / MM_PER_UNIT;

  const box = new THREE.Box3().setFromObject(selectedMesh);
  const center = new THREE.Vector3();
  box.getCenter(center);

  const newGeo = new THREE.CylinderGeometry(rU, rU, tU, 48);
  selectedMesh.geometry.dispose();
  selectedMesh.geometry = newGeo;

  selectedMesh.position.copy(center);

  selectedMesh.userData.diameterMm  = diaMm;
  selectedMesh.userData.thicknessMm = thkMm;

  placeOnGround(selectedMesh);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);


};








/* ===== íŒŒì´í”„ ë²„íŠ¼ â†’ ê¸¸ì´ ì…ë ¥ íŒì—… ===== */
function spawnPipeWithPrompt(size) {
  let defaultLen = "100";
  if (size === "15A" && pipe15LenInput) defaultLen = pipe15LenInput.value || "100";
  if (size === "20A" && pipe20LenInput) defaultLen = pipe20LenInput.value || "100";

  const msg = size + " íŒŒì´í”„ ê¸¸ì´(mm)ë¥¼ ì…ë ¥í•˜ì„¸ìš”";
  const input = window.prompt(msg, defaultLen);
  if (input === null) return;

  const len = parseFloat(input);
  if (!len || len <= 0) {
    alert("0ë³´ë‹¤ í° ìˆ«ìë¥¼ mm ë‹¨ìœ„ë¡œ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  if (size === "15A" && pipe15LenInput) pipe15LenInput.value = len;
  if (size === "20A" && pipe20LenInput) pipe20LenInput.value = len;

  addKSPipe(size, len);
}

/* ========== KS ê·œê²© íŒŒì´í”„ ìƒì„± ========== */
function addKSPipe(size, lengthMm){
  saveState();

  const lenMm = parseFloat(lengthMm) || 100;
  const od = KS_OD[size];
  const radiusUnits = (od / 2) / MM_PER_UNIT;
  const lenUnits = lenMm / MM_PER_UNIT;

  // ê¸°ë³¸ ìƒ‰ìƒ
let color = 0x3a3a3a; // KS íŒŒì´í”„ ê¸°ë³¸ìƒ‰(ì–´ë‘ìš´ íšŒìƒ‰)

// âœ… 12mm / 15mm íŒŒì´í”„ëŠ” ì€ìƒ‰
if (od === 12 || od === 15) {
  color = 0xbfc3c7;
}


  const mat = new THREE.MeshStandardMaterial({
    color,
    roughness:0.6,
    metalness:0.2
  });
  const geo = new THREE.CylinderGeometry(radiusUnits, radiusUnits, lenUnits, 24);
  const pipe = new THREE.Mesh(geo, mat);
  pipe.rotation.z = Math.PI/2;
  pipe.position.set(0,0,0);
  pipe.userData.isPipe   = true;
  pipe.userData.size     = size;
  pipe.userData.lengthMm = lenMm;
  pipe.userData.radiusMm = od / 2;

  placeOnGround(pipe);

  scene.add(pipe);
  draggable.push(pipe);

  clearAllSelection();
  selectedSet.add(pipe);
  markSelected(pipe);
  selectedMesh = pipe;
  updateRotationGizmo();

  return pipe;
}

/* ì„ íƒ íŒŒì´í”„ ê¸¸ì´ ë³€ê²½ (UI ë²„íŠ¼ì€ ì§€ê¸ˆ ì—†ìŒ) */
function resizeSelectedPipe(){
  if (!selectedMesh || !selectedMesh.userData || !selectedMesh.userData.isPipe) {
    alert("ê¸¸ì´ë¥¼ ë°”ê¿€ íŒŒì´í”„ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.");
    return;
  }
  const newLenMm = parseFloat(selectedPipeLenInput.value);
  if (!newLenMm || newLenMm <= 0) {
    alert("0ë³´ë‹¤ í° ê¸¸ì´ë¥¼ mm ë‹¨ìœ„ë¡œ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }
  saveState();

  const radiusMm = selectedMesh.userData.radiusMm || (KS_OD[selectedMesh.userData.size]/2);
  const radiusUnits = radiusMm / MM_PER_UNIT;
  const lenUnits = newLenMm / MM_PER_UNIT;

  const newGeo = new THREE.CylinderGeometry(radiusUnits, radiusUnits, lenUnits, 24);
  selectedMesh.geometry.dispose();
  selectedMesh.geometry = newGeo;
  selectedMesh.userData.lengthMm = newLenMm;
}


function addKSPipePrompt(size) {
  const len = prompt("íŒŒì´í”„ ê¸¸ì´ë¥¼ mm ë‹¨ìœ„ë¡œ ì…ë ¥í•˜ì„¸ìš”", "100");
  if (len === null) return;

  const lenMm = parseFloat(len);
  if (!isFinite(lenMm) || lenMm <= 0) {
    alert("ì˜¬ë°”ë¥¸ ê¸¸ì´(mm)ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  addKSPipe(size, lenMm);
}





/* ========== ë³µì‚¬ / ì‚­ì œ / ì „ì²´ ì‚­ì œ ========== */
/* ============================================
   ì„ íƒëœ ë¶€ì†ë“¤ì„ í•˜ë‚˜ì˜ STL íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°
   - selectedSet ì— ìˆëŠ” ê²ƒë“¤ + selectedMesh
   - ë‚´ë¶€ Mesh ë“¤ê¹Œì§€ worldMatrix ì ìš© í›„ STL ìƒì„±
   - ë‚´ë³´ë‚¼ ë•Œ Xì¶• ê¸°ì¤€ -90ë„ íšŒì „ (íŒŒë€ì¶• ì •ë©´)
============================================ */

function exportSelectedToSTL() {
  const targets =
    selectedSet.size > 0 ? [...selectedSet] :
    (selectedMesh ? [selectedMesh] : []);

  if (targets.length === 0) {
    alert("ë¨¼ì € STLë¡œ ì €ì¥í•  ë¶€ì†ì„ í•˜ë‚˜ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const worldGeometries = [];

  targets.forEach(obj => {
    obj.updateWorldMatrix(true, false);

    obj.traverse(child => {
      if (!child.isMesh || !child.geometry) return;

      const g = child.geometry.clone();
      g.applyMatrix4(child.matrixWorld);

      // âœ… ì•ˆì „ì¥ì¹˜: ì´ìƒê°’/ë¹ˆ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°©ì§€
      const pos = g.getAttribute("position");
      if (!pos || pos.count < 3) return;

      worldGeometries.push(g);
    });
  });

  if (worldGeometries.length === 0) {
    alert("ì„ íƒëœ ë¶€ì†ì—ì„œ ë‚´ë³´ë‚¼ ë©”ì‹œê°€ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  // âœ… 1) ì¶• ë³´ì •(ê¸°ì¡´ ìœ ì§€)
  const rot = new THREE.Matrix4().makeRotationX(Math.PI / 2);

  // âœ… 2) ìŠ¤ì¼€ì¹˜ì—…ìš© ìŠ¤ì¼€ì¼ ì—…(ë„ˆë¬´ ì‘ìœ¼ë©´ ì‹¤íŒ¨í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ)
  const EXPORT_SCALE = 100;
  const scl = new THREE.Matrix4().makeScale(EXPORT_SCALE, EXPORT_SCALE, EXPORT_SCALE);

  worldGeometries.forEach(g => {
    g.applyMatrix4(rot);
    g.applyMatrix4(scl);
  });

  // âœ… 3) ë°”ì´ë„ˆë¦¬ STL ìƒì„± + ë‹¤ìš´ë¡œë“œ
  const stlBuffer = buildBinaryStlFromGeometries(worldGeometries);
  downloadBinaryFile("pipe3d_export.stl", stlBuffer);
}
function buildBinaryStlFromGeometries(geometries) {
  // ë¨¼ì € ì „ì²´ triangle ê°œìˆ˜ ê³„ì‚°
  let triCount = 0;

  geometries.forEach(geo => {
    let g = geo;
    if (g.index) g = g.toNonIndexed();
    const pos = g.getAttribute("position");
    if (!pos) return;
    triCount += Math.floor(pos.count / 3);
  });

  // STL ë°”ì´ë„ˆë¦¬ í¬ë§·: 80ë°”ì´íŠ¸ í—¤ë” + 4ë°”ì´íŠ¸ triCount + (triCount * 50ë°”ì´íŠ¸)
  const buffer = new ArrayBuffer(84 + triCount * 50);
  const dv = new DataView(buffer);

  // 80ë°”ì´íŠ¸ í—¤ë” (ì•„ë¬´ ë¬¸ìì—´/0ìœ¼ë¡œ ì±„ì›Œë„ ë¨)
  const header = "pipe3d_export_binary";
  for (let i = 0; i < 80; i++) {
    dv.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }

  dv.setUint32(80, triCount, true);

  let offset = 84;

  const vA = new THREE.Vector3();
  const vB = new THREE.Vector3();
  const vC = new THREE.Vector3();
  const cb = new THREE.Vector3();
  const ab = new THREE.Vector3();
  const n  = new THREE.Vector3();

  geometries.forEach(geo => {
    let g = geo;
    if (g.index) g = g.toNonIndexed();

    const pos = g.getAttribute("position");
    if (!pos) return;

    // normalì´ ì—†ìœ¼ë©´ ê³„ì‚°
    if (!g.getAttribute("normal")) g.computeVertexNormals();

    for (let i = 0; i < pos.count; i += 3) {
      vA.fromBufferAttribute(pos, i);
      vB.fromBufferAttribute(pos, i + 1);
      vC.fromBufferAttribute(pos, i + 2);

      // ë©´ ë…¸ë©€(ìŠ¤ì¼€ì¹˜ì—…ì—ì„œ ë” ì•ˆì •ì ì¸ í¸)
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      n.copy(cb.cross(ab));
      if (n.lengthSq() > 0) n.normalize();
      else n.set(0, 0, 0);

      // normal (12 bytes)
      dv.setFloat32(offset,     n.x, true);
      dv.setFloat32(offset + 4, n.y, true);
      dv.setFloat32(offset + 8, n.z, true);
      offset += 12;

      // vA, vB, vC (each 12 bytes)
      dv.setFloat32(offset,     vA.x, true);
      dv.setFloat32(offset + 4, vA.y, true);
      dv.setFloat32(offset + 8, vA.z, true);
      offset += 12;

      dv.setFloat32(offset,     vB.x, true);
      dv.setFloat32(offset + 4, vB.y, true);
      dv.setFloat32(offset + 8, vB.z, true);
      offset += 12;

      dv.setFloat32(offset,     vC.x, true);
      dv.setFloat32(offset + 4, vC.y, true);
      dv.setFloat32(offset + 8, vC.z, true);
      offset += 12;

      // attribute byte count (2 bytes)
      dv.setUint16(offset, 0, true);
      offset += 2;
    }
  });

  return buffer;
}

function downloadBinaryFile(filename, arrayBuffer) {
  const blob = new Blob([arrayBuffer], { type: "application/octet-stream" });
  const url  = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.style.display = "none";
  a.href = url;
  a.download = filename;

  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}



/* ì—¬ëŸ¬ ê°œì˜ BufferGeometry â†’ í•˜ë‚˜ì˜ ASCII STL ë¬¸ìì—´ë¡œ ë§Œë“¤ê¸° */
function buildASCIIStlFromGeometries(geometries, solidName) {
  let lines = [];
  lines.push("solid " + (solidName || "export"));

  const vA = new THREE.Vector3();
  const vB = new THREE.Vector3();
  const vC = new THREE.Vector3();
  const cb = new THREE.Vector3();
  const ab = new THREE.Vector3();

  geometries.forEach(geo => {
    let g = geo;
    if (g.index) {
      g = g.toNonIndexed();
    }

    const pos = g.getAttribute("position");
    let nor = g.getAttribute("normal");

    if (!nor) {
      g.computeVertexNormals();
      nor = g.getAttribute("normal");
    }

    for (let i = 0; i < pos.count; i += 3) {
      vA.fromBufferAttribute(pos, i);
      vB.fromBufferAttribute(pos, i + 1);
      vC.fromBufferAttribute(pos, i + 2);

      let nx, ny, nz;
      if (nor) {
        nx = nor.getX(i);
        ny = nor.getY(i);
        nz = nor.getZ(i);
      } else {
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab).normalize();
        nx = cb.x; ny = cb.y; nz = cb.z;
      }

      lines.push(`  facet normal ${nx} ${ny} ${nz}`);
      lines.push(`    outer loop`);
      lines.push(`      vertex ${vA.x} ${vA.y} ${vA.z}`);
      lines.push(`      vertex ${vB.x} ${vB.y} ${vB.z}`);
      lines.push(`      vertex ${vC.x} ${vC.y} ${vC.z}`);
      lines.push(`    endloop`);
      lines.push(`  endfacet`);
    }
  });

  lines.push("endsolid " + (solidName || "export"));
  return lines.join("\n");
}

/* ë¬¸ìì—´ì„ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œì‹œí‚¤ëŠ” ìœ í‹¸ */
function downloadTextFile(filename, text) {
  const blob = new Blob([text], { type: "application/octet-stream" });
  const url  = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.style.display = "none";
  a.href = url;
  a.download = filename;

  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}








function cloneSelected(){
  if (selectedSet.size === 0 && !selectedMesh) {
    alert("ë¨¼ì € ë³µì‚¬í•  ê°œì²´ë¥¼ ì„ íƒí•˜ì„¸ìš” (í´ë¦­).");
    return;
  }
  saveState();

  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
  clearAllSelection();

  let lastClone = null;
  targets.forEach(src=>{
    const clone = src.clone(true);
    clone.userData = {...src.userData};
    makeMaterialsUnique(clone);
    clone.position.add(new THREE.Vector3(0.3, 0, 0.3));
    scene.add(clone);
    draggable.push(clone);

    selectedSet.add(clone);
    markSelected(clone);
    lastClone = clone;
  });

  selectedMesh = lastClone;
  updateRotationGizmo();
}

function deleteSelected(){
  if (selectedSet.size === 0 && !selectedMesh) return;
  saveState();

  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
  targets.forEach(m => {
    unmarkSelected(m);
    scene.remove(m);
    const idx = draggable.indexOf(m);
    if (idx !== -1) draggable.splice(idx, 1);
  });
  selectedSet.clear();
  selectedMesh = null;
  updateRotationGizmo();
}

function clearScene(){
  saveState();

  const keep = new Set([grid, ambient, dirLight, rotationGizmo]);
  scene.children.slice().forEach(obj=>{
    if (!keep.has(obj)) scene.remove(obj);
  });
  draggable.length = 0;
  selectedSet.clear();
  selectedMesh = null;
  updateRotationGizmo();
}

/* ========== ê·¸ë£¹ ë§Œë“¤ê¸° / í•´ì œ ========== */
function groupSelected() {
  if (selectedSet.size < 2) {
    alert("ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì„ ê°œì²´ë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”. (Ctrl+í´ë¦­)");
    return;
  }
  saveState();

  const objects = [...selectedSet];

  const center = new THREE.Vector3();
  objects.forEach(o => {
    const wp = new THREE.Vector3();
    o.getWorldPosition(wp);
    center.add(wp);
  });
  center.multiplyScalar(1/objects.length);

  const group = new THREE.Group();
  group.position.copy(center);

  objects.forEach(o => {
    const wp = new THREE.Vector3();
    o.getWorldPosition(wp);

    unmarkSelected(o);
    const idx = draggable.indexOf(o);
    if (idx !== -1) draggable.splice(idx,1);

    scene.remove(o);
    group.add(o);

    o.position.copy(wp);
    o.position.sub(center);
  });

  scene.add(group);
  draggable.push(group);

  selectedSet.clear();
  selectedMesh = group;
  selectedSet.add(group);
  markSelected(group);
  updateRotationGizmo();
}

function ungroupSelected() {
  if (!selectedMesh || !(selectedMesh instanceof THREE.Group)) {
    alert("í˜„ì¬ ì„ íƒëœ ê°ì²´ê°€ ê·¸ë£¹ì´ ì•„ë‹™ë‹ˆë‹¤.");
    return;
  }
  saveState();

  const group = selectedMesh;

  // [í•µì‹¬ ìˆ˜ì • 1] ê·¸ë£¹ì„ ê¹¨ê¸° ì „ì—, ê·¸ë£¹ì— ê·¸ë ¤ì§„ ë…¸ë€ ì ì„ ì„ ë¨¼ì € ê¹”ë”í•˜ê²Œ ì§€ì›ë‹ˆë‹¤.
  unmarkSelected(group);

  group.updateWorldMatrix(true, false);

  const children = group.children.slice();

  children.forEach(child => {
    // [í•µì‹¬ ìˆ˜ì • 2] ìì‹ ë¶€í’ˆë“¤ì— í˜¹ì‹œë¼ë„ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆëŠ” ì ì„  ì”ì¬ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
    if (typeof stripSelectionOutlineDeep === "function") {
        stripSelectionOutlineDeep(child);
    } else {
        // í•¨ìˆ˜ê°€ ì—†ì„ ê²½ìš° ìˆ˜ë™ ì œê±°
        if (child.userData && child.userData.selectionOutline) {
            child.remove(child.userData.selectionOutline);
            delete child.userData.selectionOutline;
        }
    }

    child.updateWorldMatrix(true, false);
    const worldMatrix = child.matrixWorld.clone();

    group.remove(child);
    scene.add(child);

    // ì›”ë“œ ì¢Œí‘œ ìœ ì§€
    worldMatrix.decompose(child.position, child.quaternion, child.scale);

    draggable.push(child);
  });

  // ê·¸ë£¹ ê»ë°ê¸° ì‚­ì œ
  const idx = draggable.indexOf(group);
  if (idx !== -1) draggable.splice(idx, 1);
  scene.remove(group);

  // ìì‹ë“¤ ê°œë³„ ì„ íƒ ìƒíƒœë¡œ ë³€ê²½
  clearAllSelection();
  children.forEach(ch => {
    selectedSet.add(ch);
    markSelected(ch);
  });
  selectedMesh = children[children.length - 1] || null;
  
  // ğŸ”¹ ìœ¤ê³½ì„  ë° ê¸°ì¦ˆëª¨ ì—…ë°ì´íŠ¸
  if(typeof setSelectedObject === "function") setSelectedObject(selectedMesh);
  updateRotationGizmo();
}

/* ========== ìì„: ì²´ì¸ ë°©ì‹ (ìœ„ì¹˜ë§Œ) ========== */
function attachSelectedGroup() {
  const arr = [...selectedSet];
  if (arr.length < 2) {
    alert("ë‘ ê°œ ì´ìƒ ì„ íƒ í›„ Aë¥¼ ëˆ„ë¥´ê±°ë‚˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    return;
  }

  saveState();

  function collectAttachPoints(obj) {
    const pts = [];
    if (obj.geometry) {
      pts.push(...getWorldAttachPointsForMesh(obj));
    } else if (obj instanceof THREE.Group) {
      obj.traverse(child => {
        if (child.geometry) pts.push(...getWorldAttachPointsForMesh(child));
      });
    }
    return pts;
  }

  function attachPair(anchor, target) {
  // âœ… ì›”ë“œí–‰ë ¬ ìµœì‹ í™”(ê·¸ë£¹+ê·¸ë£¹ì—ì„œ í•µì‹¬)
  anchor.updateWorldMatrix(true, false);
  target.updateWorldMatrix(true, false);

  const anchorPts = collectAttachPoints(anchor);
  const myPts     = collectAttachPoints(target);
  if (!anchorPts.length || !myPts.length) return;

  let bestDist = Infinity;
  let bestA = null;
  let bestB = null;

  for (let i = 0; i < anchorPts.length; i++) {
    const ap = anchorPts[i];
    for (let j = 0; j < myPts.length; j++) {
      const mp = myPts[j];
      const d = ap.distanceTo(mp);
      if (d < bestDist) {
        bestDist = d;
        bestA = ap;
        bestB = mp;
      }
    }
  }

  if (!bestA || !bestB) return;

  const delta = new THREE.Vector3().subVectors(bestA, bestB);
  target.position.add(delta);

  // âœ… ì´ë™ í›„ì—ë„ ìµœì‹ í™”
  target.updateWorldMatrix(true, false);
}


  for (let i = 1; i < arr.length; i++) {
    attachPair(arr[i - 1], arr[i]);
  }

  updateRotationGizmo();
}





/* ========== ì„ íƒ ê°œì²´ ì •ë ¬ ìœ í‹¸ ========== */

// ê°œì²´(ë©”ì‹œ/ê·¸ë£¹)ì˜ ì›”ë“œ ê¸°ì¤€ ì¤‘ì‹¬ì  êµ¬í•˜ê¸°
function getObjectCenterWorld(obj) {
  const box = new THREE.Box3().setFromObject(obj);
  const center = new THREE.Vector3();
  box.getCenter(center);
  return center;
}

function alignSelectionAxis(axis) {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (targets.length < 2) {
    alert("ì •ë ¬í•  ê°œì²´ë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  saveState();  // Undo ì €ì¥

  // ê¸°ì¤€ì´ ë˜ëŠ” ì²« ë²ˆì§¸(ë˜ëŠ” ë§ˆì§€ë§‰ ì„ íƒì„ ê¸°ì¤€ìœ¼ë¡œ í•˜ê³  ì‹¶ìœ¼ë©´ targets[targets.length-1]ë¡œ ë°”ê¿”ë„ ë¨)
  const refCenter = getObjectCenterWorld(targets[0]);

  let refVal = 0;
  if (axis === "x") refVal = refCenter.x;
  else if (axis === "y") refVal = refCenter.y;
  else refVal = refCenter.z;

  for (let i = 1; i < targets.length; i++) {
    const obj = targets[i];
    const c = getObjectCenterWorld(obj);

    let curVal = 0;
    if (axis === "x") curVal = c.x;
    else if (axis === "y") curVal = c.y;
    else curVal = c.z;

    const delta = refVal - curVal;

    if (axis === "x") obj.position.x += delta;
    else if (axis === "y") obj.position.y += delta;
    else obj.position.z += delta;
  }

  updateRotationGizmo();
}





/* ========== í™”ë©´ ì¢Œí‘œ â†’ Raycaster ========== */
function setMouseFromEvent(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top)  / rect.height;
  mouse.x = x * 2 - 1;
  mouse.y = -(y * 2 - 1);
}

/* ìµœìƒìœ„ draggable ì°¾ê¸° */
function findTopDraggable(obj) {
  let cur = obj;
  while (cur && !draggable.includes(cur)) {
    cur = cur.parent;
  }
  return cur || obj;
}

/* ========== ì„ íƒ ê¸°ì¤€ ì‹œì  ì´ë™ ========== */
function focusOnSelection() {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  if (targets.length === 0) return;

  // 1. ì„ íƒëœ ëª¨ë“  ê°œì²´ë¥¼ í¬í•¨í•˜ëŠ” ì˜ì—­(Box) ê³„ì‚°
  const box = new THREE.Box3();
  targets.forEach(obj => {
    box.expandByObject(obj);
  });

  const center = new THREE.Vector3();
  box.getCenter(center); // ê°œì²´ë“¤ì˜ ì¤‘ì‹¬ì 
  const size = new THREE.Vector3();
  box.getSize(size);    // ê°œì²´ë“¤ì˜ ì „ì²´ í¬ê¸°

  // 2. ê°œì²´ í¬ê¸°ì— ë”°ë¥¸ ì ì ˆí•œ ê±°ë¦¬ ê³„ì‚°
  // ê°œì²´ì˜ ëŒ€ê°ì„  ê¸¸ì´ë¥¼ êµ¬í•´ì„œ ê·¸ë³´ë‹¤ ì•½ê°„ ë” ë©€ë¦¬ ë°°ì¹˜ (í™”ë©´ì— ê½‰ ì°¨ê²Œ)
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  
  // ë¬¼ì²´ê°€ í™”ë©´ì— ì ë‹¹íˆ ë“¤ì–´ì˜¤ëŠ” ê±°ë¦¬ ê³„ì‚° (ì—¬ìœ ê³„ìˆ˜ 1.5)
  let newRadius = maxDim / (2 * Math.tan(fov / 2)) * 0.8;

  // ë„ˆë¬´ ì‘ì€ ë¬¼ì²´ë‚˜ ë„ˆë¬´ í° ë¬¼ì²´ì¼ ê²½ìš° ìµœì†Œ/ìµœëŒ€ ê±°ë¦¬ ì œí•œ
  newRadius = Math.max(newRadius, 2); 

  // 3. ì¹´ë©”ë¼ ì¢Œí‘œ ë° íƒ€ê²Ÿ ì—…ë°ì´íŠ¸
  camTarget.copy(center); // íšŒì „ ì¤‘ì‹¬ì„ ê°œì²´ ì¤‘ì‹¬ìœ¼ë¡œ
  radius = newRadius;     // ê±°ë¦¬ë¥¼ ê°œì²´ ì•ìœ¼ë¡œ ë‹¹ê¹€

  // 4. ì¦‰ì‹œ ì¹´ë©”ë¼ ë°˜ì˜
  updateCamera();
  
  console.log("ê°œì²´ ë³´ê¸° ì‹¤í–‰: ê±°ë¦¬", Math.round(radius));
}



/* ========== í„°ì¹˜ ì§€ì› ì¶”ê°€ ========== */
/* ========== í„°ì¹˜ ì§€ì› ì¶”ê°€ (ê¸°ì¡´ ë§ˆìš°ìŠ¤ ë¡œì§ ì—°ê²°) ========== */
canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1) {
    const touch = e.touches[0];
    // ê°€ìƒì˜ ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ í´ë¦­(button: 0) ì´ë²¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì„œ mousedown ë¡œì§ ì‹¤í–‰
    const mouseEvent = new MouseEvent("mousedown", {
      clientX: touch.clientX,
      clientY: touch.clientY,
      button: 0
    });
    canvas.dispatchEvent(mouseEvent);
  }
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  if (e.touches.length === 1) {
    e.preventDefault(); // ìŠ¤í¬ë¡¤ ë°©ì§€
    const touch = e.touches[0];
    // ê°€ìƒì˜ mousemove ì´ë²¤íŠ¸ ìƒì„±
    const mouseEvent = new MouseEvent("mousemove", {
      clientX: touch.clientX,
      clientY: touch.clientY
    });
    window.dispatchEvent(mouseEvent);
  }
}, { passive: false });

canvas.addEventListener("touchend", (e) => {
  // ê°€ìƒì˜ mouseup ì´ë²¤íŠ¸ ìƒì„±
  const mouseEvent = new MouseEvent("mouseup", {});
  window.dispatchEvent(mouseEvent);
}, { passive: false });


/* ========== ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ========== */
canvas.addEventListener("mousedown", e => {
  lastX = e.clientX;
  lastY = e.clientY;

  // ê°€ìš´ë° ë²„íŠ¼ (íœ  í´ë¦­): í‰í–‰ì´ë™(Pan) / Shift+í´ë¦­ì‹œ ë†’ì´ì´ë™(Elevate)
  if (e.button === 1) {
    e.preventDefault();
    dragging = true;
    
    // [ìˆ˜ì •ë¨] ë’¤ì— ë¶™ì–´ìˆë˜ 'orbit' ê¸€ì ì‚­ì œí•¨
    dragMode = e.shiftKey ? "elevate" : "pan"; 
    return;
  }

  // ì˜¤ë¥¸ìª½ ë²„íŠ¼: íšŒì „(Orbit)
  if (e.button === 2) {
    e.preventDefault();
    dragging = true;
    dragMode = "orbit";
    return;
  }


  

  // ì™¼ìª½ ë²„íŠ¼ë§Œ ì•„ë˜ ë¡œì§ ì§„í–‰ (ì„ íƒ, ìƒì„± ë“±)
  if (e.button !== 0) return;

  setMouseFromEvent(e);

  // íšŒì „ Gizmo
  if (rotationGizmo && rotationGizmo.visible && gizmoEnabled && (hitRingX || hitRingY || hitRingZ)) {
    raycaster.setFromCamera(mouse, camera);
    const gizmoHits = raycaster.intersectObjects([hitRingX, hitRingY, hitRingZ], true);

    if (gizmoHits.length > 0 && (selectedMesh || selectedSet.size > 0)) {
      const hitObj = gizmoHits[0].object;
      const axis = hitObj.userData.axis || "y";
      rotateAxis = axis;

      // ì´ë²ˆ íšŒì „ì— ì‚¬ìš©í•  ì›”ë“œ ì¶•
      if (rotateAxis === "x")      rotateWorldAxis.set(1, 0, 0);
      else if (rotateAxis === "y") rotateWorldAxis.set(0, 1, 0);
      else if (rotateAxis === "z") rotateWorldAxis.set(0, 0, 1);

      saveState();
      dragging = true;
      dragMode = "rotate";

      // íšŒì „ ì¤‘ì‹¬(í™”ë©´ ì¢Œí‘œ)
      const centerWorld = rotationGizmo.position.clone();
      const proj = centerWorld.project(camera);
      rotateCenterScreen.set(
        ( proj.x * 0.5 + 0.5 ) * window.innerWidth,
        (-proj.y * 0.5 + 0.5 ) * window.innerHeight
      );

      const sx = e.clientX;
      const sy = e.clientY;
      rotateStartAngle = Math.atan2(sy - rotateCenterScreen.y, sx - rotateCenterScreen.x);

      // ì´ˆê¸° ì¿¼í„°ë‹ˆì–¸ ì €ì¥
      initialRotations.clear();
      const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];
      targets.forEach(o => {
        initialRotations.set(o, o.quaternion.clone());
      });

      hoveredAxis = rotateAxis;
      updateRingHoverVisuals(hoveredAxis);

      if (angleUI) {
        angleUI.style.display = "block";
        angleUI.textContent = rotateAxis.toUpperCase() + " 0Â°";
        angleUI.style.left = rotateCenterScreen.x + "px";
        angleUI.style.top  = (rotateCenterScreen.y - 60) + "px";
      }
      return;
    }
  }

  // ì¼ë°˜ ì„ íƒ / ì´ë™ / ë“œë˜ê·¸ ë°•ìŠ¤
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(draggable, true);

  if (hits.length > 0) {
    const hit = hits[0];
    const target = findTopDraggable(hit.object);

    if (e.ctrlKey || e.metaKey) {
      toggleSelect(target);
    } else {
      if (selectedSet.size > 1 && selectedSet.has(target)) {
        selectedMesh = target;
      } else {
        selectOnly(target);
      }
    }

    const anchor = selectedMesh || target;

    movePlane.set(new THREE.Vector3(0,1,0), 0);
    raycaster.setFromCamera(mouse, camera);
    if (raycaster.ray.intersectPlane(movePlane, planeHit)) {
      dragOffset.copy(anchor.position).sub(planeHit);
    } else {
      dragOffset.set(0, anchor.position.y, 0);
    }

    saveState();
    dragging = true;
    dragMode = "move";

  } else {
    // ë¹ˆ ê³µê°„ í´ë¦­ â†’ ì„ íƒ í•´ì œ + ë°•ìŠ¤ ì„ íƒ ì‹œì‘
    clearAllSelection();
    createSelectionRect(e.clientX, e.clientY, e.ctrlKey || e.metaKey);

    dragging = true;
    dragMode = "rect";
  }
});
canvas.addEventListener("dblclick", (e) => {
  // âœ… ë”ë¸”í´ë¦­ ì§€ì ì—ì„œ ì˜¤ë¸Œì íŠ¸ ì§‘ê¸°
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  // âœ… selection outline ê°™ì€ ê±´ raycast ë§‰ì•„ë†¨ìœ¼ë‹ˆ(ë„ˆ ì½”ë“œì— ìˆìŒ) ê·¸ëŒ€ë¡œ ì˜ ì¡í˜
  const hits = raycaster.intersectObjects(draggable, true);
  if (!hits.length) return;

  // ìµœìƒìœ„ draggable(ë¶€ëª¨)ë¡œ ëŒì–´ì˜¬ë¦¬ê¸°
  let obj = hits[0].object;
  while (obj && !draggable.includes(obj) && obj.parent) obj = obj.parent;
  if (!obj) return;

  // âœ… ë”ë¸”í´ë¦­í•œ ëŒ€ìƒë§Œ ì„ íƒ
  selectOnly(obj);

  // âœ… íƒ€ì…ë³„ ì¹˜ìˆ˜ ë³€ê²½ í˜¸ì¶œ
  if (selectedMesh?.userData?.isPipe) {
    resizeSelectedPipePrompt();
    return;
  }

  if (selectedMesh?.userData?.isRectPlate) {
    // ë„¤ ì½”ë“œì— ì‚¬ê°íŒ ì¹˜ìˆ˜ ë³€ê²½ í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ í˜¸ì¶œ
    // (ì´ë¦„ì´ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ì„œ, ì•„ë˜ ë‘˜ ì¤‘ ë„¤ íŒŒì¼ì— ìˆëŠ” ê±¸ë¡œ ë§ì¶°)
    if (typeof resizeSelectedRectPlatePrompt === "function") resizeSelectedRectPlatePrompt();
    else if (typeof resizeRectPlatePrompt === "function") resizeRectPlatePrompt();
    return;
  }

  if (selectedMesh?.userData?.isPlate && selectedMesh?.userData?.plateShape === "circle") {
    if (typeof resizeSelectedCirclePlatePrompt === "function") resizeSelectedCirclePlatePrompt();
    else if (typeof resizeCirclePlatePrompt === "function") resizeCirclePlatePrompt();
    return;
  }
});


let lastUpTime = 0;
let lastUpX = 0;
let lastUpY = 0;

window.addEventListener("mouseup", e => {
  if (e.button !== 0) return;

  const now = performance.now();
  const dx = Math.abs(e.clientX - lastUpX);
  const dy = Math.abs(e.clientY - lastUpY);

  // ì´ë™ì´ ìˆì—ˆìœ¼ë©´ í´ë¦­ ì·¨ì†Œ
  if (dx > 4 || dy > 4) {
    lastUpTime = now;
    lastUpX = e.clientX;
    lastUpY = e.clientY;
    return;
  }

  // ë”ë¸”í´ë¦­ íŒì • (300ms)
  if (now - lastUpTime > 300) {
    lastUpTime = now;
    lastUpX = e.clientX;
    lastUpY = e.clientY;
    return;
  }

  lastUpTime = 0;

  setMouseFromEvent(e);
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(draggable, true);
  if (hits.length === 0) return;

  const target = findTopDraggable(hits[0].object);
  if (!target) return;

  selectOnly(target);
});





canvas.addEventListener("contextmenu", e => e.preventDefault());

window.addEventListener("mousemove", e=>{
  setMouseFromEvent(e);

  const canHover = !(dragging && dragMode === "rotate");

  if (canHover && rotationGizmo && rotationGizmo.visible && gizmoEnabled && (hitRingX || hitRingY || hitRingZ)) {
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects([hitRingX, hitRingY, hitRingZ], true);
    let newAxis = null;
    if (hits.length > 0) {
      const hitObj = hits[0].object;
      newAxis = hitObj.userData.axis || null;
    }
    if (newAxis !== hoveredAxis) {
      hoveredAxis = newAxis;
      updateRingHoverVisuals(hoveredAxis);
    }
  } else if (canHover && hoveredAxis !== null && !(dragging && dragMode === "rotate")) {
    hoveredAxis = null;
    updateRingHoverVisuals(null);
  }

  if (!dragging) return;

  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;

  if (dragMode === "orbit") {
    theta -= dx * 0.001;
    phi   -= dy * 0.001;
    const eps = 0.1;
    phi = Math.max(eps, Math.min(Math.PI-eps, phi));
    updateCamera();

 } else if (dragMode === "pan") {
    const distFromTarget = camera.position.distanceTo(camTarget);
    
    // ìµœì†Œ ê±°ë¦¬ ë³´ì •ê°’ì„ 10ìœ¼ë¡œ ëŒ€í­ ë‚®ì¶¤ (ê°€ê¹Œìš´ ê³³ì—ì„œ ì²œì²œíˆ ì›€ì§ì´ê²Œ)
    const effectiveDist = Math.max(distFromTarget, 10); 

    let worldPerPixel = 
      (effectiveDist * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * 2) / window.innerHeight;

    // ì „ì²´ ì†ë„ë¥¼ 0.4ë°°ë¡œ ë‚®ì¶¤ (ë§¤ìš° ë¶€ë“œëŸ¬ì›Œì§)
    worldPerPixel *= 0.2; 

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
    const rightOnPlane = new THREE.Vector3(right.x, 0, right.z).normalize();
    const forwardOnPlane = new THREE.Vector3(dir.x, 0, dir.z).normalize();

    camTarget.addScaledVector(rightOnPlane, -dx * worldPerPixel);
    camTarget.addScaledVector(forwardOnPlane, dy * worldPerPixel);

    updateCamera();








  } else if (dragMode === "move" && (selectedMesh || selectedSet.size > 0)) {
    // âœ… [ìˆ˜ì •ë¨] í™”ë©´ ê¸°ì¤€ ì´ë™ (ì–´ë””ì„œë“  ê°ë„ ì¼ì •)
    
    // 1. ê¸°ì¤€ì´ ë  ê°ì²´ì™€ ì¹´ë©”ë¼ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
    const anchor = selectedMesh || [...selectedSet][0];
    const dist = camera.position.distanceTo(anchor.position);

    // 2. í˜„ì¬ ì¤Œ(ê±°ë¦¬)ì— ë§ì¶° ë§ˆìš°ìŠ¤ ì´ë™ ê°ë„ ìë™ ì¡°ì ˆ (ì´ê²Œ í•µì‹¬!)
    //    ê±°ë¦¬ê°€ ë©€ë©´ ë¹¨ë¦¬ ì›€ì§ì´ê³ , ê°€ê¹Œìš°ë©´ ì •ë°€í•˜ê²Œ ì›€ì§ì„
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const scale = (dist * Math.tan(vFov / 2) * 2) / window.innerHeight;

    // 3. ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥ì„ ë°”ë‹¥(XZí‰ë©´)ì— íˆ¬ì˜
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    
    // ì•ë’¤ ë°©í–¥ (Yì¶• ì œê±°í•´ì„œ ë°”ë‹¥ì— ë¶™ì„)
    const forward = new THREE.Vector3(camDir.x, 0, camDir.z).normalize();
    // ì¢Œìš° ë°©í–¥ (ì•ë’¤ ë²¡í„°ì™€ Yì¶•(0,1,0)ì˜ ì™¸ì )
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    // 4. ë§ˆìš°ìŠ¤ ì›€ì§ì„(dx, dy)ë§Œí¼ ì´ë™ ì ìš©
    //    ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½(+) -> Right ë²¡í„° ë°©í–¥
    //    ë§ˆìš°ìŠ¤ ì•„ë˜ìª½(+) -> Forward ë²¡í„° ë°˜ëŒ€ ë°©í–¥ (ë’¤ë¡œ)
    const moveVec = new THREE.Vector3();
    moveVec.addScaledVector(right, dx * scale);
    moveVec.addScaledVector(forward, -dy * scale); // ë§ˆìš°ìŠ¤ ìœ„ë¡œ ì˜¬ë¦¬ë©´ ì•ìœ¼ë¡œ ê°€ì•¼ í•˜ë¯€ë¡œ -dy

    // 5. ì„ íƒëœ ëª¨ë“  ë¬¼ì²´ ì´ë™
    if (snapEnabled) {
      // ìŠ¤ëƒ… ëª¨ë“œì¼ ë•ŒëŠ” ê¸°ì¡´ì²˜ëŸ¼ ìŠ¤ëƒ… ì ìš© (í•„ìš”ì‹œ êµ¬í˜„, ì—¬ê¸°ì„œëŠ” ë¶€ë“œëŸ¬ìš´ ì´ë™ ìš°ì„ )
      // ìŠ¤ëƒ…ì„ ìœ ì§€í•˜ê³  ì‹¶ë‹¤ë©´ ì´ë™ í›„ ìœ„ì¹˜ë¥¼ ë°˜ì˜¬ë¦¼í•˜ëŠ” ë¡œì§ì´ ì¶”ê°€ë˜ì–´ì•¼ í•˜ì§€ë§Œ,
      // ë“œë˜ê·¸ ê°ë„ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ìŠ¤ëƒ…ë³´ë‹¤ëŠ” ë¶€ë“œëŸ¬ìš´ ì´ë™ì´ ìš°ì„ ì…ë‹ˆë‹¤.
      // ì›í•˜ì‹ ë‹¤ë©´ ë‚˜ì¤‘ì— ìŠ¤ëƒ… ë¡œì§ì„ ì—¬ê¸°ì— ì„ì–´ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      translateSelection(moveVec.x, 0, moveVec.z); 
    } else {
      translateSelection(moveVec.x, 0, moveVec.z);
    }

  } else if (dragMode === "rect") {
    updateSelectionRect(e.clientX, e.clientY);

 } else if (dragMode === "rotate") {
  const sx = e.clientX;
  const sy = e.clientY;

  // ë§ˆìš°ìŠ¤ í˜„ì¬ ê°ë„
  const ang = Math.atan2(sy - rotateCenterScreen.y, sx - rotateCenterScreen.x);

  // ğŸ” ì„¸ ì¶• ì „ë¶€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ê°ë„ ê³„ì‚°
  let rawDelta = rotateStartAngle - ang;

  const stepDeg = 22.5;
  const stepRad = THREE.MathUtils.degToRad(stepDeg);

  let stepIndex = Math.round(rawDelta / stepRad);
  const snapped = stepIndex * stepRad;

  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];

  // ğŸŒ ì›”ë“œ ì¶• ê¸°ì¤€ íšŒì „ ì ìš©
  targets.forEach(obj => {
    const initQ = initialRotations.get(obj);
    if (!initQ) return;

    obj.quaternion.copy(initQ);

    // ğŸ”´ Xì¶•ë§Œ íšŒì „ ë°©í–¥ ë°˜ëŒ€ë¡œ ì ìš©
    const applied = (rotateAxis === "x") ? -snapped : snapped;
    obj.rotateOnWorldAxis(rotateWorldAxis, applied);
  });

  // ===== HUD ê°ë„ í‘œì‹œ =====
  const absIndex = Math.abs(stepIndex);
  let shownIndex = absIndex;
  if (absIndex > 8) shownIndex = 16 - absIndex;
  let shownDeg = shownIndex * stepDeg;

  let textDeg;
  if (Math.abs(shownDeg - Math.round(shownDeg)) < 1e-6) {
    textDeg = Math.round(shownDeg).toString();
  } else {
    textDeg = shownDeg.toFixed(1);
  }

  if (angleUI) {
    angleUI.style.display = "block";
    angleUI.textContent = `${rotateAxis.toUpperCase()} ${textDeg}Â°`;
    angleUI.style.left = rotateCenterScreen.x + "px";
    angleUI.style.top  = (rotateCenterScreen.y - 60) + "px";
  }
 if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
}


});

window.addEventListener("mouseup", e=>{
  if (dragMode === "rect") {
    const minX = Math.min(rectStartX, rectEndX);
    const minY = Math.min(rectStartY, rectEndY);
    const maxX = Math.max(rectStartX, rectEndX);
    const maxY = Math.max(rectStartY, rectEndY);
    const thresh = 5;

    if (maxX - minX < thresh && maxY - minY < thresh) {
      clearAllSelection();
    }

    hideSelectionRect();
  }

  if (dragMode === "rotate" && angleUI) {
    angleUI.style.display = "none";
  }

  dragging = false;
  dragMode = null;

  // âœ… ì¶”ê°€: ì–´ë–¤ ì´ìœ ë¡œë“  íŒŒë€ ë°•ìŠ¤ê°€ ë‚¨ìœ¼ë©´ ë¬´ì¡°ê±´ ëˆë‹¤
  hideSelectionRect();
});
window.addEventListener("blur", () => {
  dragging = false;
  dragMode = null;
  hideSelectionRect();
});


/* ========== ì¤Œ ========== */
window.addEventListener("wheel", (e) => {
    // UI ì²´í¬ ë¡œì§ ìƒëµ...
    e.preventDefault();

    // 1.02 (2%ì”© ë³€í™”)ë¡œ ìˆ˜ì •í•˜ì—¬ ì•„ì£¼ ì„¸ë°€í•˜ê²Œ ì¤Œì´ ë˜ë„ë¡ í•¨
    const zoomScale = e.deltaY > 0 ? 1.05 : 0.95;

    let newRadius = radius * zoomScale;
    newRadius = Math.max(0.1, Math.min(100000, newRadius));

    radius = newRadius;
    updateCamera();
}, { passive: false });




/* ========== í‚¤ë³´ë“œ: ì´ë™ + íšŒì „ + ë‹¨ì¶•í‚¤ ========== */
window.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();

// âœ… ì‹œì  ì´ˆê¸°í™” ë‹¨ì¶•í‚¤ (ìˆ«ì 0) - ê°•ì œ ë¦¬ì…‹ ë²„ì „
if (key === "c" ) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    console.log("ì‹œì  ì´ˆê¸°í™” ì‘ë™ ì‹œë„");

    // 1. ë§Œì•½ ë‹¤ë¥¸ ì´ë¦„ì˜ í•¨ìˆ˜ì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ê°€ì¥ í”í•œ ì´ë¦„ë“¤ ë‹¤ ì²´í¬
    const resetFunc = window.resetView || window.initView || window.resetCamera;
    
    if (typeof resetFunc === "function") {
        resetFunc();
        console.log("ê¸°ì¡´ í•¨ìˆ˜ë¡œ ë¦¬ì…‹ ì™„ë£Œ");
    } 
    // 2. í•¨ìˆ˜ê°€ ì—†ìœ¼ë©´ ì»¨íŠ¸ë¡¤ëŸ¬ ìì²´ë¥¼ ê°•ì œ ë¦¬ì…‹ (ëŒ€ë¶€ë¶„ì˜ Three.js í”„ë¡œì íŠ¸ í•´ë‹¹)
    else if (window.controls) {
        window.controls.reset(); 
        // controls.reset()ì´ ì‘ë™ ì•ˆ í•  ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì¢Œí‘œ ê°•ì œ ëŒ€ì…
        if (window.camera) {
            window.camera.position.set(500, 500, 500); // ë³´í†µ ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜
            window.controls.update();
        }
        console.log("ì»¨íŠ¸ë¡¤ëŸ¬ ê°•ì œ ë¦¬ì…‹ ì™„ë£Œ");
    }
    return;
}


// âœ… D : ì¹˜ìˆ˜ í† ê¸€
if (!e.ctrlKey && !e.metaKey && key === "d") {
  e.preventDefault();
  dimensionEnabled = !dimensionEnabled;
if (!dimensionEnabled) hideAllDimensions();
else showDimensionsSmartForSelection();
return;

}



  // L : íšŒì „ ë§ í‘œì‹œ
  if (!e.ctrlKey && !e.metaKey && key === "l") {
    gizmoEnabled = true;
    updateRotationGizmo();
    return;
  }

 if (e.ctrlKey || e.metaKey) {
  // âœ… Undo: Ctrl+Z
  if (key === "z" && !e.shiftKey) {
    e.preventDefault();
    undo();
    return;
  }

  // âœ… Redo: Ctrl+Shift+Z
  if (key === "z" && e.shiftKey) {
    e.preventDefault();
    redo();
    return;
  }

  // âœ… Redo: Ctrl+Y
  if (key === "y") {
    e.preventDefault();
    redo();
    return;
  }

  // âœ… Copy / Paste / SelectAll
  if (key === "c") { e.preventDefault(); copySelected(); return; }
  if (key === "v") { e.preventDefault(); pasteClipboard(); return; }
  if (key === "a") { e.preventDefault(); selectAll(); return; }
}



  // 1: ìŠ¤ëƒ… ì˜¨/ì˜¤í”„, 2: ìì„ í”Œë˜ê·¸
  if (key === "1") {
    snapEnabled = !snapEnabled;
    console.log("Snap:", snapEnabled);
    return;
  }
  if (key === "2") {
    magnetEnabled = !magnetEnabled;
    console.log("Magnet flag:", magnetEnabled, "(í˜„ì¬ëŠ” Aí‚¤/ë²„íŠ¼ìœ¼ë¡œ ì‹¤ì œ ì •ë ¬)");
    return;
  }

  if (key === "a") { attachSelectedGroup(); return; }
  if (key === "c") { cloneSelected(); return; }
  if (e.key === "Delete" || e.key === "Backspace") { deleteSelected(); return; }
  // â›”ï¸ ì—¬ê¸° ìˆë˜ if (key === "k") { groupSelected(); return; } ëŠ” ì‚­ì œ!

  if (key === "x") {
    focusOnSelection();
    return;
  }


  

  if (key === "b") {
    e.preventDefault();
    placeSelectionOnGround();
    return;
  }

  if (key === "p") {
    if (!selectedMesh && selectedSet.size === 0) {
      console.log("ì„ íƒëœ ë¶€ì†ì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }
    const target = selectedMesh || [...selectedSet][0];
    console.log("==== [P] ì„ íƒ ë¶€ì† í¬íŠ¸ ë””ë²„ê·¸ ====");
    console.log("userData.threadCenters:", target.userData && target.userData.threadCenters);
    console.log("userData.basePorts:",     target.userData && target.userData.basePorts);
    console.log("userData.rawThreadCenters:", target.userData && target.userData.rawThreadCenters);
    const pts = getWorldAttachPointsForMesh(target) || [];
    console.log("world attach points:", pts);
    return;
  }

  if (!selectedMesh && selectedSet.size === 0) return;

  let moveStep = baseMoveStep;
  if (e.shiftKey) moveStep *= 5;

  const rotateStep = THREE.MathUtils.degToRad(15);
  const targets = selectedSet.size > 0 ? [...selectedSet] : [selectedMesh];

  switch(key) {
    case "+":
      e.preventDefault();
      saveState();
      translateSelection(0, moveStep, 0);
      break;

    case "-":
      e.preventDefault();
      saveState();
      translateSelection(0, -moveStep, 0);
      break;

    case "q":
  saveState();
  targets.forEach(o => o.rotation.y += rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("y", targets[0].rotation.y);
  break;


    case "e":
  saveState();
  targets.forEach(o => o.rotation.y -= rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("y", targets[0].rotation.y);
  break;


  case "r":
  saveState();
  targets.forEach(o => o.rotation.x += rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("x", targets[0].rotation.x);
  break;


   case "f":
  saveState();
  targets.forEach(o => o.rotation.x -= rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("x", targets[0].rotation.x);
  break;


    case "t":
  saveState();
  targets.forEach(o => o.rotation.z += rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("z", targets[0].rotation.z);
  break;


   case "g":
  saveState();
  targets.forEach(o => o.rotation.z -= rotateStep);
  updateRotationGizmo();
  if (dimensionEnabled) showDimensionsForSelection(selectedMesh);
  showRotateHUD("z", targets[0].rotation.z);
  break;


    // ğŸ”¥ Kí‚¤ í† ê¸€: ê·¸ë£¹ / ê·¸ë£¹í•´ì œ
    case "k":
  e.preventDefault();

  // âœ… 2ê°œ ì´ìƒ ì„ íƒì´ë©´: ë¬´ì¡°ê±´ ê·¸ë£¹ ë§Œë“¤ê¸°
  if (selectedSet.size >= 2) {
    groupSelected();
  } else {
    // âœ… 1ê°œë§Œ ì„ íƒì´ë©´: ê·¸ë£¹ì´ë©´ í•´ì œ / ì•„ë‹ˆë©´(ë‹¨ì¼ ë©”ì‹œ) ê·¸ë£¹ ì‹œë„
    if (selectedMesh instanceof THREE.Group) ungroupSelected();
    else groupSelected();
  }
  break;






    case "arrowleft":
      e.preventDefault();
      saveState();
      // í™”ë©´ ê¸°ì¤€ ì™¼ìª½
      moveSelectionViewRelative(-moveStep, 0);
      break;

    case "arrowright":
      e.preventDefault();
      saveState();
      // í™”ë©´ ê¸°ì¤€ ì˜¤ë¥¸ìª½
      moveSelectionViewRelative(moveStep, 0);
      break;

    case "arrowup":
      e.preventDefault();
      saveState();
      // í™”ë©´ ê¸°ì¤€ ìœ„/ì•ìª½
      moveSelectionViewRelative(0, moveStep);
      break;

    case "arrowdown":
      e.preventDefault();
      saveState();
      // í™”ë©´ ê¸°ì¤€ ì•„ë˜/ë’¤ìª½
      moveSelectionViewRelative(0, -moveStep);
      break;
  }
  
});


window.addEventListener("keyup", (e) => {
  const key = e.key.toLowerCase();
  if (key === "l") {
    gizmoEnabled = false;
    hoveredAxis = null;
    updateRingHoverVisuals(null);
    updateRotationGizmo();

    if (dragMode === "rotate") {
      dragMode = null;
      dragging = false;
      if (angleUI) angleUI.style.display = "none";
    }
  }
});

/* ========== ë Œë” ë£¨í”„ & ë¦¬ì‚¬ì´ì¦ˆ ========== */
function animate(){
  requestAnimationFrame(animate);

  // âœ… íšŒì „/ì´ë™í•˜ë©´ ì¹˜ìˆ˜ë„ ê°™ì´ ë”°ë¼ê°€ê²Œ
  updateDimensionsAuto();

  renderer.render(scene,camera);
}


/* â˜… ì²« í™”ë©´ ì¹´ë©”ë¼ ì„¸íŒ… + ë Œë” ì‹œì‘ */
initFirstView();
updateCamera();
setView("front");
saveState();
animate();


window.addEventListener("resize",()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  updateRotationGizmo();
});


/* =========================
   âœ… Plate(ì‚¬ê°/ì›í˜•) ìƒ‰ìƒ/ë¶ˆíˆ¬ëª…ë„ UI
========================= */

function isPlateObject(obj) {
  return !!(obj?.userData?.isRectPlate || (obj?.userData?.isPlate && obj?.userData?.plateShape === "circle"));
}

function setObjectOpacityDeep(obj, opacity01) {
  obj.traverse(o => {
    if (!o.isMesh || !o.material) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];
    mats.forEach(m => {
      if (!m) return;
      m.transparent = (opacity01 < 0.999);
      m.opacity = opacity01;
      m.needsUpdate = true;
    });
  });
}

function setObjectColorDeep(obj, hexColor) {
  obj.traverse(o => {
    if (!o.isMesh || !o.material) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];
    mats.forEach(m => {
      if (!m) return;
      if (m.color && m.color.set) m.color.set(hexColor);
      m.needsUpdate = true;
    });
  });
}

function getSelectedPlates() {
  const targets = selectedSet.size > 0 ? [...selectedSet] : (selectedMesh ? [selectedMesh] : []);
  return targets.filter(isPlateObject);
}

// âœ… Undo ìŠ¤íƒì„ ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì¤‘ â€œí•œ ë²ˆë§Œâ€ ì €ì¥í•˜ê¸° ìœ„í•œ í”Œë˜ê·¸
let plateOpacityDragArmed = false;

function applyPlateOpacityFromUI(live = true) {
  const slider = document.getElementById("plateOpacity");
  const label  = document.getElementById("plateOpacityLabel");
  if (!slider) return;

  const v = parseInt(slider.value, 10);
  const opacity = Math.max(0.05, Math.min(1, v / 100));
  if (label) label.textContent = `${v}%`;

  const plates = getSelectedPlates();
  if (!plates.length) return; // ì‹¤ì‹œê°„ì€ ì¡°ìš©íˆ ë¬´ì‹œ(ì•ŒëŸ¿ X)

  // âœ… ë“œë˜ê·¸ ì‹œì‘ ì‹œì ì—ë§Œ saveState() 1íšŒ
  if (live && plateOpacityDragArmed) {
    saveState();
    plateOpacityDragArmed = false;
  }

  plates.forEach(p => setObjectOpacityDeep(p, opacity));
}

function getPlateUIChosenColor() {
  const picker = document.getElementById("plateColorPicker");
  if (picker && typeof picker.value === "string" && picker.value.trim()) return picker.value.trim();
  return (typeof window.__lastPlateColor === "string" && window.__lastPlateColor.trim()) ? window.__lastPlateColor.trim() : null;
}

// âœ… "ì„ íƒ íŒì— ì ìš©" ë²„íŠ¼: íˆ¬ëª…ë„ + ìƒ‰ìƒ(ì»¬ëŸ¬í”¼ì»¤/ë§ˆì§€ë§‰ íŒ”ë ˆíŠ¸) ë™ì‹œì— 1ë²ˆ Undoë¡œ ì ìš©
function applyPlateStyleFromUI() {
  const plates = getSelectedPlates();
  if (!plates.length) {
    alert("íŒ(ì‚¬ê°/ì›í˜•)ì„ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  const slider = document.getElementById("plateOpacity");
  const label  = document.getElementById("plateOpacityLabel");
  const v = slider ? parseInt(slider.value, 10) : 100;
  const opacity = Math.max(0.05, Math.min(1, (isFinite(v) ? v : 100) / 100));
  if (label && isFinite(v)) label.textContent = `${v}%`;

  const color = getPlateUIChosenColor();

  saveState(); // âœ… Undo 1íšŒ

  plates.forEach(p => {
    setObjectOpacityDeep(p, opacity);

    if (color) {
      setObjectColorDeep(p, color);
      p.userData = p.userData || {};
      p.userData.color = color; // ì €ì¥/ë³µì›ìš©
    }
  });
}

function applyPlateColor(hex) {
  window.__lastPlateColor = hex;
  const picker = document.getElementById("plateColorPicker");
  if (picker && picker.value !== hex) picker.value = hex;
  try{ syncPlateSwatchesFromColor(hex); }catch(e){}
  // âœ… ì‚¬ê°/ì›í˜•íŒ ëª¨ë‘ í¬í•¨ + null ì•ˆì „
  const plates = getSelectedPlates(); // getSelectedPlates()ëŠ” isPlateObjectë¡œ ê±°ë¦„ :contentReference[oaicite:3]{index=3}
  if (!plates || plates.length === 0) return;

  saveState(); // âœ… Undo 1íšŒ

  plates.forEach(p => {
    if (!p) return;
    setObjectColorDeep(p, hex);  // íŒ ë‚´ë¶€ meshê¹Œì§€ ìƒ‰ ì ìš© :contentReference[oaicite:4]{index=4}
    p.userData = p.userData || {};
    p.userData.color = hex; // ì €ì¥/ë³µì›ìš©
  });

  const preview = document.getElementById("plateColorPreview");
  if (preview) preview.style.background = hex;

 
}




/* ===== íŒ”ë ˆíŠ¸ êµ¬ì„± ===== */
const PLATE_PALETTE = [
  "#ffffff","#cfcfcf","#8a8a8a","#3a3a3a","#000000",
  "#ff3b3b","#ff8a00","#ffd400","#43d854","#2ea8ff",
  "#7a5cff","#ff4fd8","#8b5a2b","#4b2e1f","#d8b48a",
  "#2b2b2b","#1f3b4b","#3b1f4b","#1f4b2b","#4b1f1f"
];

(function bindPlateUI(){
  // âœ… ìš°ì¸¡ íŒ¨ë„ ìœ„ì—ì„œëŠ” ì”¬(ìº”ë²„ìŠ¤) ì¡°ì‘ ì´ë²¤íŠ¸ë¡œ ì „íŒŒë˜ì§€ ì•Šê²Œë§Œ ë§‰ê³ ,
  //    íŒ¨ë„ ë‚´ë¶€ ë²„íŠ¼/ìŠ¬ë¼ì´ë” í´ë¦­ì€ ì •ìƒ ë™ì‘í•˜ê²Œ í•œë‹¤.

  const rightPanel = document.getElementById("rightUI"); // âœ… ì‹¤ì œ id
  if (!rightPanel) {
    console.warn("[bindPlateUI] #rightUI ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
    return;
  }

  // âœ… í•µì‹¬: capture:false(ë²„ë¸” ë‹¨ê³„)ë¡œ ë§‰ì•„ì•¼ ë‚´ë¶€ ë²„íŠ¼ í´ë¦­ì´ ì‚´ì•„ìˆìŒ
  const blockTypes = [
    "pointerdown","pointermove","pointerup",
    "mousedown","mousemove","mouseup",
    "touchstart","touchmove","touchend",
    "click","dblclick","contextmenu"
  ];

  blockTypes.forEach(type => {
    rightPanel.addEventListener(type, (e) => {
      e.stopPropagation();
      // e.preventDefault(); // âŒ ê¸°ë³¸ë™ì‘(ë²„íŠ¼ í´ë¦­/í¬ì»¤ìŠ¤)ì€ ì‚´ë ¤ë‘ëŠ” ê²Œ ì•ˆì „
    }, { capture: false });
  });

  // âœ… íœ : íŒ¨ë„ ìŠ¤í¬ë¡¤ì€ ì‚´ë¦¬ê³ , ì”¬ìœ¼ë¡œë§Œ ì•ˆ ë‚´ë ¤ê°€ê²Œ
  rightPanel.addEventListener("wheel", (e) => {
    e.stopPropagation();
  }, { capture: false, passive: true });

  // ------------------------------
  // ì•„ë˜ë¶€í„°ëŠ” "ìˆìœ¼ë©´ ì—°ê²° / ì—†ìœ¼ë©´ ë¬´ì‹œ" ë°©ì‹ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°”ì¸ë”©
  // ------------------------------

  // âœ… íŒ”ë ˆíŠ¸ ìŠ¤ì™€ì¹˜ ìƒì„±
  const swWrap = document.getElementById("plateSwatches");
  if (swWrap && typeof PLATE_PALETTE !== "undefined") {
    swWrap.innerHTML = "";
    PLATE_PALETTE.forEach(hex => {
      const d = document.createElement("div");
      d.className = "swatch";
      d.style.background = hex;
      d.title = hex;
      d.addEventListener("click", () => applyPlateColor(hex));
      swWrap.appendChild(d);
    });
  }

  // âœ… í”„ë¦¬ë·° ì´ˆê¸°ìƒ‰
  const preview = document.getElementById("plateColorPreview");
  if (preview) preview.style.background = preview.style.background || "#4b2e1f";

  // âœ… íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë”
  const slider = document.getElementById("plateOpacity");
  if (slider) {
    slider.addEventListener("pointerdown", () => { plateOpacityDragArmed = true; });
    slider.addEventListener("input", () => { applyPlateOpacityFromUI(true); });
    slider.addEventListener("pointerup", () => { plateOpacityDragArmed = false; });
    slider.addEventListener("change", () => { applyPlateOpacityFromUI(false); });
  }

  // âœ… ì»¬ëŸ¬í”¼ì»¤(ë„¤ê°€ ì£¼ì„ì²˜ë¦¬í•˜ë©´ ì—†ì–´ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ "ìˆì„ ë•Œë§Œ" ì—°ê²°)
  const picker = document.getElementById("plateColorPicker");
  if (picker) {
    picker.addEventListener("input", () => {
      const hex = picker.value;
      const pv = document.getElementById("plateColorPreview");
      if (pv) pv.style.background = hex;

      // ì‹¤ì‹œê°„ ë°˜ì˜(Undo ëˆ„ì  ë°©ì§€í•˜ë ¤ë©´ saveState ì—†ì´ ìƒ‰ë§Œ ë°˜ì˜)
      const plates = getSelectedPlates();
      if (!plates.length) return;
      plates.forEach(p => setObjectColorDeep(p, hex));
      render();
    });

    picker.addEventListener("change", () => {
      applyPlateColor(picker.value); // âœ… saveState í¬í•¨
    });
  }
})();




function updateNominalUI() {
  const b15 = document.getElementById("nom15");
  const b20 = document.getElementById("nom20");
  if (!b15 || !b20) return;

  b15.classList.toggle("active", CURRENT_NOMINAL === "15A");
  b20.classList.toggle("active", CURRENT_NOMINAL === "20A");
}

function setNominal(nominal) {
  if (!NOMINAL_SCALE[nominal]) return;
  CURRENT_NOMINAL = nominal;
  updateNominalUI();
  console.log("CURRENT_NOMINAL =", CURRENT_NOMINAL);
}

/* âœ… ìµœì´ˆ ë¡œë“œ ì‹œì—ë„ í™œì„±í™” í‘œì‹œ */
updateNominalUI();






/* =================================================================
   [ìˆ˜ì •ë¨] ìŠ¤ëƒ… í¬ì¸íŠ¸ ì‹œê°í™” í•¨ìˆ˜ (ì  í‘œì‹œ ê¸°ëŠ¥ ì‚­ì œë¨)
   ================================================================= */
function updatePortVisuals(obj) {
  // 1. ê¸°ì¡´ì— ë– ìˆëŠ” ì ë“¤ì´ ìˆë‹¤ë©´ ì‹¹ ì§€ì›Œì¤ë‹ˆë‹¤.
  if (typeof portHelpers !== 'undefined') {
    portHelpers.forEach(h => { 
      if(h.parent) h.parent.remove(h); 
    });
    portHelpers = [];
  }

  // 2. ìƒˆë¡œìš´ ì ì„ ë§Œë“œëŠ” ì½”ë“œëŠ” ë‹¤ ì‚­ì œí–ˆìœ¼ë¯€ë¡œ, 
  //    ì´ì œ ì•„ë¬´ê²ƒë„ í™”ë©´ì— ê·¸ë ¤ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.
}



/* â–¼â–¼â–¼ <script> íƒœê·¸ ì•ˆìª½(ë§¨ ì•„ë˜)ì— ë„£ìœ¼ì„¸ìš” â–¼â–¼â–¼ */

/* =================================================================
   [UI ë¡œì§] ì‚¬ì´ì¦ˆ ì„ íƒ ë° í†µí•© ìƒì„± í•¨ìˆ˜ (Dispatcher)
   ================================================================= */


// 1. íƒ­ ë³€ê²½ í•¨ìˆ˜
function setNominalMode(size) {
  CURRENT_NOMINAL = size;
  
  const btn15 = document.getElementById('btnTab15');
  const btn20 = document.getElementById('btnTab20');
  
  if(btn15 && btn20) {
    btn15.className = (size === '15A' ? 'tab-btn active' : 'tab-btn');
    btn20.className = (size === '20A' ? 'tab-btn active' : 'tab-btn');
  }
  
  console.log("í˜„ì¬ ëª¨ë“œ ë³€ê²½:", CURRENT_NOMINAL);
}

// 2. í†µí•© ìƒì„± í•¨ìˆ˜ë“¤
function spawnSocket() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralSocket15A();
  else spawnProceduralSocket20A();
}

function spawnElbow() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralElbow15A();
  else spawnProceduralElbow20A();
}

function spawn45Elbow() {
  if (CURRENT_NOMINAL === '15A') spawnProcedural45Elbow15A();
  else spawnProcedural45Elbow20A();
}

function spawnTee() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralTee15A();
  else spawnProceduralTee20A();
}

function spawnCap() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralCap15A();
  else spawnProceduralCap20A();
}

function spawnPlug() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralPlug15A();
  else spawnProceduralPlug20A();
}

function spawnUnion() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralUnion15A();
  else spawnProceduralUnion20A();
}

function spawnFlange() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralFlange15A();
  else spawnProceduralFlange20A();
}

function spawnCrossTee() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralCrossTee15A();
  else spawnProceduralCrossTee20A();
}

function spawnSOTee() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralSOTee15A();
  else spawnProceduralSOTee20A();
}

function spawnSOElbow() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralSOElbow15A();
  else spawnProceduralSOElbow20A();
}

// [ì—°ê²° ë¶€ì† ë¡œì§]
function spawnReducer() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralReducer20A15A();
  else spawnProceduralReducer25A20A();
}

function spawnBushing() {
  if (CURRENT_NOMINAL === '15A') spawnProceduralBushing20A15A();
  else spawnProceduralBushing25A20A();
}



</script>



<script>
/* =========================================================
   âœ… ë¹ˆ ìŠ¤ì™€ì¹˜ ìŠ¬ë¡¯ ë°©ì‹(ê³ ì • ê°œìˆ˜)
   - ê¸°ë³¸ íŒ”ë ˆíŠ¸ëŠ” 'ë¹ˆì¹¸(ì ì„ )' 12ê°œ
   - ì»¬ëŸ¬í”¼ì»¤ì—ì„œ ìƒ‰ í™•ì •(change) ì‹œ: ì²« ë¹ˆì¹¸ì„ ì±„ì›€
   - ì¤‘ë³µ ìƒ‰ì´ë©´ í•´ë‹¹ ì¹¸ë§Œ í•˜ì´ë¼ì´íŠ¸/í™œì„±
   - localStorageë¡œ ì €ì¥/ë³µì›
========================================================= */
function slots(){
  // DOM ìˆœì„œ(=ìœ„ì—ì„œë¶€í„°/ì™¼ìª½ë¶€í„°) ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ê²Œ ê³ ì •
  return Array.from(document.querySelectorAll(".color-swatches .swatch:not(.fixed)"));
}

function clearSwatchSlot(sw){
  sw.dataset.color = "";
  sw.classList.add("empty");
  sw.style.background = "transparent";
  sw.title = "ë¹ˆ ìŠ¬ë¡¯";

  // ì´ë²¤íŠ¸ ì œê±°
  sw.onclick = null;
  sw.oncontextmenu = null;

  // active í‘œì‹œë„ ì œê±°(ì„ íƒì‚¬í•­)
  sw.classList.remove("active");
}

function fillSlot(sw, hex){
  hex = normHex(hex);

  sw.dataset.color = hex;
  sw.classList.remove("empty");
  sw.style.background = hex;
  sw.title = hex;

  // âœ… í´ë¦­í•  ë•ŒëŠ” â€œí˜„ì¬ sw.dataset.colorâ€ë¥¼ ì½ì–´ì„œ ì ìš© (í´ë¡œì € ê¼¬ì„ ë°©ì§€)
  sw.onclick = (e) => {
    // Shift+í´ë¦­ = ì‚­ì œ
    if (e.shiftKey) {
      clearSwatchSlot(sw);
      return;
    }

    const cur = normHex(sw.dataset.color);
    if (!cur) return;

    if (typeof applyPlateColor === "function") {
      applyPlateColor(cur);
    }
  };

  // âœ… ìš°í´ë¦­ = ì‚­ì œ
  sw.oncontextmenu = (e) => {
    e.preventDefault();
    clearSwatchSlot(sw);
  };
}

// âœ… â€œì•(ì²« ë¹ˆì¹¸)â€ë¶€í„° ì±„ìš°ê¸° + ì¤‘ë³µì´ë©´ í™œì„±í™”ë§Œ
window.addOrActivateSwatch = function(hex){
  hex = normHex(hex);
  if (!hex) return;

  const s = slots();
  if (!s.length) return;

  // 1) ì´ë¯¸ ìˆìœ¼ë©´ activeë§Œ
  const existing = s.find(sw => normHex(sw.dataset.color) === hex);
  if (existing) {
    try { syncPlateSwatchesFromColor(hex); } catch(e){}
    return;
  }

  // 2) ì²« ë¹ˆì¹¸(ìœ„/ì™¼ìª½ë¶€í„°) ì±„ìš°ê¸°
  const empty = s.find(sw => sw.classList.contains("empty") || !normHex(sw.dataset.color));
  if (empty) {
    fillSlot(empty, hex);
    try { syncPlateSwatchesFromColor(hex); } catch(e){}
    return;
  }

  // 3) ë¹ˆì¹¸ ì—†ìœ¼ë©´ â€œë§ˆì§€ë§‰ ì¹¸â€ ë®ì–´ì“°ê¸°
  fillSlot(s[s.length - 1], hex);
  try { syncPlateSwatchesFromColor(hex); } catch(e){}
};


/* ========== ì¹´ë©”ë¼ ì´ˆê¸°í™” í•¨ìˆ˜ (ì²« í™”ë©´ê³¼ ì™„ë²½ ë™ì¼) ========== */
function resetCamera() {
  // 1. íšŒì „ ì¤‘ì‹¬ì„ ì›”ë“œ ì¢Œí‘œ (0, 0, 0)ìœ¼ë¡œ ì´ˆê¸°í™”
  camTarget.set(0, 0, 0);

  // 2. ì´ˆê¸° ì¹´ë©”ë¼ ê±°ë¦¬ (ì‚¬ìš©ì íŒŒì¼ì˜ ê¸°ë³¸ê°’ radius = 20)
  // 5000ì—ì„œ 20ìœ¼ë¡œ ìˆ˜ì •í•˜ì—¬ ë¬¼ì²´ê°€ í¬ê²Œ ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
  radius = 20; 

  // 3. ì´ˆê¸° ê°ë„ (ì‚¬ìš©ì íŒŒì¼ì˜ ê¸°ë³¸ê°’ theta = PI*0.5, phi = PI*0.35)
  // ì´ ê°ë„ê°€ "ì •ë©´ì—ì„œ ì•½ê°„ ìœ„"ë¥¼ ë³´ëŠ” ê°€ì¥ ê¹”ë”í•œ ì‹œì ì…ë‹ˆë‹¤.
  theta = Math.PI * 0.5; 
  phi   = Math.PI * 0.35; 

  // 4. ì¦‰ì‹œ ë°˜ì˜
  updateCamera();

  console.log("ì²« í™”ë©´ ì‹œì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
}

/* ========== [ìˆ˜ì •] ëª¨ë“  UI íŒ¨ë„(ì¢Œ, ìš°, ìƒë‹¨) ë‚´ ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€ ========== */
[
  document.getElementById("ui"), 
  document.getElementById("rightUI"), 
  document.getElementById("topViewBar")
].forEach(panel => {
  if (panel) {
    panel.addEventListener("contextmenu", (e) => {
      // ë¸Œë¼ìš°ì € ê¸°ë³¸ ë©”ë‰´ ì¶œë ¥ì„ ì°¨ë‹¨í•˜ê³  ì´ë²¤íŠ¸ ì „íŒŒë¥¼ ë§‰ìŠµë‹ˆë‹¤.
      e.preventDefault();
      e.stopPropagation();
    }, false);
  }
});
</script>
</body>
</html>
